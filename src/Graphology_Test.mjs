// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Nodefs from "node:fs";
import * as Stdlib__Option from "@dsiu/rescript-stdlib-fp/src/Stdlib__Option.mjs";
import * as Graphology__Graph from "@dsiu/rescript-graphology/src/Graphology__Graph.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

var G = Graphology__Graph.MakeGraph({});

function make(graph) {
  return {
          graph: graph,
          queue: [],
          seen: new Set(),
          size: 0
        };
}

function size(t) {
  return t.size;
}

function hasAlreadySeenEverything(t) {
  return t.seen.size === G.order(t.graph);
}

function countUnseenNodes(t) {
  return G.order(t.graph) - t.seen.size | 0;
}

function forEachNodeYetUnseen(t, callback) {
  var seen = t.seen;
  var graph = t.graph;
  return G.NodesIter.someNode(graph, (function (node, attr) {
                if (seen.size === G.order(graph)) {
                  return true;
                }
                if (seen.has(node)) {
                  return false;
                }
                var shouldBreak = callback(node, attr);
                if (shouldBreak) {
                  return true;
                } else {
                  return false;
                }
              }));
}

function has(t, node) {
  return t.seen.has(node);
}

function push(t, node) {
  var seenSizeBefore = t.seen.size;
  t.seen.add(node);
  if (seenSizeBefore === t.seen.size) {
    return [
            t,
            false
          ];
  } else {
    t.queue.push(node);
    return [
            {
              graph: t.graph,
              queue: t.queue,
              seen: t.seen,
              size: t.size + 1 | 0
            },
            true
          ];
  }
}

function pushWith(t, node, item) {
  var seenSizeBefore = t.seen.size;
  t.seen.add(node);
  if (seenSizeBefore === t.seen.size) {
    return [
            t,
            false
          ];
  } else {
    t.queue.push(item);
    return [
            {
              graph: t.graph,
              queue: t.queue,
              seen: t.seen,
              size: t.size + 1 | 0
            },
            true
          ];
  }
}

function shift(t) {
  var item = Stdlib__Option.getExn(t.queue.shift());
  return [
          {
            graph: t.graph,
            queue: t.queue,
            seen: t.seen,
            size: t.queue.length
          },
          item
        ];
}

var BFSQueue = {
  make: make,
  size: size,
  hasAlreadySeenEverything: hasAlreadySeenEverything,
  countUnseenNodes: countUnseenNodes,
  forEachNodeYetUnseen: forEachNodeYetUnseen,
  has: has,
  push: push,
  pushWith: pushWith,
  shift: shift
};

function abstractBfs(graph, startingNode, callback, options) {
  make(graph);
}

var BFS_Graphology = {
  BFSQueue: BFSQueue,
  abstractBfs: abstractBfs,
  bfsFromNode: abstractBfs
};

function stringToFile(str, fileName) {
  Nodefs.writeFileSync(fileName, Buffer.from(str));
}

function writeToFile(g, filename) {
  var gexfStrWithOptions = G.GEXF.write(g, {
        formatNode: (function (key, _attributes) {
            return {
                    label: key,
                    attributes: {
                      name: key
                    }
                  };
          }),
        formatEdge: (function (key, _attributes) {
            return {
                    label: key,
                    attributes: {
                      name: key
                    }
                  };
          }),
        version: "1.3"
      });
  stringToFile(gexfStrWithOptions, filename);
}

var GEXF = {
  writeToFile: writeToFile
};

var g = G.makeGraph(undefined);

G.mergeEdge(g, "1", "2", undefined);

G.mergeEdge(g, "1", "3", undefined);

G.mergeEdge(g, "1", "4", undefined);

G.mergeEdge(g, "2", "5", undefined);

G.mergeEdge(g, "2", "6", undefined);

G.mergeEdge(g, "4", "7", undefined);

G.mergeEdge(g, "4", "8", undefined);

G.mergeEdge(g, "5", "9", undefined);

G.mergeEdge(g, "5", "10", undefined);

G.mergeEdge(g, "7", "11", undefined);

G.mergeEdge(g, "7", "12", undefined);

var prim = G.inspect(g);

console.log(prim);

console.log("BFS");

abstractBfs(g, "1", (function (node, attr, depth) {
        console.log([
              node,
              attr,
              depth
            ]);
      }), undefined);

writeToFile(g, "./graph.gexf");

var BFS = {};

export {
  log ,
  log2 ,
  G ,
  BFS_Graphology ,
  stringToFile ,
  GEXF ,
  BFS ,
}
/* G Not a pure module */
