// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Belt_HashMap = require("rescript/lib/js/belt_HashMap.js");
var Belt_HashMapString = require("rescript/lib/js/belt_HashMapString.js");
var Belt_HashSetString = require("rescript/lib/js/belt_HashSetString.js");

function toString(t) {
  var str = {
    contents: ""
  };
  Belt_HashMapString.forEach(t, (function (k, v) {
          str.contents = str.contents + k + ": [ " + Belt_HashSetString.toArray(v).join(",") + " ]\n";
          
        }));
  return str.contents;
}

function addVertex(t, x) {
  var match = Belt_HashMapString.get(t, x);
  if (match !== undefined) {
    return ;
  } else {
    return Belt_HashMapString.set(t, x, Belt_HashSetString.make(40));
  }
}

var removeVertex = Belt_HashMapString.remove;

function getVertex(t, x) {
  addVertex(t, x);
  var v = Belt_HashMapString.get(t, x);
  if (v !== undefined) {
    return Caml_option.valFromOption(v);
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function addEdge(t, x, y) {
  return Belt_HashSetString.add(getVertex(t, x), y);
}

function removeEdge(t, x, y) {
  if (Belt_HashMapString.has(t, x)) {
    return Belt_HashSetString.remove(getVertex(t, x), y);
  }
  
}

function adjacent(t, x, y) {
  var v = Belt_HashMap.get(t, x);
  if (v !== undefined) {
    return Belt_HashSetString.has(Caml_option.valFromOption(v), y);
  } else {
    return false;
  }
}

function neighbors(t, x) {
  return Belt_Option.getWithDefault(Belt_HashMapString.get(t, x), Belt_HashSetString.make(40));
}

var make = Belt_HashMapString.make;

exports.make = make;
exports.toString = toString;
exports.addVertex = addVertex;
exports.removeVertex = removeVertex;
exports.getVertex = getVertex;
exports.addEdge = addEdge;
exports.removeEdge = removeEdge;
exports.adjacent = adjacent;
exports.neighbors = neighbors;
/* No side effect */
