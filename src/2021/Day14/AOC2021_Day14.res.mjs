// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Utils from "../../Utils.res.mjs";
import * as Belt_List from "rescript/lib/es6/Belt_List.js";
import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/Belt_Option.js";
import * as Belt_MutableMapString from "rescript/lib/es6/Belt_MutableMapString.js";

function log(prim) {
  console.log(prim);
}

function update_value_inc_by_1(h, k) {
  return Utils.mutableMapStringUpdate(h, k, Utils.increaseBy1L);
}

function update_value_inc_by_n(h, k, n) {
  return Utils.mutableMapStringUpdate(h, k, __x => Utils.increaseByBigInt(__x, n));
}

function make(template, rules) {
  let r = Belt_MutableMapString.make();
  return {
    template: Belt_List.fromArray(template),
    rules: (Belt_Array.forEach(rules, param => {
      Belt_MutableMapString.set(r, param[0], param[1]);
    }), r)
  };
}

function morph(a, b, rules) {
  let k = a + b;
  return Belt_Option.getExn(Belt_MutableMapString.get(rules, k));
}

function iterate_no_tail_opt(param) {
  let inner = (l, rules) => {
    if (!l) {
      return /* [] */0;
    }
    let match = l.tl;
    let last = l.hd;
    if (!match) {
      return {
        hd: last,
        tl: /* [] */0
      };
    }
    let h2 = match.hd;
    return Belt_List.concat({
      hd: last,
      tl: {
        hd: morph(last, h2, rules),
        tl: /* [] */0
      }
    }, inner({
      hd: h2,
      tl: match.tl
    }, rules));
  };
  return inner(param.template, param.rules);
}

function iterate_tail_opt(param) {
  let _l = param.template;
  let rules = param.rules;
  let _acc = /* [] */0;
  while (true) {
    let acc = _acc;
    let l = _l;
    if (!l) {
      return acc;
    }
    let match = l.tl;
    let last = l.hd;
    if (!match) {
      return Belt_List.concat(acc, {
        hd: last,
        tl: /* [] */0
      });
    }
    let h2 = match.hd;
    _acc = Belt_List.concat(acc, {
      hd: last,
      tl: {
        hd: morph(last, h2, rules),
        tl: /* [] */0
      }
    });
    _l = {
      hd: h2,
      tl: match.tl
    };
    continue;
  };
}

function iterateN_tail_opt(param, n) {
  let _t = param.template;
  let r = param.rules;
  let _n = n;
  while (true) {
    let n$1 = _n;
    let t = _t;
    if (n$1 === 0) {
      return t;
    }
    _n = n$1 - 1 | 0;
    _t = iterate_tail_opt({
      template: t,
      rules: r
    });
    continue;
  };
}

function solve_with_result(t, n) {
  let ret = iterateN_tail_opt(t, n);
  let r = Belt_MutableMapString.toArray(Belt_List.reduce(ret, Belt_MutableMapString.make(), (acc, k) => Utils.mutableMapStringUpdate(acc, k, Utils.increaseBy1L)));
  let match = Utils.maxKeyBigIntValuePair(r);
  let match$1 = Utils.minKeyBigIntValuePair(r);
  return match[1] - match$1[1];
}

function genPairsMap(template) {
  let acc = Belt_MutableMapString.make();
  let _l = template;
  while (true) {
    let l = _l;
    if (!l) {
      return acc;
    }
    let match = l.tl;
    let last = l.hd;
    if (!match) {
      return Utils.mutableMapStringUpdate(acc, last, Utils.increaseBy1L);
    }
    let h2 = match.hd;
    Utils.mutableMapStringUpdate(acc, last + h2, Utils.increaseBy1L);
    _l = {
      hd: h2,
      tl: match.tl
    };
    continue;
  };
}

function genNewKeys(k, rules) {
  let match = k.length;
  if (match === 1) {
    return [k];
  }
  if (match !== 2) {
    throw {
      RE_EXN_ID: "Not_found",
      Error: new Error()
    };
  }
  let a = k.substring(0, 1);
  let b = k.substring(1, 2);
  let c = morph(a, b, rules);
  return [
    a + c,
    c + b
  ];
}

function iterate(m, rules) {
  let m$p = Belt_MutableMapString.make();
  Belt_MutableMapString.forEach(m, (k, v) => Belt_Array.forEach(genNewKeys(k, rules), k$p => {
    update_value_inc_by_n(m$p, k$p, v);
  }));
  return m$p;
}

function iterateN(param, n) {
  let init = genPairsMap(param.template);
  let _m = init;
  let r = param.rules;
  let _n = n;
  while (true) {
    let n$1 = _n;
    let m = _m;
    if (n$1 === 0) {
      return m;
    }
    _n = n$1 - 1 | 0;
    _m = iterate(m, r);
    continue;
  };
}

function countPolymers(m, template) {
  let r = Belt_MutableMapString.make();
  Belt_MutableMapString.forEach(m, (k, v) => Belt_Array.forEach(Utils.splitChars(k), c => {
    update_value_inc_by_n(r, c, v);
  }));
  let first_poly = Belt_List.headExn(template);
  Belt_MutableMapString.forEach(r, (k, v) => {
    let v$p = k === first_poly ? (v + 1n) / 2n : v / 2n;
    Belt_MutableMapString.set(r, k, v$p);
  });
  return r;
}

function solve(t, n) {
  let r = iterateN(t, n);
  let c = Belt_MutableMapString.toArray(countPolymers(r, t.template));
  let match = Utils.maxKeyBigIntValuePair(c);
  let match$1 = Utils.minKeyBigIntValuePair(c);
  return match[1] - match$1[1];
}

function part1(__x) {
  return solve_with_result(__x, 10);
}

function part2(__x) {
  return solve(__x, 40);
}

let Polymer = {
  make: make,
  morph: morph,
  iterate_no_tail_opt: iterate_no_tail_opt,
  iterate_tail_opt: iterate_tail_opt,
  iterateN_tail_opt: iterateN_tail_opt,
  solve_with_result: solve_with_result,
  genPairsMap: genPairsMap,
  genNewKeys: genNewKeys,
  iterate: iterate,
  iterateN: iterateN,
  countPolymers: countPolymers,
  solve: solve,
  part1: part1,
  part2: part2
};

function parse(data) {
  let parsed = Utils.splitDoubleNewline(data);
  let template = Belt_Option.getExn(Belt_Array.get(parsed, 0));
  let rules = Belt_Option.getExn(Belt_Array.get(parsed, 1));
  return [
    template.trim().split(""),
    Belt_Array.map(Utils.splitNewline(rules), x => {
      let s = x.trim().split(" -> ");
      return [
        Belt_Option.getExn(Belt_Array.get(s, 0)),
        Belt_Option.getExn(Belt_Array.get(s, 1))
      ];
    })
  ];
}

function solvePart1(data) {
  let match = parse(data);
  return solve_with_result(make(match[0], match[1]), 10);
}

function solvePart2(data) {
  let match = parse(data);
  return solve(make(match[0], match[1]), 40);
}

export {
  log,
  update_value_inc_by_1,
  update_value_inc_by_n,
  Polymer,
  parse,
  solvePart1,
  solvePart2,
}
/* Utils Not a pure module */
