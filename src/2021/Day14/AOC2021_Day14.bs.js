// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Belt_List = require("rescript/lib/js/belt_List.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Pervasives = require("rescript/lib/js/pervasives.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Belt_HashMapString = require("rescript/lib/js/belt_HashMapString.js");
var Utils$AdventOfCode = require("../../Utils.bs.js");

function log(prim) {
  console.log(prim);
  
}

function make(template, rules) {
  var r = Belt_HashMapString.make(40);
  return {
          template: Belt_List.fromArray(template),
          rules: (Belt_Array.forEach(rules, (function (param) {
                    Belt_HashMapString.set(r, param[0], param[1]);
                    
                  })), r)
        };
}

function morph(a, b, rules) {
  var k = a + b;
  return Belt_Option.getExn(Belt_HashMapString.get(rules, k));
}

function iterate_no_tail_opt(param) {
  var inner = function (l, rules) {
    if (!l) {
      return /* [] */0;
    }
    var match = l.tl;
    var last = l.hd;
    if (!match) {
      return {
              hd: last,
              tl: /* [] */0
            };
    }
    var h2 = match.hd;
    return Belt_List.concat({
                hd: last,
                tl: {
                  hd: morph(last, h2, rules),
                  tl: /* [] */0
                }
              }, inner({
                    hd: h2,
                    tl: match.tl
                  }, rules));
  };
  return inner(param.template, param.rules);
}

function iterate(param) {
  var _l = param.template;
  var rules = param.rules;
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var l = _l;
    if (!l) {
      return acc;
    }
    var match = l.tl;
    var last = l.hd;
    if (!match) {
      return Belt_List.concat(acc, {
                  hd: last,
                  tl: /* [] */0
                });
    }
    var h2 = match.hd;
    _acc = Belt_List.concat(acc, {
          hd: last,
          tl: {
            hd: morph(last, h2, rules),
            tl: /* [] */0
          }
        });
    _l = {
      hd: h2,
      tl: match.tl
    };
    continue ;
  };
}

function iterateN(param, n) {
  var _t = param.template;
  var r = param.rules;
  var _n = n;
  while(true) {
    var n$1 = _n;
    var t = _t;
    if (n$1 === 0) {
      return t;
    }
    _n = n$1 - 1 | 0;
    _t = iterate({
          template: t,
          rules: r
        });
    continue ;
  };
}

function solve(t, n) {
  var ret = iterateN(t, n);
  var r = Belt_HashMapString.toArray(Belt_List.reduce(ret, Belt_HashMapString.make(10), (function (acc, k) {
              var v = Belt_HashMapString.get(acc, k);
              if (v !== undefined) {
                Belt_HashMapString.set(acc, k, v + 1 | 0);
              } else {
                Belt_HashMapString.set(acc, k, 1);
              }
              return acc;
            })));
  var match = Belt_Array.reduce(r, [
        "",
        0
      ], (function (acc, param) {
          var v = param[1];
          if (v > acc[1]) {
            return [
                    param[0],
                    v
                  ];
          } else {
            return acc;
          }
        }));
  var match$1 = Belt_Array.reduce(r, [
        "",
        Pervasives.max_int
      ], (function (acc, param) {
          var v = param[1];
          if (v < acc[1]) {
            return [
                    param[0],
                    v
                  ];
          } else {
            return acc;
          }
        }));
  return match[1] - match$1[1] | 0;
}

function part1(__x) {
  return solve(__x, 10);
}

function part2(__x) {
  return solve(__x, 40);
}

var Polymer = {
  make: make,
  morph: morph,
  iterate_no_tail_opt: iterate_no_tail_opt,
  iterate: iterate,
  iterateN: iterateN,
  solve: solve,
  part1: part1,
  part2: part2
};

function parse(data) {
  var parsed = Utils$AdventOfCode.splitDoubleNewline(data);
  var template = Belt_Option.getExn(Belt_Array.get(parsed, 0));
  var rules = Belt_Option.getExn(Belt_Array.get(parsed, 1));
  return [
          template.trim().split(""),
          Belt_Array.map(Utils$AdventOfCode.splitNewline(rules), (function (x) {
                  var s = x.trim().split(" -> ");
                  return [
                          Belt_Option.getExn(Belt_Array.get(s, 0)),
                          Belt_Option.getExn(Belt_Array.get(s, 1))
                        ];
                }))
        ];
}

function solvePart1(data) {
  var match = parse(data);
  return solve(make(match[0], match[1]), 10);
}

function solvePart2(data) {
  var match = parse(data);
  return solve(make(match[0], match[1]), 40);
}

exports.log = log;
exports.Polymer = Polymer;
exports.parse = parse;
exports.solvePart1 = solvePart1;
exports.solvePart2 = solvePart2;
/* No side effect */
