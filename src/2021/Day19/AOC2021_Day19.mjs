// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Bag$Bag from "rescript-bag/src/bag.mjs";
import * as Belt_Id from "rescript/lib/es6/Belt_Id.js";
import * as Belt_Set from "rescript/lib/es6/Belt_Set.js";
import * as Belt_List from "rescript/lib/es6/Belt_List.js";
import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/Belt_Option.js";
import * as Stdlib__List from "@dsiu/rescript-stdlib-fp/src/Stdlib__List.mjs";
import * as Stdlib__Array from "@dsiu/rescript-stdlib-fp/src/Stdlib__Array.mjs";
import * as Primitive_object from "rescript/lib/es6/Primitive_object.js";
import * as Stdlib__Function from "@dsiu/rescript-stdlib-fp/src/Stdlib__Function.mjs";
import * as Utils$AdventOfCode from "../../Utils.mjs";
import * as Linear$AdventOfCode from "../../Linear.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function coordToString(param) {
  let match = param._0;
  return "(" + String(match[0]) + ", " + String(match[1]) + ", " + String(match[2]) + ")";
}

function transformToString(trans) {
  return coordToString(trans({
    TAG: "Coord",
    _0: [
      0,
      0,
      0
    ]
  }));
}

function rotX(param) {
  let match = param._0;
  return {
    TAG: "Coord",
    _0: [
      match[0],
      - match[2],
      match[1]
    ]
  };
}

function rotY(param) {
  let match = param._0;
  return {
    TAG: "Coord",
    _0: [
      match[2],
      match[1],
      - match[0]
    ]
  };
}

function rotZ(param) {
  let match = param._0;
  return {
    TAG: "Coord",
    _0: [
      - match[1],
      match[0],
      match[2]
    ]
  };
}

function translate(param, param$1) {
  let match = param$1._0;
  let match$1 = param._0;
  return {
    TAG: "Coord",
    _0: [
      match$1[0] + match[0],
      match$1[1] + match[1],
      match$1[2] + match[2]
    ]
  };
}

let ras = [
  Utils$AdventOfCode.identity,
  rotY,
  extra => Stdlib__Function.compose(rotY, rotY, extra),
  extra => Stdlib__Function.compose3(rotY, rotY, rotY, extra),
  rotZ,
  extra => Stdlib__Function.compose3(rotZ, rotZ, rotZ, extra)
];

let rbs = [
  Utils$AdventOfCode.identity,
  rotX,
  extra => Stdlib__Function.compose(rotX, rotX, extra),
  extra => Stdlib__Function.compose3(rotX, rotX, rotX, extra)
];

let rotations = Stdlib__Array.combination2(ras, rbs, (a, b) => (extra => Stdlib__Function.compose(a, b, extra)));

let cmp = Primitive_object.compare;

let I = {
  cmp: cmp
};

function cmp$1(a, b) {
  return a - b | 0;
}

let F = {
  cmp: cmp$1
};

let B = Bag$Bag.Make(F);

function bagFromArray(__x) {
  return Belt_Array.reduce(__x, B.empty, (acc, x) => B.add(x, undefined, acc));
}

function bagToString(b) {
  let str = {
    contents: ""
  };
  B.iter((x, m) => {
    str.contents = str.contents + ("@ " + String(x) + ":" + String(m) + ",");
  }, b);
  return "{" + str.contents + "}";
}

function eq(a, b) {
  return a.scannerName === b.scannerName;
}

function toString(t) {
  return Utils$AdventOfCode.Printable.$$Array.toString(t, param => "scannerName: " + String(param.scannerName) + ", beacons: " + Utils$AdventOfCode.Printable.$$Array.toString(param.beacons, param => {
    let match = param._0;
    return "(" + String(match[0]) + ", " + String(match[1]) + ", " + String(match[2]) + ")";
  }) + ", signature: " + bagToString(param.signature) + "\n");
}

function minus(a, b) {
  let b$1 = b._0;
  let a$1 = a._0;
  return {
    TAG: "Coord",
    _0: [
      a$1[0] - b$1[0],
      a$1[1] - b$1[1],
      a$1[2] - b$1[2]
    ]
  };
}

function sign(bcns) {
  let pythag = param => {
    let match = param._0;
    let z = match[2];
    let y = match[1];
    let x = match[0];
    return x * x + y * y + z * z;
  };
  return bagFromArray(Stdlib__Array.combinationIf2(bcns, bcns, (a, b) => {
    let b$1 = b._0;
    let a$1 = a._0;
    if (Linear$AdventOfCode.V3.cmp(b$1, a$1) > 0) {
      return pythag(minus({
        TAG: "Coord",
        _0: a$1
      }, {
        TAG: "Coord",
        _0: b$1
      }));
    }
    
  }));
}

function vagueMatch(scanner1, scanner2) {
  let s1 = scanner1.signature;
  let s2 = scanner2.signature;
  let s = Belt_List.size(B.elements(B.inter(s1, s2)));
  return s >= 66;
}

function cmp$2(a, b) {
  return Linear$AdventOfCode.V3.cmp(a._0, b._0);
}

let V3Comparator = Belt_Id.MakeComparable({
  cmp: cmp$2
});

function v3SetFromArray(a) {
  return Belt_Set.fromArray(a, V3Comparator);
}

let v3SetMake = Belt_Set.make(V3Comparator);

function interact(a, b) {
  let sa = Belt_Set.fromArray(a, V3Comparator);
  let sb = Belt_Set.fromArray(b, V3Comparator);
  return Belt_Set.intersect(sa, sb);
}

function matchingTransformAll(scanner1, scanner2) {
  let beacons1 = scanner1.beacons;
  let beacons2 = scanner2.beacons;
  return Stdlib__Array.combinationIf3(beacons1, beacons2, rotations, (b1, b2, rot) => {
    let t = minus(b1, rot(b2));
    let translation = extra => translate(t, extra);
    let transB2 = Belt_Array.mapU(beacons2, b => translate(t, rot(b)));
    let len = Belt_Set.size(interact(beacons1, transB2));
    if (len >= 12) {
      return extra => Stdlib__Function.compose(rot, translation, extra);
    }
    
  });
}

function matchingTransform(scanner1, scanner2) {
  return Stdlib__Array.arrayToOption(matchingTransformAll(scanner1, scanner2));
}

function mkReconstruction(scanners) {
  if (scanners) {
    return {
      TAG: "Reconstruction",
      found: /* [] */0,
      working: {
        hd: scanners.hd,
        tl: /* [] */0
      },
      waiting: scanners.tl
    };
  }
  throw {
    RE_EXN_ID: "Invalid_argument",
    _1: "empty scanners",
    Error: new Error()
  };
}

function transformScanner(param) {
  let trans = param[1];
  let s = param[0];
  return {
    scannerName: s.scannerName,
    beacons: Belt_Array.mapU(s.beacons, b => Belt_Option.getExn(trans)(b)),
    transformation: Belt_Option.getExn(trans),
    signature: s.signature
  };
}

function reconstructStep(param) {
  let working = param.working;
  if (working) {
    let current = working.hd;
    let waiting = param.waiting;
    let passMatches = Belt_List.keep(waiting, x => vagueMatch(current, x));
    let matches = Belt_List.keep(Belt_List.zip(passMatches, Belt_List.mapU(passMatches, x => Stdlib__Array.arrayToOption(matchingTransformAll(current, x)))), x => Belt_Option.isSome(x[1]));
    let waiting$p = Belt_List.keep(waiting, s => {
      if (Belt_List.has(Belt_List.map(matches, prim => prim[0]), s, eq)) {
        return false;
      } else {
        return true;
      }
    });
    let newWorker = Belt_List.mapU(matches, transformScanner);
    return {
      TAG: "Reconstruction",
      found: {
        hd: current,
        tl: param.found
      },
      working: Belt_List.concat(working.tl, newWorker),
      waiting: waiting$p
    };
  }
  throw {
    RE_EXN_ID: "Invalid_argument",
    _1: "empty working scanner",
    Error: new Error()
  };
}

function reconstruct(_r) {
  while (true) {
    let r = _r;
    if (!r.working) {
      return r;
    }
    _r = reconstructStep(r);
    continue;
  };
}

function make(param) {
  let beacons = param[1];
  return {
    scannerName: param[0],
    beacons: beacons,
    transformation: Utils$AdventOfCode.identity,
    signature: sign(beacons)
  };
}

let Scanner = {
  coordToString: coordToString,
  transformToString: transformToString,
  nullTrans: Utils$AdventOfCode.identity,
  rotX: rotX,
  rotY: rotY,
  rotZ: rotZ,
  translate: translate,
  rotations: rotations,
  I: I,
  F: F,
  Bag: undefined,
  B: B,
  bagFromArray: bagFromArray,
  bagToString: bagToString,
  eq: eq,
  toString: toString,
  minus: minus,
  sign: sign,
  vagueMatch: vagueMatch,
  V3Comparator: V3Comparator,
  v3SetFromArray: v3SetFromArray,
  v3SetMake: v3SetMake,
  interact: interact,
  matchingTransformAll: matchingTransformAll,
  matchingTransform: matchingTransform,
  mkReconstruction: mkReconstruction,
  transformScanner: transformScanner,
  reconstructStep: reconstructStep,
  reconstruct: reconstruct,
  make: make
};

function parse(data) {
  let floatFromStr = prim => Number(prim);
  let parseOne = data => {
    let lines = Belt_Array.map(Utils$AdventOfCode.splitNewline(data), prim => prim.trim());
    let name = Utils$AdventOfCode.intFromStringExn(Belt_Array.getExn(lines, 0).replace("--- scanner ", "").replace(" ---", ""));
    let coords = Belt_Array.map(Belt_Array.sliceToEnd(lines, 1), line => {
      let c = Belt_Array.map(line.split(","), floatFromStr);
      return {
        TAG: "Coord",
        _0: [
          Belt_Array.getExn(c, 0),
          Belt_Array.getExn(c, 1),
          Belt_Array.getExn(c, 2)
        ]
      };
    });
    return [
      name,
      coords
    ];
  };
  return Belt_Array.map(Utils$AdventOfCode.splitDoubleNewline(data), parseOne);
}

function reconstructScanners(scanners) {
  return reconstruct(mkReconstruction(Belt_List.fromArray(scanners))).found;
}

function part1(scanners) {
  let bSets = Belt_List.mapU(scanners, s => Belt_Set.fromArray(s.beacons, V3Comparator));
  return Belt_Set.size(Belt_List.reduceU(bSets, v3SetMake, Belt_Set.union));
}

function part2(scanners) {
  let extractOrigin = sc => sc.transformation({
    TAG: "Coord",
    _0: [
      0.0,
      0.0,
      0.0
    ]
  });
  let origins = Belt_List.mapU(scanners, extractOrigin);
  return Belt_Option.getExn(Stdlib__List.listToOption(Belt_List.sort(Stdlib__List.combination2(origins, origins, (a, b) => {
    let a$1 = minus(a, b);
    let a$2 = a$1._0;
    return Math.abs(a$2[0]) + Math.abs(a$2[1]) + Math.abs(a$2[2]);
  }), (a, b) => b - a | 0)));
}

function solvePart1(data) {
  let scanners = Belt_Array.map(parse(data), make);
  return part1(reconstructScanners(scanners));
}

function solvePart2(data) {
  let scanners = Belt_Array.map(parse(data), make);
  return part2(reconstructScanners(scanners));
}

let compose = Stdlib__Function.compose;

let compose3 = Stdlib__Function.compose3;

export {
  log,
  log2,
  compose,
  compose3,
  Scanner,
  parse,
  reconstructScanners,
  part1,
  part2,
  solvePart1,
  solvePart2,
}
/* rotations Not a pure module */
