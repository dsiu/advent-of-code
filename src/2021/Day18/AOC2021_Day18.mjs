// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Int from "rescript/lib/es6/belt_Int.js";
import * as Res_parser from "@resinfo/parser/src/res_parser.mjs";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Belt_Result from "rescript/lib/es6/belt_Result.js";

function log(prim) {
  console.log(prim);
  
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
  
}

function log3(prim0, prim1, prim2) {
  console.log(prim0, prim1, prim2);
  
}

function dumpElem(e) {
  if (e.TAG === /* Int */0) {
    return String(e._0);
  }
  var match = e._0;
  var s1 = dumpElem(match[0]);
  var s2 = dumpElem(match[1]);
  return "[" + s1 + ", " + s2 + "]";
}

function charToString(c) {
  return String.fromCharCode(c);
}

function concatStringList(chars) {
  if (chars) {
    return chars.hd + concatStringList(chars.tl);
  } else {
    return "";
  }
}

var manyWhitespace = Res_parser.many(Res_parser.anyOf([
          /* ' ' */32,
          /* '\n' */10,
          /* '\t' */9,
          /* '\r' */13
        ]));

var comma = Res_parser.$$char(/* ',' */44);

var zero = Res_parser.$$char(/* '0' */48);

var oneThroughNine = Res_parser.satisfy(function (c) {
      if (c >= /* '1' */49) {
        return /* '9' */57 >= c;
      } else {
        return false;
      }
    });

var digit = Res_parser.map(Res_parser.orElse(zero, oneThroughNine), charToString);

var digits = Res_parser.map(Res_parser.atLeastOne(digit), concatStringList);

var pair = Res_parser.makeRecursive(function (p) {
      var betweenBraces = function (__x) {
        return Res_parser.between(__x, Res_parser.$$char(/* '[' */91), Res_parser.$$char(/* ']' */93));
      };
      var pairOrNumber = Res_parser.choice([
            p,
            Res_parser.map(digits, (function (x) {
                    return {
                            TAG: /* Int */0,
                            _0: Belt_Option.getExn(Belt_Int.fromString(x))
                          };
                  }))
          ]);
      return Res_parser.map(betweenBraces(Res_parser.andThen(Res_parser.keepLeft(pairOrNumber, comma), pairOrNumber)), (function (x) {
                    return {
                            TAG: /* Pair */1,
                            _0: x
                          };
                  }));
    });

function parse(s) {
  return Res_parser.run(pair, s);
}

var Parser = {
  charToString: charToString,
  concatStringList: concatStringList,
  manyWhitespace: manyWhitespace,
  comma: comma,
  zero: zero,
  oneThroughNine: oneThroughNine,
  digit: digit,
  digits: digits,
  pair: pair,
  parse: parse
};

var SnailFish = {
  dumpElem: dumpElem,
  Parser: Parser
};

function solvePart1(data) {
  var l = Res_parser.run(pair, data);
  var prim1 = Belt_Result.isOk(l);
  console.log("parse result:", prim1);
  var p = Belt_Result.getExn(l)[0];
  if (l.TAG === /* Ok */0) {
    var prim1$1 = dumpElem(p);
    console.log("Parsed as: ", prim1$1);
    var prim1$2 = Belt_Result.getExn(l)[1];
    console.log("Parse state:", prim1$2);
    console.log("\n");
  } else {
    console.log(l._0);
    console.log("\n");
  }
  return 1;
}

function solvePart2(data) {
  return 2;
}

var P;

var Rjs;

export {
  log ,
  log2 ,
  log3 ,
  P ,
  Rjs ,
  SnailFish ,
  solvePart1 ,
  solvePart2 ,
  
}
/* manyWhitespace Not a pure module */
