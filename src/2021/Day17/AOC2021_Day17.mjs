// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Js_int from "rescript/lib/es6/js_int.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Utils$AdventOfCode from "../../Utils.mjs";

function log(prim) {
  console.log(prim);
}

function velocityNext(param) {
  var x = param.x;
  return {
          x: x === 0 ? 0 : (
              x < 0 ? x + 1 | 0 : x - 1 | 0
            ),
          y: param.y - 1 | 0
        };
}

function isTargetHit_(param, param$1) {
  var y = param[1];
  var x = param[0];
  if (x >= param$1.x_min && x <= param$1.x_max && y >= param$1.y_min) {
    return y <= param$1.y_max;
  } else {
    return false;
  }
}

function isTargetHit(t_init, __x) {
  return isTargetHit_(__x, t_init);
}

function isOutOfRange_(param, param$1) {
  if (param[0] > param$1.x_max) {
    return true;
  } else {
    return param[1] < param$1.y_min;
  }
}

function isOUtOfRange(t_init, __x) {
  return isOutOfRange_(__x, t_init);
}

function toString(r) {
  var trajectory_str = function (__x) {
    return Belt_Array.map(__x, (function (param) {
                  return "(" + String(param[0]) + ", " + String(param[1]) + ")\n";
                }));
  };
  if (r.TAG === "Hit") {
    var match = r._0;
    var t_str = trajectory_str(r._1);
    return "Hit: (" + String(match[0]) + ", " + String(match[1]) + ") | trajectory: [" + Curry._2(Utils$AdventOfCode.Printable.$$Array.toString, t_str, (function (str) {
                  return str;
                })) + "]";
  }
  var t_str$1 = trajectory_str(r._0);
  return "Miss: trajectory: [" + Curry._2(Utils$AdventOfCode.Printable.$$Array.toString, t_str$1, (function (str) {
                return str;
              })) + "]";
}

function launch(v0, target) {
  var _c = [
    0,
    0
  ];
  var _v = v0;
  var _trajectory = [];
  while(true) {
    var trajectory = _trajectory;
    var v = _v;
    var c = _c;
    if (isTargetHit_(c, target)) {
      return {
              TAG: "Hit",
              _0: c,
              _1: trajectory
            };
    }
    if (isOutOfRange_(c, target)) {
      return {
              TAG: "Miss",
              _0: Belt_Array.concat(trajectory, [c])
            };
    }
    _trajectory = Belt_Array.concat(trajectory, [c]);
    _v = velocityNext(v);
    _c = [
      c[0] + v.x | 0,
      c[1] + v.y | 0
    ];
    continue ;
  };
}

function iterate(vx_start, vx_end, vy_start, vy_end, target) {
  var result = [];
  for(var x = vx_start; x <= vx_end; ++x){
    for(var y = vy_start; y <= vy_end; ++y){
      var v = {
        x: x,
        y: y
      };
      var r = launch(v, target);
      if (r.TAG === "Hit") {
        result = Belt_Array.concat(result, [[
                v,
                r
              ]]);
      }
      
    }
  }
  return result;
}

function part1(vx_start, vx_end, vy_start, vy_end, target) {
  var getMaxY = function (__x) {
    return Belt_Array.reduce(__x, Js_int.min, (function (acc, c) {
                  if (c[1] > acc) {
                    return c[1];
                  } else {
                    return acc;
                  }
                }));
  };
  var launch_results = iterate(vx_start, vx_end, vy_start, vy_end, target);
  return Belt_Array.reduce(launch_results, [
              Js_int.min,
              Belt_Option.getExn(Belt_Array.get(launch_results, 0))
            ], (function (acc, param) {
                var r$p = param[1];
                if (r$p.TAG !== "Hit") {
                  return acc;
                }
                var y = getMaxY(r$p._1);
                if (y > acc[0]) {
                  return [
                          y,
                          [
                            param[0],
                            r$p
                          ]
                        ];
                } else {
                  return acc;
                }
              }));
}

function part2(vx_start, vx_end, vy_start, vy_end, target) {
  return iterate(vx_start, vx_end, vy_start, vy_end, target).length;
}

var TrickShot = {
  velocityNext: velocityNext,
  isTargetHit_: isTargetHit_,
  isTargetHit: isTargetHit,
  isOutOfRange_: isOutOfRange_,
  isOUtOfRange: isOUtOfRange,
  toString: toString,
  launch: launch,
  iterate: iterate,
  part1: part1,
  part2: part2
};

function parse(data) {
  var match = data.replace("target area: ", "").split(", ");
  if (match.length !== 2) {
    throw {
          RE_EXN_ID: "Match_failure",
          _1: [
            "AOC2021_Day17.res",
            118,
            6
          ],
          Error: new Error()
        };
  }
  var x_str = match[0];
  var y_str = match[1];
  var match$1 = Belt_Array.map(x_str.replace("x=", "").split(".."), Utils$AdventOfCode.intFromStringExn);
  if (match$1.length !== 2) {
    throw {
          RE_EXN_ID: "Match_failure",
          _1: [
            "AOC2021_Day17.res",
            119,
            6
          ],
          Error: new Error()
        };
  }
  var x_min = match$1[0];
  var x_max = match$1[1];
  var match$2 = Belt_Array.map(y_str.replace("y=", "").split(".."), Utils$AdventOfCode.intFromStringExn);
  if (match$2.length !== 2) {
    throw {
          RE_EXN_ID: "Match_failure",
          _1: [
            "AOC2021_Day17.res",
            121,
            6
          ],
          Error: new Error()
        };
  }
  var y_min = match$2[0];
  var y_max = match$2[1];
  return {
          x_min: x_min,
          x_max: x_max,
          y_min: y_min,
          y_max: y_max
        };
}

function solvePart1(data) {
  var t = parse(data);
  return part1(1, t.x_max - 1 | 0, 0, (-t.y_min | 0) - 1 | 0, t)[0];
}

function solvePart2(data) {
  var t = parse(data);
  var vy_start = -Math.abs(t.y_min) | 0;
  var vy_end = -vy_start | 0;
  return part2(0, t.x_max, vy_start, vy_end, t);
}

export {
  log ,
  TrickShot ,
  parse ,
  solvePart1 ,
  solvePart2 ,
}
/* Utils-AdventOfCode Not a pure module */
