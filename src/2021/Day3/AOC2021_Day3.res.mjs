// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Utils from "../../Utils.res.mjs";
import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Belt_MapInt from "rescript/lib/es6/Belt_MapInt.js";
import * as Primitive_object from "rescript/lib/es6/Primitive_object.js";
import * as Belt_MutableMapInt from "rescript/lib/es6/Belt_MutableMapInt.js";

function log(prim) {
  console.log(prim);
}

function inc(t, k) {
  return Belt_MapInt.set(t, k, Belt_MapInt.getWithDefault(t, k, 0) + 1 | 0);
}

function mostCommon(t) {
  let one_count = Belt_MapInt.get(t, 1);
  let zero_count = Belt_MapInt.get(t, 0);
  if (Primitive_object.equal(one_count, zero_count) || Primitive_object.greaterthan(one_count, zero_count)) {
    return 1;
  } else {
    return 0;
  }
}

function leastCommon(t) {
  let one_count = Belt_MapInt.get(t, 1);
  let zero_count = Belt_MapInt.get(t, 0);
  if (Primitive_object.equal(one_count, zero_count) || !Primitive_object.lessthan(one_count, zero_count)) {
    return 0;
  } else {
    return 1;
  }
}

function make(param) {
  return Belt_Array.reduce([
    0,
    1
  ], undefined, (a, x) => Belt_MapInt.set(a, x, 0));
}

let CountContainer = {
  set: Belt_MapInt.set,
  get: Belt_MapInt.get,
  getWithDefault: Belt_MapInt.getWithDefault,
  reduce: Belt_MapInt.reduce,
  inc: inc,
  mostCommon: mostCommon,
  leastCommon: leastCommon,
  make: make
};

function getSafe(m, k) {
  return Belt_MutableMapInt.getWithDefault(m, k, make());
}

let Total = {
  set: Belt_MutableMapInt.set,
  get: Belt_MutableMapInt.get,
  getSafe: getSafe,
  forEach: Belt_MutableMapInt.forEach,
  map: Belt_MutableMapInt.map,
  make: Belt_MutableMapInt.make
};

function logAndCont(x) {
  console.log("binStringToInt", x);
  return x;
}

function bitArrayToInt(x) {
  return parseInt(Belt_Array.map(x, prim => String(prim)).join(""), 2);
}

function calTotal(xs) {
  return Belt_Array.reduce(xs, Belt_MutableMapInt.make(), (a, bits) => {
    Belt_Array.forEachWithIndex(bits, (idx, bit_val) => {
      let orig_total = getSafe(a, idx);
      Belt_MutableMapInt.set(a, idx, inc(orig_total, bit_val));
    });
    return a;
  });
}

function calGamma(xs) {
  return Belt_MutableMapInt.valuesToArray(Belt_MutableMapInt.map(calTotal(xs), mostCommon));
}

function calEpsilon(xs) {
  return Belt_MutableMapInt.valuesToArray(Belt_MutableMapInt.map(calTotal(xs), leastCommon));
}

function part1(xs) {
  let gamma = calGamma(xs);
  let epsilon = calEpsilon(xs);
  return Math.imul(bitArrayToInt(gamma), bitArrayToInt(epsilon));
}

function findRating(xs, func) {
  let _bit_pos = 0;
  let _inputs = xs;
  while (true) {
    let inputs = _inputs;
    let bit_pos = _bit_pos;
    let len = inputs.length;
    if (len === 1) {
      return inputs[0];
    }
    if (len !== 0) {
      let filter = func(inputs);
      let criteria = Belt_Array.getExn(filter, bit_pos);
      let next_inputs = Belt_Array.keep(inputs, x => Primitive_object.equal(Belt_Array.getExn(x, bit_pos), criteria));
      _inputs = next_inputs;
      _bit_pos = bit_pos + 1 | 0;
      continue;
    }
    throw {
      RE_EXN_ID: "Not_found",
      Error: new Error()
    };
  };
}

function calOxygen(__x) {
  return findRating(__x, calGamma);
}

function calCO2(__x) {
  return findRating(__x, calEpsilon);
}

function part2(xs) {
  let oxygen = findRating(xs, calGamma);
  let co2 = findRating(xs, calEpsilon);
  return Math.imul(bitArrayToInt(oxygen), bitArrayToInt(co2));
}

function parse(data) {
  return Belt_Array.map(Utils.splitNewline(data), line => Belt_Array.map(Utils.splitChars(line.trim()), Utils.intFromStringExn));
}

function solvePart1(data) {
  return part1(parse(data));
}

function solvePart2(data) {
  return part2(parse(data));
}

let toBinaryString = Belt_MutableMapInt.valuesToArray;

export {
  log,
  CountContainer,
  Total,
  toBinaryString,
  logAndCont,
  bitArrayToInt,
  calTotal,
  calGamma,
  calEpsilon,
  part1,
  findRating,
  calOxygen,
  calCO2,
  part2,
  parse,
  solvePart1,
  solvePart2,
}
/* Utils Not a pure module */
