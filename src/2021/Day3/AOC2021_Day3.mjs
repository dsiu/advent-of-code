// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_MapInt from "rescript/lib/es6/belt_MapInt.js";
import * as Belt_MutableMapInt from "rescript/lib/es6/belt_MutableMapInt.js";
import * as Utils$AdventOfCode from "../../Utils.mjs";

function log(prim) {
  console.log(prim);
}

function inc(t, k) {
  return Belt_MapInt.set(t, k, Belt_MapInt.getWithDefault(t, k, 0) + 1 | 0);
}

function mostCommon(t) {
  var one_count = Belt_MapInt.get(t, 1);
  var zero_count = Belt_MapInt.get(t, 0);
  if (Caml_obj.equal(one_count, zero_count) || Caml_obj.greaterthan(one_count, zero_count)) {
    return 1;
  } else {
    return 0;
  }
}

function leastCommon(t) {
  var one_count = Belt_MapInt.get(t, 1);
  var zero_count = Belt_MapInt.get(t, 0);
  if (Caml_obj.equal(one_count, zero_count) || !Caml_obj.lessthan(one_count, zero_count)) {
    return 0;
  } else {
    return 1;
  }
}

function make(param) {
  return Belt_Array.reduce([
              0,
              1
            ], undefined, (function (a, x) {
                return Belt_MapInt.set(a, x, 0);
              }));
}

var CountContainer = {
  set: Belt_MapInt.set,
  get: Belt_MapInt.get,
  getWithDefault: Belt_MapInt.getWithDefault,
  reduce: Belt_MapInt.reduce,
  inc: inc,
  mostCommon: mostCommon,
  leastCommon: leastCommon,
  make: make
};

function getSafe(m, k) {
  return Belt_MutableMapInt.getWithDefault(m, k, make());
}

var Total = {
  set: Belt_MutableMapInt.set,
  get: Belt_MutableMapInt.get,
  getSafe: getSafe,
  forEach: Belt_MutableMapInt.forEach,
  map: Belt_MutableMapInt.map,
  make: Belt_MutableMapInt.make
};

function logAndCont(x) {
  console.log("binStringToInt", x);
  return x;
}

function bitArrayToInt(x) {
  var __x = Belt_Array.map(x, (function (prim) {
            return String(prim);
          })).join("");
  return parseInt(__x, 2);
}

function calTotal(xs) {
  return Belt_Array.reduce(xs, Belt_MutableMapInt.make(), (function (a, bits) {
                Belt_Array.forEachWithIndex(bits, (function (idx, bit_val) {
                        var orig_total = getSafe(a, idx);
                        Belt_MutableMapInt.set(a, idx, inc(orig_total, bit_val));
                      }));
                return a;
              }));
}

function calGamma(xs) {
  return Belt_MutableMapInt.valuesToArray(Belt_MutableMapInt.map(calTotal(xs), mostCommon));
}

function calEpsilon(xs) {
  return Belt_MutableMapInt.valuesToArray(Belt_MutableMapInt.map(calTotal(xs), leastCommon));
}

function part1(xs) {
  var gamma = calGamma(xs);
  var epsilon = calEpsilon(xs);
  return Math.imul(bitArrayToInt(gamma), bitArrayToInt(epsilon));
}

function findRating(xs, func) {
  var _bit_pos = 0;
  var _inputs = xs;
  while(true) {
    var inputs = _inputs;
    var bit_pos = _bit_pos;
    var len = inputs.length;
    if (len === 1) {
      return inputs[0];
    }
    if (len !== 0) {
      var filter = func(inputs);
      var criteria = Belt_Array.getExn(filter, bit_pos);
      var next_inputs = Belt_Array.keep(inputs, (function(bit_pos,criteria){
          return function (x) {
            return Caml_obj.equal(Belt_Array.getExn(x, bit_pos), criteria);
          }
          }(bit_pos,criteria)));
      _inputs = next_inputs;
      _bit_pos = bit_pos + 1 | 0;
      continue ;
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
}

function calOxygen(__x) {
  return findRating(__x, calGamma);
}

function calCO2(__x) {
  return findRating(__x, calEpsilon);
}

function part2(xs) {
  var oxygen = findRating(xs, calGamma);
  var co2 = findRating(xs, calEpsilon);
  return Math.imul(bitArrayToInt(oxygen), bitArrayToInt(co2));
}

function parse(data) {
  return Belt_Array.map(Utils$AdventOfCode.splitNewline(data), (function (line) {
                return Belt_Array.map(Utils$AdventOfCode.splitChars(line.trim()), Utils$AdventOfCode.intFromStringExn);
              }));
}

function solvePart1(data) {
  return part1(parse(data));
}

function solvePart2(data) {
  return part2(parse(data));
}

var toBinaryString = Belt_MutableMapInt.valuesToArray;

export {
  log ,
  CountContainer ,
  Total ,
  toBinaryString ,
  logAndCont ,
  bitArrayToInt ,
  calTotal ,
  calGamma ,
  calEpsilon ,
  part1 ,
  findRating ,
  calOxygen ,
  calCO2 ,
  part2 ,
  parse ,
  solvePart1 ,
  solvePart2 ,
}
/* Utils-AdventOfCode Not a pure module */
