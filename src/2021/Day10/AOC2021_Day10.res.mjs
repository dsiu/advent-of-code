// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Utils from "../../Utils.res.mjs";
import * as Belt_List from "rescript/lib/es6/Belt_List.js";
import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/Belt_Option.js";
import * as Stack_Array from "../../Stack_Array.res.mjs";
import * as Belt_SortArray from "rescript/lib/es6/Belt_SortArray.js";
import * as Primitive_bigint from "rescript/lib/es6/Primitive_bigint.js";
import * as Stdlib__Function from "@dsiu/rescript-stdlib-fp/src/Stdlib__Function.res.mjs";
import * as Stdlib__Ordering from "@dsiu/rescript-stdlib-fp/src/Stdlib__Ordering.res.mjs";
import * as Primitive_exceptions from "rescript/lib/es6/Primitive_exceptions.js";

function log(prim) {
  console.log(prim);
}

let ParseError = /* @__PURE__ */Primitive_exceptions.create("AOC2021_Day10.ParseError");

let NotSupported = /* @__PURE__ */Primitive_exceptions.create("AOC2021_Day10.NotSupported");

function isOpenBracket(token) {
  if (token === "{" || token === "[" || token === "<") {
    return true;
  } else {
    return token === "(";
  }
}

function isCloseBracket(token) {
  if (token === "}" || token === "]" || token === ">") {
    return true;
  } else {
    return token === ")";
  }
}

function matches(left, right) {
  if (left === "(") {
    return right === ")";
  } else if (left === "<") {
    return right === ">";
  } else if (left === "[") {
    return right === "]";
  } else if (left === "{") {
    return right === "}";
  } else {
    return false;
  }
}

function make(c) {
  switch (c) {
    case "(" :
      return "(";
    case ")" :
      return ")";
    case "<" :
      return "<";
    case ">" :
      return ">";
    case "[" :
      return "[";
    case "]" :
      return "]";
    case "{" :
      return "{";
    case "}" :
      return "}";
    default:
      throw {
        RE_EXN_ID: ParseError,
        _1: c + " is not supported",
        Error: new Error()
      };
  }
}

function toString(x) {
  return x;
}

let Token = {
  isOpenBracket: isOpenBracket,
  isCloseBracket: isCloseBracket,
  matches: matches,
  make: make,
  toString: toString
};

function tokenAtToString(param) {
  return "'" + param._0 + "':" + String(param._1);
}

function tokenize(xs) {
  return Belt_Array.mapWithIndex(xs, (i, x) => ({
    TAG: "TokenAt",
    _0: make(x),
    _1: i
  }));
}

function map(t, f) {
  if (typeof t !== "object") {
    return "Empty";
  }
  if (t.TAG !== "Node") {
    return {
      TAG: "NodeList",
      _0: Belt_List.map(t._0, __x => map(__x, f))
    };
  }
  let tl = t.tl;
  let b1 = t.l;
  if (typeof tl !== "object") {
    return {
      TAG: "Node",
      l: f(b1),
      tl: "Empty",
      r: f(t.r)
    };
  }
  if (tl.TAG !== "Node") {
    return {
      TAG: "Node",
      l: f(b1),
      tl: map({
        TAG: "NodeList",
        _0: tl._0
      }, f),
      r: f(t.r)
    };
  }
  throw {
    RE_EXN_ID: NotSupported,
    _1: "nested nodes",
    Error: new Error()
  };
}

function toString$1(t) {
  if (typeof t !== "object") {
    return "Empty";
  }
  if (t.TAG !== "Node") {
    return "NodeList:{ " + Belt_List.toArray(Belt_List.map(t._0, toString$1)).join(", ") + " }";
  }
  let tl = t.tl;
  let b1 = t.l;
  if (typeof tl !== "object") {
    return "Node(" + tokenAtToString(b1) + ", tl: Empty, " + tokenAtToString(t.r) + "})";
  }
  tl.TAG === "Node";
  return "Node(" + tokenAtToString(b1) + ", tl: " + toString$1(tl) + ", " + tokenAtToString(t.r) + "})";
}

function makeNode(l, r) {
  return {
    TAG: "Node",
    l: l,
    tl: "Empty",
    r: r
  };
}

function makeNodeFromStr(l, li, r, ri) {
  return {
    TAG: "Node",
    l: {
      TAG: "TokenAt",
      _0: make(l),
      _1: li
    },
    tl: "Empty",
    r: {
      TAG: "TokenAt",
      _0: make(r),
      _1: ri
    }
  };
}

function add(a, b) {
  if (typeof a !== "object") {
    return b;
  }
  if (a.TAG === "Node") {
    let tl = a.tl;
    let l = a.l;
    if (typeof tl !== "object") {
      if (typeof b !== "object") {
        return a;
      } else if (b.TAG === "Node") {
        return {
          TAG: "NodeList",
          _0: {
            hd: a,
            tl: {
              hd: b,
              tl: /* [] */0
            }
          }
        };
      } else {
        return {
          TAG: "Node",
          l: l,
          tl: b,
          r: a.r
        };
      }
    }
    if (tl.TAG !== "Node") {
      return {
        TAG: "Node",
        l: l,
        tl: add({
          TAG: "NodeList",
          _0: tl._0
        }, b),
        r: a.r
      };
    }
    throw {
      RE_EXN_ID: NotSupported,
      _1: "nested nodes",
      Error: new Error()
    };
  } else {
    let tl$1 = a._0;
    if (typeof b !== "object") {
      return a;
    }
    if (b.TAG !== "Node") {
      return {
        TAG: "NodeList",
        _0: Belt_List.concat(tl$1, b._0)
      };
    }
    let btl = b.tl;
    let l$1 = b.l;
    if (typeof btl !== "object") {
      return {
        TAG: "Node",
        l: l$1,
        tl: {
          TAG: "NodeList",
          _0: tl$1
        },
        r: b.r
      };
    }
    if (btl.TAG !== "Node") {
      return {
        TAG: "Node",
        l: l$1,
        tl: {
          TAG: "NodeList",
          _0: Belt_List.concat(tl$1, btl._0)
        },
        r: b.r
      };
    }
    throw {
      RE_EXN_ID: NotSupported,
      _1: "not supported",
      Error: new Error()
    };
  }
}

function makeParseTree(xs) {
  let match = Belt_List.fromArray(tokenize(xs));
  let match$1;
  if (match) {
    match$1 = [
      match.hd,
      match.tl
    ];
  } else {
    throw {
      RE_EXN_ID: ParseError,
      _1: "empty input",
      Error: new Error()
    };
  }
  let _inputs = match$1[1];
  let _tree = "Empty";
  let _stack = [match$1[0]];
  while (true) {
    let stack = _stack;
    let tree = _tree;
    let inputs = _inputs;
    if (!inputs) {
      return [
        tree,
        stack
      ];
    }
    let rest = inputs.tl;
    let $$this = inputs.hd;
    console.log("processing", $$this);
    console.log("  tree", toString$1(tree));
    console.log("  stack", stack);
    let last = Stack_Array.peek(stack);
    let match$2 = isCloseBracket($$this._0);
    if (match$2) {
      if (last !== undefined) {
        let match$3 = Stack_Array.pop(stack);
        _stack = match$3[1];
        _tree = add(tree, {
          TAG: "Node",
          l: last,
          tl: "Empty",
          r: $$this
        });
        _inputs = rest;
        continue;
      }
      _stack = Stack_Array.push(stack, $$this);
      _inputs = rest;
      continue;
    }
    _stack = Stack_Array.push(stack, $$this);
    _inputs = rest;
    continue;
  };
}

let ParseTree = {
  map: map,
  toString: toString$1,
  makeNode: makeNode,
  makeNodeFromStr: makeNodeFromStr,
  add: add,
  makeParseTree: makeParseTree
};

function process(xs) {
  let match = Belt_List.fromArray(tokenize(xs));
  let match$1;
  if (match) {
    match$1 = [
      match.hd,
      match.tl
    ];
  } else {
    throw {
      RE_EXN_ID: ParseError,
      _1: "empty input",
      Error: new Error()
    };
  }
  let _inputs = match$1[1];
  let _stack = [match$1[0]];
  while (true) {
    let stack = _stack;
    let inputs = _inputs;
    if (!inputs) {
      return {
        TAG: "Incomplete",
        _0: stack
      };
    }
    let rest = inputs.tl;
    let $$this = inputs.hd;
    let last = Stack_Array.peek(stack);
    let this_token = $$this._0;
    let match$2 = isCloseBracket(this_token);
    if (match$2) {
      if (last !== undefined) {
        if (!matches(last._0, this_token)) {
          return {
            TAG: "Corrupted",
            _0: $$this
          };
        }
        let match$3 = Stack_Array.pop(stack);
        _stack = match$3[1];
        _inputs = rest;
        continue;
      }
      _stack = Stack_Array.push(stack, $$this);
      _inputs = rest;
      continue;
    }
    _stack = Stack_Array.push(stack, $$this);
    _inputs = rest;
    continue;
  };
}

function parse(data) {
  return Belt_Array.map(Utils.splitNewline(data), extra => Stdlib__Function.compose(prim => prim.trim(), Utils.splitChars, extra));
}

function examples() {
  let parent = makeNodeFromStr("(", 1, ")", 2);
  let t = add(add(parent, makeNodeFromStr("[", 3, "]", 4)), makeNodeFromStr("<", 5, ">", 6));
  map(t, x => {
    console.log(x);
    return x;
  });
  map(t, param => {
    let i = param._1;
    let a = param._0;
    if (a === "}" || a === "]" || a === ">" || a === ")") {
      console.log(i, "Close");
    } else {
      console.log(i, "Open");
    }
    return {
      TAG: "TokenAt",
      _0: a,
      _1: i
    };
  });
}

function getCorruptedScore(param) {
  let t = param._0;
  if (t === ")") {
    return 3;
  }
  if (t === ">") {
    return 25137;
  }
  if (t === "]") {
    return 57;
  }
  if (t === "}") {
    return 1197;
  }
  throw {
    RE_EXN_ID: NotSupported,
    _1: "not supported",
    Error: new Error()
  };
}

function getIncompleteScore(param) {
  let t = param._0;
  if (t === "(") {
    return 1;
  }
  if (t === "<") {
    return 4;
  }
  if (t === "[") {
    return 2;
  }
  if (t === "{") {
    return 3;
  }
  throw {
    RE_EXN_ID: NotSupported,
    _1: "not supported",
    Error: new Error()
  };
}

function solvePart1(data) {
  let corruptedOnly = r => {
    if (r.TAG === "Corrupted") {
      return r._0;
    }
    
  };
  return Belt_Array.reduce(Belt_Array.map(Belt_Array.keepMap(Belt_Array.map(parse(data), process), corruptedOnly), getCorruptedScore), 0, Utils.add);
}

function solvePart2(data) {
  let incompleteOnly = r => {
    if (r.TAG === "Corrupted") {
      return;
    } else {
      return r._0;
    }
  };
  let bigIntCompare = (a, b) => Stdlib__Ordering.toInt(Primitive_bigint.compare(a, b));
  let xs = Belt_SortArray.stableSortBy(Belt_Array.map(Belt_Array.keepMap(Belt_Array.map(parse(data), process), incompleteOnly), __x => Belt_Array.reduce(__x, 0n, (a, x) => a * 5n + BigInt(getIncompleteScore(x)))), bigIntCompare);
  let len = xs.length;
  return Belt_Option.getExn(Belt_Array.get(xs, len / 2 | 0)).toString();
}

let Stack;

export {
  log,
  Stack,
  ParseError,
  NotSupported,
  Token,
  tokenAtToString,
  tokenize,
  ParseTree,
  process,
  parse,
  examples,
  getCorruptedScore,
  getIncompleteScore,
  solvePart1,
  solvePart2,
}
/* Utils Not a pure module */
