// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Utils$AdventOfCode = require("../../Utils.bs.js");
var FP_Utils$AdventOfCode = require("../../FP_Utils.bs.js");

function log(prim) {
  console.log(prim);
  
}

var ParseError = /* @__PURE__ */Caml_exceptions.create("AOC2021_Day10-AdventOfCode.ParseError");

function isOpenBracket(token) {
  if (token === "{" || token === "[" || token === "<") {
    return true;
  } else {
    return token === "(";
  }
}

function isCloseBracket(token) {
  if (token === "}" || token === "]" || token === ">") {
    return true;
  } else {
    return token === ")";
  }
}

function make(c) {
  switch (c) {
    case "(" :
        return "(";
    case ")" :
        return ")";
    case "<" :
        return "<";
    case ">" :
        return ">";
    case "[" :
        return "[";
    case "]" :
        return "]";
    case "{" :
        return "{";
    case "}" :
        return "}";
    default:
      throw {
            RE_EXN_ID: ParseError,
            _1: c + " is not supported",
            Error: new Error()
          };
  }
}

var Token = {
  isOpenBracket: isOpenBracket,
  isCloseBracket: isCloseBracket,
  make: make
};

function map(t, f) {
  if (t) {
    return /* Node */{
            l: Curry._1(f, t.l),
            tl: Belt_List.map(t.tl, (function (__x) {
                    return map(__x, f);
                  })),
            r: Curry._1(f, t.r)
          };
  } else {
    return /* Empty */0;
  }
}

function makeNode(l, lp, r, rp) {
  return /* Node */{
          l: /* TokenAt */{
            _0: make(l),
            _1: lp
          },
          tl: {
            hd: /* Empty */0,
            tl: /* [] */0
          },
          r: /* TokenAt */{
            _0: make(r),
            _1: rp
          }
        };
}

function addChildren(t, children) {
  if (t) {
    return /* Node */{
            l: t.l,
            tl: children,
            r: t.r
          };
  } else {
    return /* Empty */0;
  }
}

var ParseTree = {
  map: map,
  makeNode: makeNode,
  addChildren: addChildren
};

function parse(data) {
  return Belt_Array.map(Utils$AdventOfCode.splitNewline(data), (function (param) {
                return FP_Utils$AdventOfCode.compose((function (prim) {
                              return prim.trim();
                            }), Utils$AdventOfCode.splitChars, param);
              }));
}

function solvePart1(data) {
  var parent = makeNode("(", 1, ")", 2);
  var t = addChildren(parent, {
        hd: makeNode("[", 3, "]", 4),
        tl: {
          hd: makeNode("<", 5, ">", 6),
          tl: /* [] */0
        }
      });
  map(t, (function (x) {
          console.log(x);
          return x;
        }));
  map(t, (function (param) {
          var i = param._1;
          var a = param._0;
          if (a === "}" || a === "]" || a === ">" || a === ")") {
            console.log(i, "Close");
          } else {
            console.log(i, "Open");
          }
          return /* TokenAt */{
                  _0: a,
                  _1: i
                };
        }));
  return 1;
}

function solvePart2(data) {
  return 2;
}

exports.log = log;
exports.ParseError = ParseError;
exports.Token = Token;
exports.ParseTree = ParseTree;
exports.parse = parse;
exports.solvePart1 = solvePart1;
exports.solvePart2 = solvePart2;
/* No side effect */
