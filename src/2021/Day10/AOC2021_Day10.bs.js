// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Utils$AdventOfCode = require("../../Utils.bs.js");
var FP_Utils$AdventOfCode = require("../../FP_Utils.bs.js");
var Stack_Array$AdventOfCode = require("../../Stack_Array.bs.js");

function log(prim) {
  console.log(prim);
  
}

var ParseError = /* @__PURE__ */Caml_exceptions.create("AOC2021_Day10-AdventOfCode.ParseError");

function isOpenBracket(token) {
  if (token === "{" || token === "[" || token === "<") {
    return true;
  } else {
    return token === "(";
  }
}

function isCloseBracket(token) {
  if (token === "}" || token === "]" || token === ">") {
    return true;
  } else {
    return token === ")";
  }
}

function matches(left, right) {
  return false;
}

function make(c) {
  switch (c) {
    case "(" :
        return "(";
    case ")" :
        return ")";
    case "<" :
        return "<";
    case ">" :
        return ">";
    case "[" :
        return "[";
    case "]" :
        return "]";
    case "{" :
        return "{";
    case "}" :
        return "}";
    default:
      throw {
            RE_EXN_ID: ParseError,
            _1: c + " is not supported",
            Error: new Error()
          };
  }
}

var Token = {
  isOpenBracket: isOpenBracket,
  isCloseBracket: isCloseBracket,
  matches: matches,
  make: make
};

function tokenize(xs) {
  return Belt_Array.mapWithIndex(xs, (function (i, x) {
                return /* TokenAt */{
                        _0: make(x),
                        _1: i
                      };
              }));
}

function map(t, f) {
  if (t) {
    return /* Node */{
            l: Curry._1(f, t.l),
            tl: Belt_List.map(t.tl, (function (__x) {
                    return map(__x, f);
                  })),
            r: Curry._1(f, t.r)
          };
  } else {
    return /* Empty */0;
  }
}

function makeNode(l, r) {
  return /* Node */{
          l: l,
          tl: {
            hd: /* Empty */0,
            tl: /* [] */0
          },
          r: r
        };
}

function makeNodeFromStr(l, li, r, ri) {
  return makeNode(/* TokenAt */{
              _0: make(l),
              _1: li
            }, /* TokenAt */{
              _0: make(r),
              _1: ri
            });
}

function addChildren(t, children) {
  if (t) {
    return /* Node */{
            l: t.l,
            tl: children,
            r: t.r
          };
  } else {
    return /* Empty */0;
  }
}

function makeParseTree(xs) {
  var _inputs = Belt_List.fromArray(tokenize(xs));
  var _idx = 0;
  var _tree = /* Empty */0;
  var _stack = [];
  while(true) {
    var stack = _stack;
    var tree = _tree;
    var idx = _idx;
    var inputs = _inputs;
    if (!inputs) {
      return tree;
    }
    var rest = inputs.tl;
    var $$this = inputs.hd;
    var last = Belt_Option.getExn(Stack_Array$AdventOfCode.peek(stack));
    if (matches(last._0, $$this._0)) {
      _tree = makeNode(last, $$this);
      _idx = idx + 1 | 0;
      _inputs = rest;
      continue ;
    }
    _stack = Stack_Array$AdventOfCode.push(stack, $$this);
    _idx = idx + 1 | 0;
    _inputs = rest;
    continue ;
  };
}

var ParseTree = {
  tokenize: tokenize,
  map: map,
  makeNode: makeNode,
  makeNodeFromStr: makeNodeFromStr,
  addChildren: addChildren,
  makeParseTree: makeParseTree
};

function parse(data) {
  return Belt_Array.map(Utils$AdventOfCode.splitNewline(data), (function (param) {
                return FP_Utils$AdventOfCode.compose((function (prim) {
                              return prim.trim();
                            }), Utils$AdventOfCode.splitChars, param);
              }));
}

function solvePart1(data) {
  var parent = makeNodeFromStr("(", 1, ")", 2);
  var t = addChildren(parent, {
        hd: makeNodeFromStr("[", 3, "]", 4),
        tl: {
          hd: makeNodeFromStr("<", 5, ">", 6),
          tl: /* [] */0
        }
      });
  map(t, (function (x) {
          console.log(x);
          return x;
        }));
  map(t, (function (param) {
          var i = param._1;
          var a = param._0;
          if (a === "}" || a === "]" || a === ">" || a === ")") {
            console.log(i, "Close");
          } else {
            console.log(i, "Open");
          }
          return /* TokenAt */{
                  _0: a,
                  _1: i
                };
        }));
  return 1;
}

function solvePart2(data) {
  return 2;
}

var Stack;

exports.log = log;
exports.Stack = Stack;
exports.ParseError = ParseError;
exports.Token = Token;
exports.ParseTree = ParseTree;
exports.parse = parse;
exports.solvePart1 = solvePart1;
exports.solvePart2 = solvePart2;
/* No side effect */
