// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Utils from "../../Utils.mjs";
import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/Belt_Option.js";
import * as AdjacencyList from "../../AdjacencyList.mjs";
import * as Belt_HashMapString from "rescript/lib/es6/Belt_HashMapString.js";
import * as Belt_SortArrayString from "rescript/lib/es6/Belt_SortArrayString.js";
import * as Primitive_exceptions from "rescript/lib/es6/Primitive_exceptions.js";
import * as Belt_MutableSetString from "rescript/lib/es6/Belt_MutableSetString.js";

function log(prim) {
  console.log(prim);
}

let ParseError = /* @__PURE__ */Primitive_exceptions.create("AOC2021_Day12.Maze.ParseError");

function make(edges) {
  let maze = AdjacencyList.$$String.make();
  Belt_Array.forEach(edges, edge => {
    if (edge.length !== 2) {
      throw {
        RE_EXN_ID: ParseError,
        Error: new Error()
      };
    }
    let a = edge[0];
    let b = edge[1];
    AdjacencyList.$$String.addEdge(maze, a, b);
    AdjacencyList.$$String.addEdge(maze, b, a);
  });
  return maze;
}

let toString = AdjacencyList.$$String.toString;

let Maze = {
  AdjList: undefined,
  ParseError: ParseError,
  make: make,
  toString: toString
};

function is_visited(visited, node) {
  return Belt_Option.mapWithDefault(Belt_HashMapString.get(visited, node), false, v => v > 0);
}

function inc_visited(visited, node) {
  return Utils.hashMapStringUpdate(visited, node, Utils.increaseBy1);
}

function get_visited_count(visited, node) {
  return Belt_Option.getWithDefault(Belt_HashMapString.get(visited, node), 0);
}

function is_upper_case(c) {
  return c.toUpperCase() === c;
}

function is_small_case(c) {
  return c.toLowerCase() === c;
}

function has_any_small_cave_been_visited_twice(visited) {
  let smalls = Belt_HashMapString.reduce(visited, [], (acc, key, value) => {
    if (key.toLowerCase() === key && value > 1) {
      return Belt_Array.concat(acc, [[
          key,
          value
        ]]);
    } else {
      return acc;
    }
  });
  return smalls.length !== 0;
}

function get_edges(t, node) {
  return AdjacencyList.$$String.neighbors(t, node);
}

function can_visit_part1(visited, node) {
  if (node.toUpperCase() === node) {
    return true;
  } else {
    return get_visited_count(visited, node) <= 0;
  }
}

function can_visit_part2(visited, node) {
  let c = get_visited_count(visited, node);
  if (node.toUpperCase() === node) {
    return true;
  }
  switch (node) {
    case "end" :
    case "start" :
      return c <= 0;
    default:
      if (c <= 0) {
        return true;
      } else {
        return !has_any_small_cave_been_visited_twice(visited);
      }
  }
}

function dfs(visit_func, t, start_node, end_node) {
  let explore = (node, visited, acc, end_node) => {
    let visited$p = Utils.hashMapStringUpdate(visited, node, Utils.increaseBy1);
    if (node === end_node) {
      return [acc];
    }
    let edges = AdjacencyList.$$String.neighbors(t, node);
    return Belt_MutableSetString.reduce(edges, [], (a, e) => {
      if (visit_func(visited$p, e)) {
        return Belt_Array.concat(a, explore(e, Belt_HashMapString.copy(visited$p), Belt_Array.concat(acc, [e]), end_node));
      } else {
        return a;
      }
    });
  };
  let visited = Belt_HashMapString.make(40);
  let acc = [start_node];
  return explore(start_node, visited, acc, end_node);
}

function dfs_part1(m, start, end) {
  return dfs(can_visit_part1, m, start, end);
}

function dfs_part2(m, start, end) {
  return dfs(can_visit_part2, m, start, end);
}

function array_to_string(xs) {
  return Belt_Array.reduce(xs, "", (acc, x) => acc + " " + x);
}

function sort_result(result) {
  return Belt_SortArrayString.stableSort(Belt_Array.map(result, array_to_string));
}

function parse(data) {
  return Belt_Array.map(Belt_Array.map(Utils.splitNewline(data), prim => prim.trim()), __x => __x.split("-"));
}

function solvePart1(data) {
  let maze = make(parse(data));
  return dfs_part1(maze, "start", "end").length;
}

function solvePart2(data) {
  let maze = make(parse(data));
  return dfs_part2(maze, "start", "end").length;
}

let is_big_cave = is_upper_case;

let is_small_cave = is_small_case;

let get_visited_nodes = Belt_HashMapString.keysToArray;

export {
  log,
  Maze,
  is_visited,
  inc_visited,
  get_visited_count,
  is_upper_case,
  is_small_case,
  is_big_cave,
  is_small_cave,
  has_any_small_cave_been_visited_twice,
  get_edges,
  can_visit_part1,
  can_visit_part2,
  get_visited_nodes,
  dfs,
  dfs_part1,
  dfs_part2,
  array_to_string,
  sort_result,
  parse,
  solvePart1,
  solvePart2,
}
/* Utils Not a pure module */
