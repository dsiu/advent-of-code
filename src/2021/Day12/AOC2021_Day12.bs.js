// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Belt_HashMapString = require("rescript/lib/js/belt_HashMapString.js");
var Belt_HashSetString = require("rescript/lib/js/belt_HashSetString.js");
var Utils$AdventOfCode = require("../../Utils.bs.js");
var Belt_SortArrayString = require("rescript/lib/js/belt_SortArrayString.js");
var Adjacency_List$AdventOfCode = require("../../Adjacency_List.bs.js");

function log(prim) {
  console.log(prim);
  
}

var ParseError = /* @__PURE__ */Caml_exceptions.create("AOC2021_Day12-AdventOfCode.Maze.ParseError");

function make(edges) {
  var maze = Adjacency_List$AdventOfCode.make(40);
  Belt_Array.forEach(edges, (function (edge) {
          if (edge.length !== 2) {
            throw {
                  RE_EXN_ID: ParseError,
                  Error: new Error()
                };
          }
          var a = edge[0];
          var b = edge[1];
          Adjacency_List$AdventOfCode.addEdge(maze, a, b);
          return Adjacency_List$AdventOfCode.addEdge(maze, b, a);
        }));
  return maze;
}

var Maze = {
  ParseError: ParseError,
  make: make,
  toString: Adjacency_List$AdventOfCode.toString
};

function is_visited(visited, node) {
  return Belt_Option.mapWithDefault(Belt_HashMapString.get(visited, node), false, (function (v) {
                return v > 0;
              }));
}

function inc_visited(visited, node) {
  return Utils$AdventOfCode.hashMapStringUpdate(visited, node, Utils$AdventOfCode.increaseBy1);
}

function get_visited_count(visited, node) {
  return Belt_Option.getWithDefault(Belt_HashMapString.get(visited, node), 0);
}

function is_upper_case(c) {
  return c.toUpperCase() === c;
}

function is_small_case(c) {
  return c.toLowerCase() === c;
}

function has_any_small_cave_been_visited_twice(visited) {
  var smalls = Belt_HashMapString.reduce(visited, [], (function (acc, key, value) {
          if (key.toLowerCase() === key && value > 1) {
            return Belt_Array.concat(acc, [[
                          key,
                          value
                        ]]);
          } else {
            return acc;
          }
        }));
  return smalls.length !== 0;
}

var get_edges = Adjacency_List$AdventOfCode.neighbors;

function can_visit_part1(visited, node) {
  if (node.toUpperCase() === node) {
    return true;
  } else {
    return get_visited_count(visited, node) <= 0;
  }
}

function can_visit_part2(visited, node) {
  var c = get_visited_count(visited, node);
  if (node.toUpperCase() === node) {
    return true;
  }
  switch (node) {
    case "end" :
    case "start" :
        return c <= 0;
    default:
      if (c <= 0) {
        return true;
      } else {
        return !has_any_small_cave_been_visited_twice(visited);
      }
  }
}

function dfs(visit_func, t, start_node, end_node) {
  var explore = function (node, visited, acc, end_node) {
    var visited$p = Utils$AdventOfCode.hashMapStringUpdate(visited, node, Utils$AdventOfCode.increaseBy1);
    if (node === end_node) {
      return [acc];
    }
    var edges = Adjacency_List$AdventOfCode.neighbors(t, node);
    return Belt_HashSetString.reduce(edges, [], (function (a, e) {
                  if (Curry._2(visit_func, visited$p, e)) {
                    return Belt_Array.concat(a, explore(e, Belt_HashMapString.copy(visited$p), Belt_Array.concat(acc, [e]), end_node));
                  } else {
                    return a;
                  }
                }));
  };
  var visited = Belt_HashMapString.make(40);
  var acc = [start_node];
  return explore(start_node, visited, acc, end_node);
}

function dfs_part1(param, param$1, param$2) {
  return dfs(can_visit_part1, param, param$1, param$2);
}

function dfs_part2(param, param$1, param$2) {
  return dfs(can_visit_part2, param, param$1, param$2);
}

function array_to_string(xs) {
  return Belt_Array.reduce(xs, "", (function (acc, x) {
                return acc + " " + x;
              }));
}

function sort_result(result) {
  return Belt_SortArrayString.stableSort(Belt_Array.map(result, array_to_string));
}

function parse(data) {
  return Belt_Array.map(Belt_Array.map(Utils$AdventOfCode.splitNewline(data), (function (prim) {
                    return prim.trim();
                  })), (function (__x) {
                return __x.split("-");
              }));
}

function solvePart1(data) {
  var maze = make(parse(data));
  return dfs_part1(maze, "start", "end").length;
}

function solvePart2(data) {
  var maze = make(parse(data));
  return dfs_part2(maze, "start", "end").length;
}

var is_big_cave = is_upper_case;

var is_small_cave = is_small_case;

var get_visited_nodes = Belt_HashMapString.keysToArray;

exports.log = log;
exports.Maze = Maze;
exports.is_visited = is_visited;
exports.inc_visited = inc_visited;
exports.get_visited_count = get_visited_count;
exports.is_upper_case = is_upper_case;
exports.is_small_case = is_small_case;
exports.is_big_cave = is_big_cave;
exports.is_small_cave = is_small_cave;
exports.has_any_small_cave_been_visited_twice = has_any_small_cave_been_visited_twice;
exports.get_edges = get_edges;
exports.can_visit_part1 = can_visit_part1;
exports.can_visit_part2 = can_visit_part2;
exports.get_visited_nodes = get_visited_nodes;
exports.dfs = dfs;
exports.dfs_part1 = dfs_part1;
exports.dfs_part2 = dfs_part2;
exports.array_to_string = array_to_string;
exports.sort_result = sort_result;
exports.parse = parse;
exports.solvePart1 = solvePart1;
exports.solvePart2 = solvePart2;
/* No side effect */
