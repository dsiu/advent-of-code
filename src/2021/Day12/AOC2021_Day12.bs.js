// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Belt_HashMap = require("rescript/lib/js/belt_HashMap.js");
var Belt_HashMapString = require("rescript/lib/js/belt_HashMapString.js");
var Belt_HashSetString = require("rescript/lib/js/belt_HashSetString.js");
var Utils$AdventOfCode = require("../../Utils.bs.js");

function log(prim) {
  console.log(prim);
  
}

function addVertex(t, x) {
  var match = Belt_HashMapString.get(t, x);
  if (match !== undefined) {
    return ;
  } else {
    return Belt_HashMapString.set(t, x, Belt_HashSetString.make(40));
  }
}

function getVertex(t, x) {
  addVertex(t, x);
  var v = Belt_HashMapString.get(t, x);
  if (v !== undefined) {
    return Caml_option.valFromOption(v);
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function addEdge(t, x, y) {
  return Belt_HashSetString.add(getVertex(t, x), y);
}

function adjacent(t, x, y) {
  var v = Belt_HashMap.get(t, x);
  if (v !== undefined) {
    return Belt_HashSetString.has(Caml_option.valFromOption(v), y);
  } else {
    return false;
  }
}

function neighbors(t, x) {
  var v = Belt_HashMap.get(t, x);
  if (v !== undefined) {
    return Belt_HashSetString.toArray(Caml_option.valFromOption(v));
  } else {
    return [];
  }
}

var Graph = {
  make: Belt_HashMapString.make,
  addVertex: addVertex,
  getVertex: getVertex,
  addEdge: addEdge,
  adjacent: adjacent,
  neighbors: neighbors
};

function parse(data) {
  return Belt_Array.map(Utils$AdventOfCode.splitNewline(data), (function (prim) {
                return prim.trim();
              }));
}

function solvePart1(data) {
  return 1;
}

function solvePart2(data) {
  return 2;
}

exports.log = log;
exports.Graph = Graph;
exports.parse = parse;
exports.solvePart1 = solvePart1;
exports.solvePart2 = solvePart2;
/* No side effect */
