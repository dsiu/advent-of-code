// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Belt_HashSetString = require("rescript/lib/js/belt_HashSetString.js");
var Utils$AdventOfCode = require("../../Utils.bs.js");
var FP_Utils$AdventOfCode = require("../../FP_Utils.bs.js");
var Adjacency_List$AdventOfCode = require("../../Adjacency_List.bs.js");

function log(prim) {
  console.log(prim);
  
}

var ParseError = /* @__PURE__ */Caml_exceptions.create("AOC2021_Day12-AdventOfCode.Maze.ParseError");

function make(edges) {
  var maze = Adjacency_List$AdventOfCode.make(40);
  Belt_Array.forEach(edges, (function (edge) {
          if (edge.length !== 2) {
            throw {
                  RE_EXN_ID: ParseError,
                  Error: new Error()
                };
          }
          var a = edge[0];
          var b = edge[1];
          Adjacency_List$AdventOfCode.addEdge(maze, a, b);
          return Adjacency_List$AdventOfCode.addEdge(maze, b, a);
        }));
  return maze;
}

var Maze = {
  ParseError: ParseError,
  make: make,
  toString: Adjacency_List$AdventOfCode.toString
};

function array_count(xs, predicate) {
  return Belt_Array.keep(xs, predicate).length;
}

var CycleFound = /* @__PURE__ */Caml_exceptions.create("AOC2021_Day12-AdventOfCode.CycleFound");

function count_node_in_array(a, node) {
  var predicate = function (param) {
    return FP_Utils$AdventOfCode.eq(node, param);
  };
  return Belt_Array.keep(a, predicate).length;
}

function is_visited(visited, node) {
  var predicate = function (param) {
    return FP_Utils$AdventOfCode.eq(node, param);
  };
  return Belt_Array.keep(visited, predicate).length !== 0;
}

var get_edges = Adjacency_List$AdventOfCode.neighbors;

function is_upper_case(c) {
  return c.toUpperCase() === c;
}

function can_visited_part1(visited, node) {
  if (node.toUpperCase() === node) {
    return true;
  }
  var predicate = function (param) {
    return FP_Utils$AdventOfCode.eq(node, param);
  };
  return Belt_Array.keep(visited, predicate).length <= 0;
}

function can_visited_part2(visited, node) {
  var predicate = function (param) {
    return FP_Utils$AdventOfCode.eq(node, param);
  };
  var c = Belt_Array.keep(visited, predicate).length;
  switch (node) {
    case "end" :
    case "start" :
        return c < 1;
    default:
      if (node.toUpperCase() === node) {
        return true;
      } else {
        return c < 2;
      }
  }
}

function dfs(visit_func, t, start_node, end_node) {
  var explore = function (node, visited, path, acc, end_node) {
    var visited$p = Belt_Array.concat(visited, [node]);
    if (node === end_node) {
      return [acc];
    }
    var edges = Adjacency_List$AdventOfCode.neighbors(t, node);
    return Belt_HashSetString.reduce(edges, [], (function (a, e) {
                  if (Curry._2(visit_func, visited$p, e)) {
                    return Belt_Array.concat(a, explore(e, visited$p, path, Belt_Array.concat(visited$p, [e]), end_node));
                  } else {
                    return a;
                  }
                }));
  };
  var visited = [];
  var path = [];
  var acc = [];
  return explore(start_node, visited, path, acc, end_node);
}

function dfs_part1(param, param$1, param$2) {
  return dfs(can_visited_part1, param, param$1, param$2);
}

function dfs_part2(param, param$1, param$2) {
  return dfs(can_visited_part2, param, param$1, param$2);
}

function parse(data) {
  return Belt_Array.map(Belt_Array.map(Utils$AdventOfCode.splitNewline(data), (function (prim) {
                    return prim.trim();
                  })), (function (__x) {
                return __x.split("-");
              }));
}

function solvePart1(data) {
  var maze = make(parse(data));
  console.log(Adjacency_List$AdventOfCode.toString(maze));
  var result = dfs_part1(maze, "start", "end");
  console.log(result.length);
  return result.length;
}

function solvePart2(data) {
  var maze = make(parse(data));
  console.log(Adjacency_List$AdventOfCode.toString(maze));
  var result = dfs_part2(maze, "start", "end");
  console.log("part 2: ", result);
  console.log(result.length);
  return result.length;
}

exports.log = log;
exports.Maze = Maze;
exports.array_count = array_count;
exports.CycleFound = CycleFound;
exports.count_node_in_array = count_node_in_array;
exports.is_visited = is_visited;
exports.get_edges = get_edges;
exports.is_upper_case = is_upper_case;
exports.can_visited_part1 = can_visited_part1;
exports.can_visited_part2 = can_visited_part2;
exports.dfs = dfs;
exports.dfs_part1 = dfs_part1;
exports.dfs_part2 = dfs_part2;
exports.parse = parse;
exports.solvePart1 = solvePart1;
exports.solvePart2 = solvePart2;
/* No side effect */
