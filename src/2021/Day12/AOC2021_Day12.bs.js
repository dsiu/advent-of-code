// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Utils$AdventOfCode = require("../../Utils.bs.js");
var Adjacency_List$AdventOfCode = require("../../Adjacency_List.bs.js");

function log(prim) {
  console.log(prim);
  
}

var ParseError = /* @__PURE__ */Caml_exceptions.create("AOC2021_Day12-AdventOfCode.Maze.ParseError");

function make(edges) {
  var maze = Adjacency_List$AdventOfCode.make(40);
  Belt_Array.forEach(edges, (function (edge) {
          if (edge.length !== 2) {
            throw {
                  RE_EXN_ID: ParseError,
                  Error: new Error()
                };
          }
          var a = edge[0];
          var b = edge[1];
          Adjacency_List$AdventOfCode.addEdge(maze, a, b);
          return Adjacency_List$AdventOfCode.addEdge(maze, b, a);
        }));
  return maze;
}

var Maze = {
  ParseError: ParseError,
  make: make,
  toString: Adjacency_List$AdventOfCode.toString
};

function parse(data) {
  return Belt_Array.map(Belt_Array.map(Utils$AdventOfCode.splitNewline(data), (function (prim) {
                    return prim.trim();
                  })), (function (__x) {
                return __x.split("-");
              }));
}

function solvePart1(data) {
  console.log(Adjacency_List$AdventOfCode.toString(make(parse(data))));
  return 1;
}

function solvePart2(data) {
  return 2;
}

exports.log = log;
exports.Maze = Maze;
exports.parse = parse;
exports.solvePart1 = solvePart1;
exports.solvePart2 = solvePart2;
/* No side effect */
