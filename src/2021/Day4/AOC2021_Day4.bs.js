// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Belt_Int = require("rescript/lib/js/belt_Int.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Belt_SetInt = require("rescript/lib/js/belt_SetInt.js");
var Utils$AdventOfCode = require("../../Utils.bs.js");
var Array2D$AdventOfCode = require("../../Array2D.bs.js");

function log(prim) {
  console.log(prim);
  
}

function make(line) {
  return Belt_Array.keepMap(line.split(","), Belt_Int.fromString);
}

var Draws = {
  make: make
};

function make$1(lines) {
  return Belt_Array.map(lines, (function (x) {
                return Belt_Array.keepMap(x.split(" "), (function (s) {
                              if (s.length > 0) {
                                return Belt_Int.fromString(s.trim());
                              }
                              
                            }));
              }));
}

function match(candidates, match_draws) {
  var can_set = Belt_SetInt.fromArray(candidates);
  var draws_set = Belt_SetInt.fromArray(match_draws);
  if (Belt_SetInt.subset(can_set, draws_set)) {
    return Belt_SetInt.toArray(can_set);
  }
  
}

function solve(t, match_draws) {
  var helper = function (t, i, getter, limit) {
    if (i < limit) {
      return Belt_Option.flatMap(Curry._2(getter, t, i), (function (row) {
                    var matched = match(row, match_draws);
                    if (matched !== undefined) {
                      return matched;
                    } else {
                      return helper(t, i + 1 | 0, getter, limit);
                    }
                  }));
    }
    
  };
  var matchY = helper(t, 0, Array2D$AdventOfCode.getYEquals, Array2D$AdventOfCode.lengthY(t));
  var matchX = helper(t, 0, Array2D$AdventOfCode.getXEquals, Array2D$AdventOfCode.lengthX(t));
  var unmarked = function (t, m) {
    return Belt_SetInt.toArray(Belt_SetInt.diff(Belt_SetInt.fromArray(Array2D$AdventOfCode.flatten(t)), Belt_SetInt.fromArray(m)));
  };
  if (matchX !== undefined || matchY !== undefined) {
    return unmarked(t, match_draws);
  }
  
}

var Board = {
  make: make$1,
  match: match,
  solve: solve
};

function make$2(lines) {
  return Belt_Array.map(lines, (function (b) {
                return make$1(Belt_Array.map(Utils$AdventOfCode.splitNewline(b), (function (prim) {
                                  return prim.trim();
                                })));
              }));
}

function dump(t) {
  return Belt_Array.forEach(t, (function (prim) {
                console.log(prim);
                
              }));
}

function solvePart1(t, draws) {
  var _i = 5;
  var limit = draws.length;
  while(true) {
    var i = _i;
    if (i > limit) {
      return ;
    }
    var keys = Belt_Array.slice(draws, 0, i);
    var results = Belt_Array.keepMap(t, (function(keys){
        return function (__x) {
          return solve(__x, keys);
        }
        }(keys)));
    var match = results.length;
    if (match !== 0) {
      if (match !== 1) {
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
      }
      return [
              Belt_Option.getExn(Belt_Array.get(draws, i - 1 | 0)),
              Belt_Array.get(results, 0)
            ];
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function solvePart2(t, draws) {
  var _t = t;
  var _i = 5;
  var limit = draws.length;
  while(true) {
    var i = _i;
    var t$1 = _t;
    if (i > limit) {
      return ;
    }
    var keys = Belt_Array.slice(draws, 0, i);
    var results = Belt_Array.keepMap(t$1, (function(keys){
        return function (__x) {
          return solve(__x, keys);
        }
        }(keys)));
    var results_not = Belt_Array.keepMap(t$1, (function(keys){
        return function (b) {
          var match = solve(b, keys);
          if (match !== undefined) {
            return ;
          } else {
            return b;
          }
        }
        }(keys)));
    var match = results.length;
    var match$1 = results_not.length;
    if (match === 1 && match$1 === 0) {
      return [
              Belt_Option.getExn(Belt_Array.get(draws, i - 1 | 0)),
              Belt_Array.get(results, 0)
            ];
    }
    _i = i + 1 | 0;
    _t = results_not;
    continue ;
  };
}

var Boards = {
  make: make$2,
  dump: dump,
  solvePart1: solvePart1,
  solvePart2: solvePart2
};

function parse(data) {
  var lines = Belt_Array.map(Utils$AdventOfCode.splitDoubleNewline(data), (function (x) {
          return x.trim();
        }));
  var draws = make(Belt_Option.getExn(Belt_Array.get(lines, 0)));
  var boards = make$2(Belt_Array.sliceToEnd(lines, 1));
  return [
          draws,
          boards
        ];
}

function solvePart1$1(data) {
  var match = parse(data);
  var match$1 = Belt_Option.getExn(solvePart1(match[1], match[0]));
  var add = function (x, y) {
    return x + y | 0;
  };
  return Math.imul(match$1[0], Belt_Array.reduce(Belt_Option.getExn(match$1[1]), 0, add));
}

function solvePart2$1(data) {
  var match = parse(data);
  var match$1 = Belt_Option.getExn(solvePart2(match[1], match[0]));
  var add = function (x, y) {
    return x + y | 0;
  };
  return Math.imul(match$1[0], Belt_Array.reduce(Belt_Option.getExn(match$1[1]), 0, add));
}

exports.log = log;
exports.Draws = Draws;
exports.Board = Board;
exports.Boards = Boards;
exports.parse = parse;
exports.solvePart1 = solvePart1$1;
exports.solvePart2 = solvePart2$1;
/* No side effect */
