// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Int from "rescript/lib/es6/Belt_Int.js";
import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/Belt_Option.js";
import * as Belt_SetInt from "rescript/lib/es6/Belt_SetInt.js";
import * as Utils$AdventOfCode from "../../Utils.mjs";
import * as Array2D$AdventOfCode from "../../Array2D.mjs";

function log(prim) {
  console.log(prim);
}

function make(line) {
  return Belt_Array.keepMap(line.split(","), Belt_Int.fromString);
}

let Draws = {
  make: make
};

function toString(t) {
  return Array2D$AdventOfCode.toString(t, __x => __x.toString());
}

function make$1(lines) {
  return Belt_Array.map(lines, x => Belt_Array.keepMap(x.split(" "), s => {
    if (s.length > 0) {
      return Belt_Int.fromString(s.trim());
    }
    
  }));
}

function match(candidates, match_draws) {
  let can_set = Belt_SetInt.fromArray(candidates);
  let draws_set = Belt_SetInt.fromArray(match_draws);
  if (Belt_SetInt.subset(can_set, draws_set)) {
    return Belt_SetInt.toArray(can_set);
  }
  
}

function solve(t, match_draws) {
  let helper = (t, i, getter, limit) => {
    if (i < limit) {
      return Belt_Option.flatMap(getter(t, i), row => {
        let matched = match(row, match_draws);
        if (matched !== undefined) {
          return matched;
        } else {
          return helper(t, i + 1 | 0, getter, limit);
        }
      });
    }
    
  };
  let matchY = helper(t, 0, Array2D$AdventOfCode.getYEquals, Array2D$AdventOfCode.lengthY(t));
  let matchX = helper(t, 0, Array2D$AdventOfCode.getXEquals, Array2D$AdventOfCode.lengthX(t));
  let remove_marked = (t, m) => Belt_SetInt.toArray(Belt_SetInt.diff(Belt_SetInt.fromArray(Array2D$AdventOfCode.flatten(t)), Belt_SetInt.fromArray(m)));
  if (matchX !== undefined || matchY !== undefined) {
    return remove_marked(t, match_draws);
  }
  
}

let Board = {
  toString: toString,
  make: make$1,
  match: match,
  solve: solve
};

function make$2(lines) {
  return Belt_Array.map(lines, b => make$1(Belt_Array.map(Utils$AdventOfCode.splitNewline(b), prim => prim.trim())));
}

function toString$1(t) {
  return Utils$AdventOfCode.Printable.$$Array.toString(t, toString);
}

function solvePart1(t, draws) {
  let _i = 5;
  let limit = draws.length;
  while (true) {
    let i = _i;
    if (i > limit) {
      return;
    }
    let keys = Belt_Array.slice(draws, 0, i);
    let results = Belt_Array.keepMap(t, __x => solve(__x, keys));
    let match = results.length;
    if (match !== 0) {
      if (match !== 1) {
        throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
      }
      return [
        Belt_Option.getExn(Belt_Array.get(draws, i - 1 | 0)),
        Belt_Array.get(results, 0)
      ];
    }
    _i = i + 1 | 0;
    continue;
  };
}

function solvePart2(t, draws) {
  let _t = t;
  let _i = 5;
  let limit = draws.length;
  while (true) {
    let i = _i;
    let t$1 = _t;
    if (i > limit) {
      return;
    }
    let keys = Belt_Array.slice(draws, 0, i);
    let results = Belt_Array.keepMap(t$1, __x => solve(__x, keys));
    let results_not = Belt_Array.keepMap(t$1, b => {
      let match = solve(b, keys);
      if (match !== undefined) {
        return;
      } else {
        return b;
      }
    });
    let match = results.length;
    let match$1 = results_not.length;
    if (match === 1 && match$1 === 0) {
      return [
        Belt_Option.getExn(Belt_Array.get(draws, i - 1 | 0)),
        Belt_Array.get(results, 0)
      ];
    }
    _i = i + 1 | 0;
    _t = results_not;
    continue;
  };
}

let Boards = {
  make: make$2,
  toString: toString$1,
  solvePart1: solvePart1,
  solvePart2: solvePart2
};

function parse(data) {
  let lines = Belt_Array.map(Utils$AdventOfCode.splitDoubleNewline(data), prim => prim.trim());
  let draws = make(Belt_Option.getExn(Belt_Array.get(lines, 0)));
  let boards = make$2(Belt_Array.sliceToEnd(lines, 1));
  return [
    draws,
    boards
  ];
}

function solvePart1$1(data) {
  let match = parse(data);
  let match$1 = Belt_Option.getExn(solvePart1(match[1], match[0]));
  return Math.imul(match$1[0], Belt_Array.reduce(Belt_Option.getExn(match$1[1]), 0, Utils$AdventOfCode.add));
}

function solvePart2$1(data) {
  let match = parse(data);
  let match$1 = Belt_Option.getExn(solvePart2(match[1], match[0]));
  return Math.imul(match$1[0], Belt_Array.reduce(Belt_Option.getExn(match$1[1]), 0, Utils$AdventOfCode.add));
}

export {
  log,
  Draws,
  Board,
  Boards,
  parse,
  solvePart1$1 as solvePart1,
  solvePart2$1 as solvePart2,
}
/* Utils-AdventOfCode Not a pure module */
