// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Hashtbl from "rescript/lib/es6/hashtbl.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Imperative$Graph from "rescript-ocamlgraph/src/imperative.bs.js";
import * as Utils$AdventOfCode from "../../Utils.bs.js";
import * as Array2D$AdventOfCode from "../../Array2D.bs.js";

function log(prim) {
  console.log(prim);
  
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
  
}

var compare = Caml_obj.caml_compare;

var equal = Caml_obj.caml_equal;

var E = {
  compare: compare,
  hash: Hashtbl.hash,
  equal: equal,
  $$default: 0
};

function compare$1(param, param$1) {
  var dy = param$1[1] - param[1] | 0;
  var dx = param$1[0] - param[0] | 0;
  if (dx === 0 && dy === 0) {
    return 0;
  } else if (dx > 0 && dy > 0) {
    return 1;
  } else {
    return dx + dy | 0;
  }
}

function equal$1(v1, v2) {
  return compare$1(v1, v2) === 0;
}

function hash_int(x) {
  return caml_hash_final_mix(caml_hash_mix_int(31, x));
}

function hash(param) {
  return caml_hash_final_mix(caml_hash_mix_int(31, param[0])) + Math.imul(31, caml_hash_final_mix(caml_hash_mix_int(31, param[1]))) | 0;
}

var V = {
  compare: compare$1,
  equal: equal$1,
  seed: 31,
  hash_int: hash_int,
  hash: hash
};

var partial_arg = {
  compare: compare$1,
  hash: hash,
  equal: equal$1
};

var partial_arg$1 = Imperative$Graph.Graph.ConcreteLabeled;

var G = (function (param) {
      return partial_arg$1(partial_arg, param);
    })({
      compare: compare,
      $$default: 0
    });

function make(lines) {
  Array2D$AdventOfCode.reduceWithIndex(lines, "", (function (a, e, param) {
          var y = param[1];
          var x = param[0];
          var h = String(hash([
                    x,
                    y
                  ]));
          var prim = String(x) + "," + String(y) + " (" + h + ") = " + e;
          console.log(prim);
          return "";
        }));
  return "";
}

var Cave = {
  E: E,
  V: V,
  G: G,
  make: make
};

function parse(data) {
  var lines = Belt_Array.map(Utils$AdventOfCode.splitNewline(data), (function (l) {
          return Utils$AdventOfCode.splitChars(l.trim());
        }));
  var y = lines.length;
  console.log(y, "y");
  var x = Belt_Option.getExn(Belt_Option.flatMap(Belt_Array.get(lines, 0), (function (x) {
              return x.length;
            })));
  console.log(x, "x");
  return lines;
}

function solvePart1(data) {
  make(parse(data));
  return 1;
}

function solvePart2(data) {
  return 2;
}

export {
  log ,
  log2 ,
  Cave ,
  parse ,
  solvePart1 ,
  solvePart2 ,
  
}
/* G Not a pure module */
