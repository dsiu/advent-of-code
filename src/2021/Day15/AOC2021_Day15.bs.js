// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Format from "rescript/lib/es6/format.js";
import * as Hashtbl from "rescript/lib/es6/hashtbl.js";
import * as Belt_Int from "rescript/lib/es6/belt_Int.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Graphviz$Graph from "rescript-ocamlgraph/src/graphviz.bs.js";
import * as Imperative$Graph from "rescript-ocamlgraph/src/imperative.bs.js";
import * as Utils$AdventOfCode from "../../Utils.bs.js";
import * as Array2D$AdventOfCode from "../../Array2D.bs.js";
import * as Coordinate$AdventOfCode from "../../Coordinate.bs.js";

function log(prim) {
  console.log(prim);
  
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
  
}

var compare = Caml_obj.caml_compare;

var equal = Caml_obj.caml_equal;

var E = {
  compare: compare,
  hash: Hashtbl.hash,
  equal: equal,
  $$default: 0
};

function compare$1(param, param$1) {
  var dy = param$1[1] - param[1] | 0;
  var dx = param$1[0] - param[0] | 0;
  if (dx === 0 && dy === 0) {
    return 0;
  } else if (dx > 0 && dy > 0) {
    return 1;
  } else {
    return dx + dy | 0;
  }
}

function equal$1(v1, v2) {
  return compare$1(v1, v2) === 0;
}

function hash(param) {
  return Hashtbl.hash([
              param[0],
              param[1]
            ]);
}

var V = {
  compare: compare$1,
  equal: equal$1,
  seed: 31,
  hash: hash
};

var partial_arg = {
  compare: compare$1,
  hash: hash,
  equal: equal$1
};

var partial_arg$1 = Imperative$Graph.Graph.ConcreteLabeled;

var G = (function (param) {
      return partial_arg$1(partial_arg, param);
    })({
      compare: compare,
      $$default: 0
    });

function adjCoords(c) {
  return Belt_List.map({
              hd: Coordinate$AdventOfCode.stepN,
              tl: {
                hd: Coordinate$AdventOfCode.stepW,
                tl: {
                  hd: Coordinate$AdventOfCode.stepE,
                  tl: {
                    hd: Coordinate$AdventOfCode.stepS,
                    tl: /* [] */0
                  }
                }
              }
            }, (function (f) {
                return Curry._1(f, c);
              }));
}

function getAdjacents(t, param) {
  return Belt_List.keepMap(adjCoords([
                  param[0],
                  param[1]
                ]), (function (c) {
                if (Array2D$AdventOfCode.isValidXY(t, c)) {
                  return /* CoordAndVal */{
                          _0: c,
                          _1: Array2D$AdventOfCode.getExn(t, c)
                        };
                }
                
              }));
}

function make(lines) {
  return Array2D$AdventOfCode.reduceWithIndex(lines, Curry._2(G.create, undefined, undefined), (function (g, e, c) {
                var y = c[1];
                var x = c[0];
                Belt_List.forEach(getAdjacents(lines, c), (function (param) {
                        var cost = param._1;
                        var match = param._0;
                        var y$p = match[1];
                        var x$p = match[0];
                        Curry._2(G.add_edge_e, g, [
                              [
                                x,
                                y
                              ],
                              cost,
                              [
                                x$p,
                                y$p
                              ]
                            ]);
                        var prim = "(" + String(x) + ", " + String(y) + ")[" + String(hash([
                                  x,
                                  y
                                ])) + "], " + String(cost) + ", (" + String(x$p) + ", " + String(y$p) + ")[(" + String(hash([
                                  x$p,
                                  y$p
                                ])) + ")]";
                        console.log(prim);
                        
                      }));
                return g;
              }));
}

var E$1 = G.E;

var iter_vertex = G.iter_vertex;

var iter_edges_e = G.iter_edges_e;

function vertex_name(v) {
  var match = Curry._1(G.V.label, v);
  return "\"" + String(match[0]) + "," + String(match[1]) + "\"";
}

function graph_attributes(param) {
  return /* [] */0;
}

function default_vertex_attributes(param) {
  return /* [] */0;
}

function vertex_attributes(param) {
  return /* [] */0;
}

function default_edge_attributes(param) {
  return /* [] */0;
}

function edge_attributes(e) {
  return {
          hd: {
            NAME: "Label",
            VAL: String(Curry._1(G.E.label, e))
          },
          tl: /* [] */0
        };
}

function get_subgraph(param) {
  
}

var Display_V = G.V;

var Display_is_directed = G.is_directed;

var Display_is_empty = G.is_empty;

var Display_nb_vertex = G.nb_vertex;

var Display_nb_edges = G.nb_edges;

var Display_out_degree = G.out_degree;

var Display_in_degree = G.in_degree;

var Display_mem_vertex = G.mem_vertex;

var Display_mem_edge = G.mem_edge;

var Display_mem_edge_e = G.mem_edge_e;

var Display_find_edge = G.find_edge;

var Display_find_all_edges = G.find_all_edges;

var Display_succ = G.succ;

var Display_pred = G.pred;

var Display_succ_e = G.succ_e;

var Display_pred_e = G.pred_e;

var Display_fold_vertex = G.fold_vertex;

var Display_iter_edges = G.iter_edges;

var Display_fold_edges = G.fold_edges;

var Display_fold_edges_e = G.fold_edges_e;

var Display_map_vertex = G.map_vertex;

var Display_iter_succ = G.iter_succ;

var Display_iter_pred = G.iter_pred;

var Display_fold_succ = G.fold_succ;

var Display_fold_pred = G.fold_pred;

var Display_iter_succ_e = G.iter_succ_e;

var Display_fold_succ_e = G.fold_succ_e;

var Display_iter_pred_e = G.iter_pred_e;

var Display_fold_pred_e = G.fold_pred_e;

var Display_create = G.create;

var Display_clear = G.clear;

var Display_copy = G.copy;

var Display_add_vertex = G.add_vertex;

var Display_remove_vertex = G.remove_vertex;

var Display_add_edge = G.add_edge;

var Display_add_edge_e = G.add_edge_e;

var Display_remove_edge = G.remove_edge;

var Display_remove_edge_e = G.remove_edge_e;

var Display = {
  V: Display_V,
  E: E$1,
  is_directed: Display_is_directed,
  is_empty: Display_is_empty,
  nb_vertex: Display_nb_vertex,
  nb_edges: Display_nb_edges,
  out_degree: Display_out_degree,
  in_degree: Display_in_degree,
  mem_vertex: Display_mem_vertex,
  mem_edge: Display_mem_edge,
  mem_edge_e: Display_mem_edge_e,
  find_edge: Display_find_edge,
  find_all_edges: Display_find_all_edges,
  succ: Display_succ,
  pred: Display_pred,
  succ_e: Display_succ_e,
  pred_e: Display_pred_e,
  iter_vertex: iter_vertex,
  fold_vertex: Display_fold_vertex,
  iter_edges: Display_iter_edges,
  fold_edges: Display_fold_edges,
  iter_edges_e: iter_edges_e,
  fold_edges_e: Display_fold_edges_e,
  map_vertex: Display_map_vertex,
  iter_succ: Display_iter_succ,
  iter_pred: Display_iter_pred,
  fold_succ: Display_fold_succ,
  fold_pred: Display_fold_pred,
  iter_succ_e: Display_iter_succ_e,
  fold_succ_e: Display_fold_succ_e,
  iter_pred_e: Display_iter_pred_e,
  fold_pred_e: Display_fold_pred_e,
  create: Display_create,
  clear: Display_clear,
  copy: Display_copy,
  add_vertex: Display_add_vertex,
  remove_vertex: Display_remove_vertex,
  add_edge: Display_add_edge,
  add_edge_e: Display_add_edge_e,
  remove_edge: Display_remove_edge,
  remove_edge_e: Display_remove_edge_e,
  vertex_name: vertex_name,
  graph_attributes: graph_attributes,
  default_vertex_attributes: default_vertex_attributes,
  vertex_attributes: vertex_attributes,
  default_edge_attributes: default_edge_attributes,
  edge_attributes: edge_attributes,
  get_subgraph: get_subgraph
};

var Gv = Graphviz$Graph.Dot({
      V: {},
      E: {
        src: E$1.src,
        dst: E$1.dst
      },
      iter_vertex: iter_vertex,
      iter_edges_e: iter_edges_e,
      graph_attributes: graph_attributes,
      default_vertex_attributes: default_vertex_attributes,
      vertex_name: vertex_name,
      vertex_attributes: vertex_attributes,
      get_subgraph: get_subgraph,
      default_edge_attributes: default_edge_attributes,
      edge_attributes: edge_attributes
    });

function output(g) {
  Curry._2(Gv.fprint_graph, Format.str_formatter, g);
  return Format.flush_str_formatter(undefined);
}

var Cave = {
  E: E,
  V: V,
  G: G,
  adjCoords: adjCoords,
  getAdjacents: getAdjacents,
  make: make,
  Display: Display,
  Gv: Gv,
  output: output
};

function parse(data) {
  return Belt_Array.map(Utils$AdventOfCode.splitNewline(data), (function (l) {
                return Belt_Array.map(Utils$AdventOfCode.splitChars(l.trim()), (function (c) {
                              return Belt_Option.getExn(Belt_Int.fromString(c));
                            }));
              }));
}

function solvePart1(data) {
  var cave = make(parse(data));
  console.log(output(cave));
  return 1;
}

function solvePart2(data) {
  return 2;
}

export {
  log ,
  log2 ,
  Cave ,
  parse ,
  solvePart1 ,
  solvePart2 ,
  
}
/* G Not a pure module */
