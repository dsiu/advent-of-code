// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Graph from "@dsiu/rescript-graphology/src/Graph.mjs";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Utils$AdventOfCode from "../../Utils.mjs";
import * as Array2D$AdventOfCode from "../../Array2D.mjs";
import * as Coordinate$AdventOfCode from "../../Coordinate.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function adjCoords(c) {
  return Belt_List.map({
              hd: Coordinate$AdventOfCode.StepFunctions.stepN,
              tl: {
                hd: Coordinate$AdventOfCode.StepFunctions.stepW,
                tl: {
                  hd: Coordinate$AdventOfCode.StepFunctions.stepE,
                  tl: {
                    hd: Coordinate$AdventOfCode.StepFunctions.stepS,
                    tl: /* [] */0
                  }
                }
              }
            }, (function (f) {
                return f(c);
              }));
}

function getAdjacents(t, param) {
  return Belt_List.keepMapU(adjCoords([
                  param[0],
                  param[1]
                ]), (function (c) {
                if (Array2D$AdventOfCode.isValidXY(t, c)) {
                  return {
                          TAG: "CoordAndVal",
                          _0: c,
                          _1: Array2D$AdventOfCode.getExn(t, c)
                        };
                }
                
              }));
}

var G = Graph.MakeGraph({});

function makeNodes(g, lines) {
  return Array2D$AdventOfCode.mapWithIndexU(lines, (function (c, param) {
                G.addNode(g, c, undefined, undefined);
                return c;
              }));
}

function node(nodes, x, y) {
  return Array2D$AdventOfCode.getExn(nodes, [
              x,
              y
            ]);
}

function make(lines) {
  var g = G.makeDirectedGraph();
  var nodes = makeNodes(g, lines);
  var g$1 = Array2D$AdventOfCode.reduceWithIndexU(lines, g, (function (g, _e, c) {
          var v = node(nodes, c[0], c[1]);
          Belt_List.forEach(getAdjacents(lines, c), (function (param) {
                  var match = param._0;
                  var v$p = node(nodes, match[0], match[1]);
                  G.addEdge(g, v, v$p, {
                        weight: param._1
                      }, undefined);
                }));
          return g;
        }));
  return {
          nodes: nodes,
          g: g$1
        };
}

function solve(param) {
  var g = param.g;
  var nodes = param.nodes;
  var dest_x = Array2D$AdventOfCode.lengthX(nodes) - 1 | 0;
  var dest_y = Array2D$AdventOfCode.lengthY(nodes) - 1 | 0;
  var path = G.ShortestPath.Dijkstra.bidirectional(g, node(nodes, 0, 0), node(nodes, dest_x, dest_y), {
        NAME: "Attr",
        VAL: "weight"
      });
  var edges = G.ShortestPath.Utils.edgePathFromNodePath(g, path);
  return Belt_Array.reduce(edges, 0, (function (acc, e) {
                return acc + G.getEdgeAttribute(g, e, "weight") | 0;
              }));
}

function expand(map_orig, x_times, y_times) {
  var sz_x_orig = Array2D$AdventOfCode.lengthX(map_orig);
  var sz_y_orig = Array2D$AdventOfCode.lengthY(map_orig);
  var sz_x_final = Math.imul(sz_x_orig, x_times);
  var sz_y_final = Math.imul(sz_y_orig, y_times);
  var map = Array2D$AdventOfCode.make([
        sz_x_final,
        sz_y_final
      ], 0);
  for(var x_ep = 0; x_ep < x_times; ++x_ep){
    (function(x_ep){
    for(var y_ep = 0; y_ep < y_times; ++y_ep){
      Array2D$AdventOfCode.reduceWithIndex(map_orig, 0, (function(y_ep){
          return function (_a, e, param) {
            var x_new = param[0] + Math.imul(x_ep, sz_x_orig) | 0;
            var y_new = param[1] + Math.imul(y_ep, sz_y_orig) | 0;
            var e$p = ((e + x_ep | 0) + y_ep | 0) % 9;
            var e_new = e$p === 0 ? 9 : e$p;
            Array2D$AdventOfCode.set(map, [
                  x_new,
                  y_new
                ], e_new);
            return 0;
          }
          }(y_ep)));
    }
    }(x_ep));
  }
  return map;
}

var Cave = {
  adjCoords: adjCoords,
  getAdjacents: getAdjacents,
  G: G,
  makeNodes: makeNodes,
  node: node,
  make: make,
  solve: solve,
  expand: expand
};

function parse(data) {
  return Belt_Array.map(Utils$AdventOfCode.splitNewline(data), (function (l) {
                return Belt_Array.map(Utils$AdventOfCode.splitChars(l.trim()), Utils$AdventOfCode.intFromStringExn);
              }));
}

function solvePart1(data) {
  var cave = make(parse(data));
  return solve(cave);
}

function solvePart2(data) {
  var new_cave = expand(parse(data), 5, 5);
  var cave = make(new_cave);
  return solve(cave);
}

export {
  log ,
  log2 ,
  Cave ,
  parse ,
  solvePart1 ,
  solvePart2 ,
}
/* G Not a pure module */
