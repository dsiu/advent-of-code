// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_List from "rescript/lib/es6/Belt_List.js";
import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Graphology__Graph from "@dsiu/rescript-graphology/src/Graphology__Graph.mjs";
import * as Utils$AdventOfCode from "../../Utils.mjs";
import * as Array2D$AdventOfCode from "../../Array2D.mjs";
import * as Coordinate$AdventOfCode from "../../Coordinate.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function adjCoords(c) {
  return Belt_List.map({
    hd: Coordinate$AdventOfCode.StepFunctions.stepN,
    tl: {
      hd: Coordinate$AdventOfCode.StepFunctions.stepW,
      tl: {
        hd: Coordinate$AdventOfCode.StepFunctions.stepE,
        tl: {
          hd: Coordinate$AdventOfCode.StepFunctions.stepS,
          tl: /* [] */0
        }
      }
    }
  }, f => f(c));
}

function getAdjacents(t, param) {
  return Belt_List.keepMap(adjCoords([
    param[0],
    param[1]
  ]), c => {
    if (Array2D$AdventOfCode.isValidXY(t, c)) {
      return {
        TAG: "CoordAndVal",
        _0: c,
        _1: Array2D$AdventOfCode.getExn(t, c)
      };
    }
    
  });
}

let G = Graphology__Graph.MakeGraph({});

function makeNodes(g, lines) {
  return Array2D$AdventOfCode.mapWithIndex(lines, (c, param) => {
    G.addNode(g, c, undefined);
    return c;
  });
}

function node(nodes, x, y) {
  return Array2D$AdventOfCode.getExn(nodes, [
    x,
    y
  ]);
}

function make(lines) {
  let g = G.makeDirectedGraph();
  let nodes = makeNodes(g, lines);
  let g$1 = Array2D$AdventOfCode.reduceWithIndex(lines, g, (g, _e, c) => {
    let v = node(nodes, c[0], c[1]);
    Belt_List.forEach(getAdjacents(lines, c), param => {
      let match = param._0;
      let v$p = node(nodes, match[0], match[1]);
      G.addEdge(g, v, v$p, {
        weight: param._1
      });
    });
    return g;
  });
  return {
    nodes: nodes,
    g: g$1
  };
}

function solve(param) {
  let g = param.g;
  let nodes = param.nodes;
  let dest_x = Array2D$AdventOfCode.lengthX(nodes) - 1 | 0;
  let dest_y = Array2D$AdventOfCode.lengthY(nodes) - 1 | 0;
  let path = G.ShortestPath.Dijkstra.bidirectional(g, node(nodes, 0, 0), node(nodes, dest_x, dest_y), {
    NAME: "Attr",
    VAL: "weight"
  });
  let edges = G.ShortestPath.Utils.edgePathFromNodePath(g, path);
  return Belt_Array.reduce(edges, 0, (acc, e) => acc + G.getEdgeAttribute(g, e, "weight") | 0);
}

function expand(map_orig, x_times, y_times) {
  let sz_x_orig = Array2D$AdventOfCode.lengthX(map_orig);
  let sz_y_orig = Array2D$AdventOfCode.lengthY(map_orig);
  let sz_x_final = Math.imul(sz_x_orig, x_times);
  let sz_y_final = Math.imul(sz_y_orig, y_times);
  let map = Array2D$AdventOfCode.make([
    sz_x_final,
    sz_y_final
  ], 0);
  for (let x_ep = 0; x_ep < x_times; ++x_ep) {
    for (let y_ep = 0; y_ep < y_times; ++y_ep) {
      Array2D$AdventOfCode.reduceWithIndex(map_orig, 0, (_a, e, param) => {
        let x_new = param[0] + Math.imul(x_ep, sz_x_orig) | 0;
        let y_new = param[1] + Math.imul(y_ep, sz_y_orig) | 0;
        let e$p = ((e + x_ep | 0) + y_ep | 0) % 9;
        let e_new = e$p === 0 ? 9 : e$p;
        Array2D$AdventOfCode.set(map, [
          x_new,
          y_new
        ], e_new);
        return 0;
      });
    }
  }
  return map;
}

let Cave = {
  adjCoords: adjCoords,
  getAdjacents: getAdjacents,
  G: G,
  makeNodes: makeNodes,
  node: node,
  make: make,
  solve: solve,
  expand: expand
};

function parse(data) {
  return Belt_Array.map(Utils$AdventOfCode.splitNewline(data), l => Belt_Array.map(Utils$AdventOfCode.splitChars(l.trim()), Utils$AdventOfCode.intFromStringExn));
}

function solvePart1(data) {
  return solve(make(parse(data)));
}

function solvePart2(data) {
  let new_cave = expand(parse(data), 5, 5);
  return solve(make(new_cave));
}

export {
  log,
  log2,
  Cave,
  parse,
  solvePart1,
  solvePart2,
}
/* G Not a pure module */
