// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Pervasives from "rescript/lib/es6/pervasives.js";

function toString(t) {
  return "Interval(" + t.lower.toString() + ", " + t.upper.toString() + ")";
}

function makeWithBounds(lower, upper) {
  if (Caml_obj.greaterthan(lower, upper)) {
    Pervasives.failwith("lower bound must be less than or equal to upper bound");
  }
  return {
          lower: lower,
          upper: upper
        };
}

function makeWithLength(lower, length) {
  if (Caml_obj.lessthan(length, BigInt(0))) {
    Pervasives.failwith("length must be non-negative");
  }
  var upper = lower + length - BigInt(1);
  return makeWithBounds(lower, upper);
}

function belowNotConnected(a, b) {
  return Caml_obj.lessthan(a.upper + BigInt(1), b.lower);
}

function merge(a, b) {
  if (belowNotConnected(a, b)) {
    return Pervasives.failwith("intervals must be all below and not connected");
  }
  var lower = Caml_obj.min(a.lower, b.lower);
  var upper = Caml_obj.max(a.upper, b.upper);
  return makeWithBounds(lower, upper);
}

function inInterval(t, num) {
  if (Caml_obj.greaterequal(num, t.lower)) {
    return Caml_obj.lessequal(num, t.upper);
  } else {
    return false;
  }
}

function sort(intervals) {
  var lowerBoundAscendingCmp = function (a, b) {
    var match = a.lower;
    var match$1 = b.lower;
    var match$2 = a.upper;
    var match$3 = b.upper;
    if (Caml_obj.lessthan(match, match$1)) {
      return -1;
    } else if (Caml_obj.greaterthan(match, match$1)) {
      return 1;
    } else if (Caml_obj.lessthan(match$2, match$3)) {
      return -1;
    } else if (Caml_obj.greaterthan(match$2, match$3)) {
      return 1;
    } else {
      return 0;
    }
  };
  return intervals.toSorted(lowerBoundAscendingCmp);
}

function sortAndMergeOverlaps(intervals) {
  var sortedIntervals = sort(intervals);
  var loop = function (_sortedIntervals) {
    while(true) {
      var sortedIntervals = _sortedIntervals;
      var len = sortedIntervals.length;
      if (len === 1) {
        return [sortedIntervals[0]];
      }
      if (len === 0) {
        return [];
      }
      var a = sortedIntervals[0];
      var b = sortedIntervals[1];
      if (belowNotConnected(a, b)) {
        return [a].concat(loop(sortedIntervals.slice(1)));
      }
      _sortedIntervals = [merge(a, b)].concat(sortedIntervals.slice(2));
      continue ;
    };
  };
  return loop(sortedIntervals);
}

export {
  toString ,
  makeWithBounds ,
  makeWithLength ,
  belowNotConnected ,
  merge ,
  inInterval ,
  sort ,
  sortAndMergeOverlaps ,
}
/* No side effect */
