// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Pervasives from "rescript/lib/es6/pervasives.js";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function toString(param) {
  return "Interval(" + param[0].toString() + ", " + param[1].toString() + ")";
}

function make(lower, upper) {
  if (Caml_obj.greaterthan(lower, upper)) {
    return [
            upper,
            lower
          ];
  } else {
    return [
            lower,
            upper
          ];
  }
}

function makeWithLength(lower, length) {
  if (Caml_obj.lessthan(length, BigInt(0))) {
    Pervasives.failwith("length must be non-negative");
  }
  var upper = lower + length - BigInt(1);
  return make(lower, upper);
}

function length(param) {
  var upper = param[1];
  var lower = param[0];
  if (Caml_obj.greaterthan(upper, lower)) {
    return upper - lower + BigInt(1);
  } else {
    return lower - upper + BigInt(1);
  }
}

function contains(param, num) {
  if (Caml_obj.greaterequal(num, param[0])) {
    return Caml_obj.lessequal(num, param[1]);
  } else {
    return false;
  }
}

function isOverlap(a, b) {
  if (contains(a, b[0])) {
    return true;
  } else {
    return contains(a, b[1]);
  }
}

function intersect(a, b) {
  if (isOverlap(a, b)) {
    return make(Caml_obj.max(a[0], b[0]), Caml_obj.min(a[1], b[1]));
  }
  
}

function below(a, b) {
  return Caml_obj.lessthan(a[1], b[0]);
}

function adjacent(a, b) {
  if (Caml_obj.equal(a[1] + BigInt(1), b[0])) {
    return true;
  } else {
    return Caml_obj.equal(b[1] + BigInt(1), a[0]);
  }
}

function belowAndAdjacent(a, b) {
  if (below(a, b)) {
    return adjacent(a, b);
  } else {
    return false;
  }
}

function merge(a, b) {
  console.log("a=", a);
  console.log("b=", b);
  var prim1 = adjacent(a, b);
  console.log("adjacent=", prim1);
  var prim1$1 = isOverlap(a, b);
  console.log("overlap=", prim1$1);
  if (!(adjacent(a, b) || isOverlap(a, b))) {
    return Pervasives.failwith("intervals must be adjacent or overlapping");
  }
  var lower = Caml_obj.min(a[0], b[0]);
  var upper = Caml_obj.max(a[1], b[1]);
  return make(lower, upper);
}

function sort(intervals) {
  var lowerBoundAscendingCmp = function (param, param$1) {
    var bUpper = param$1[1];
    var bLower = param$1[0];
    var aUpper = param[1];
    var aLower = param[0];
    if (Caml_obj.lessthan(aLower, bLower)) {
      return -1;
    } else if (Caml_obj.greaterthan(aLower, bLower)) {
      return 1;
    } else if (Caml_obj.lessthan(aUpper, bUpper)) {
      return -1;
    } else if (Caml_obj.greaterthan(aUpper, bUpper)) {
      return 1;
    } else {
      return 0;
    }
  };
  return intervals.toSorted(lowerBoundAscendingCmp);
}

function sortAndMergeOverlaps(intervals) {
  var sortedIntervals = sort(intervals);
  var loop = function (_sortedIntervals) {
    while(true) {
      var sortedIntervals = _sortedIntervals;
      var len = sortedIntervals.length;
      if (len === 1) {
        return [sortedIntervals[0]];
      }
      if (len === 0) {
        return [];
      }
      var a = sortedIntervals[0];
      var b = sortedIntervals[1];
      if (below(a, b) && !adjacent(a, b)) {
        return [a].concat(loop(sortedIntervals.slice(1)));
      }
      _sortedIntervals = [merge(a, b)].concat(sortedIntervals.slice(2));
      continue ;
    };
  };
  return loop(sortedIntervals);
}

export {
  log ,
  log2 ,
  toString ,
  make ,
  makeWithLength ,
  length ,
  contains ,
  isOverlap ,
  intersect ,
  below ,
  adjacent ,
  belowAndAdjacent ,
  merge ,
  sort ,
  sortAndMergeOverlaps ,
}
/* No side effect */
