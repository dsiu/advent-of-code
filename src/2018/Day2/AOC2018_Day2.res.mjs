// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Option from "rescript/lib/es6/Option.js";
import * as Js_string from "rescript/lib/es6/Js_string.js";
import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Belt_MapString from "rescript/lib/es6/Belt_MapString.js";
import * as AOC2018_Day2_Data from "./AOC2018_Day2_Data.res.mjs";

function string_to_charStr(__x) {
  return Js_string.split("", __x);
}

function reducer(r, x) {
  let count = Belt_MapString.get(r, x);
  if (count !== undefined) {
    return Belt_MapString.set(r, x, count + 1 | 0);
  } else {
    return Belt_MapString.set(r, x, 1);
  }
}

function char_freq(cs) {
  return Belt_Array.reduce(cs, undefined, reducer);
}

function countMatchFreq(freq, m) {
  return Belt_MapString.reduce(m, 0, (acc, _key, v) => {
    if (v === freq) {
      return acc + 1 | 0;
    } else {
      return acc;
    }
  });
}

function n_char_matched_freq(freq, s) {
  let cs = Js_string.split("", s);
  return countMatchFreq(freq, Belt_Array.reduce(cs, undefined, reducer));
}

function twoTimesCounter(extra) {
  return n_char_matched_freq(2, extra);
}

function threeTimesCounter(extra) {
  return n_char_matched_freq(3, extra);
}

function nonZero(x) {
  if (x !== 0) {
    return 1;
  } else {
    return 0;
  }
}

function runDay2Part1(lines) {
  let result = Belt_Array.reduce(lines, {
    twoTimes: 0,
    threeTimes: 0
  }, (acc, l) => ({
    twoTimes: acc.twoTimes + nonZero(n_char_matched_freq(2, l)) | 0,
    threeTimes: acc.threeTimes + nonZero(n_char_matched_freq(3, l)) | 0
  }));
  return Math.imul(result.twoTimes, result.threeTimes);
}

function diffOfTwoCharStr(s1, s2) {
  let s1CharStr = Js_string.split("", s1);
  let s2CharStr = Js_string.split("", s2);
  return Belt_Array.mapWithIndex(s1CharStr, (i, x) => {
    let y = Belt_Array.get(s2CharStr, i);
    if (y !== undefined) {
      if (x === y) {
        return {
          TAG: "Match",
          _0: x
        };
      } else {
        return {
          TAG: "NotMatch",
          _0: x,
          _1: y
        };
      }
    } else {
      return {
        TAG: "NotMatch",
        _0: x,
        _1: x
      };
    }
  });
}

function countTrue(xs) {
  return Belt_Array.keep(xs, x => x.TAG === "Match").length;
}

function countFalse(xs) {
  return Belt_Array.keep(xs, x => x.TAG !== "Match").length;
}

function isDiffBy(n, xs) {
  return countFalse(xs) === n;
}

function isDiffBy1(extra) {
  return countFalse(extra) === 1;
}

function isDiffBy5(extra) {
  return countFalse(extra) === 5;
}

function findMatch(lines, predicate, x) {
  return Belt_Array.reduce(lines, {
    src: x,
    matched: []
  }, (a, y) => {
    let match = predicate(diffOfTwoCharStr(a.src, y));
    return {
      src: a.src,
      matched: match ? Belt_Array.concat(a.matched, [y]) : a.matched
    };
  });
}

function findAllMatch(predicate, lines) {
  return Belt_Array.keepMap(lines, x => {
    let res = findMatch(lines, predicate, x);
    let match = res.matched.length;
    if (match !== 0) {
      return res;
    }
    
  });
}

function runDay2Part2(lines) {
  return Belt_Array.map(findAllMatch(isDiffBy1, lines), x => Belt_Array.keepMap(diffOfTwoCharStr(x.src, Option.getExn(x.matched[0], undefined)), x => {
    if (x.TAG === "Match") {
      return x._0;
    }
    
  }).join(""));
}

let data = AOC2018_Day2_Data.data;

let test_string = "aabbbccccccddddd";

export {
  data,
  string_to_charStr,
  reducer,
  char_freq,
  countMatchFreq,
  n_char_matched_freq,
  twoTimesCounter,
  threeTimesCounter,
  nonZero,
  runDay2Part1,
  test_string,
  diffOfTwoCharStr,
  countTrue,
  countFalse,
  isDiffBy,
  isDiffBy1,
  isDiffBy5,
  findMatch,
  findAllMatch,
  runDay2Part2,
}
/* No side effect */
