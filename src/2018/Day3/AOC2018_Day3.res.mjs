// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Int from "rescript/lib/es6/Belt_Int.js";
import * as Js_array from "rescript/lib/es6/Js_array.js";
import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Belt_MapInt from "rescript/lib/es6/Belt_MapInt.js";
import * as Belt_Option from "rescript/lib/es6/Belt_Option.js";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";
import * as AOC2018_Day3_Data from "./AOC2018_Day3_Data.res.mjs";
import * as Belt_MutableMapInt from "rescript/lib/es6/Belt_MutableMapInt.js";

function id(t) {
  return t.id;
}

function x(t) {
  return t.x;
}

function y(t) {
  return t.y;
}

function w(t) {
  return t.w;
}

function h(t) {
  return t.h;
}

function maxX(t) {
  return t.x + t.w | 0;
}

function maxY(t) {
  return t.y + t.h | 0;
}

let claimRe = /#(\d+)\s+@\s+(\d+),(\d+):\s(\d+)x(\d+)/i;

function parseLine(s) {
  let __x = s.trim();
  let x = Primitive_option.fromNull(claimRe.exec(__x));
  if (x !== undefined) {
    return Belt_Array.map(Primitive_option.valFromOption(x), x => Belt_Option.getExn((x == null) ? undefined : Primitive_option.some(x)));
  } else {
    return [];
  }
}

function make(id, x, y, w, h) {
  return {
    id: id,
    x: x,
    y: y,
    w: w,
    h: h
  };
}

function makeClaim(l) {
  let xs = parseLine(l);
  return make(Belt_Option.getExn(Belt_Int.fromString(Belt_Array.getExn(xs, 1))), Belt_Option.getExn(Belt_Int.fromString(Belt_Array.getExn(xs, 2))), Belt_Option.getExn(Belt_Int.fromString(Belt_Array.getExn(xs, 3))), Belt_Option.getExn(Belt_Int.fromString(Belt_Array.getExn(xs, 4))), Belt_Option.getExn(Belt_Int.fromString(Belt_Array.getExn(xs, 5))));
}

let Claim = {
  id: id,
  x: x,
  y: y,
  w: w,
  h: h,
  maxX: maxX,
  maxY: maxY,
  parseLine: parseLine,
  make: make,
  makeClaim: makeClaim
};

function findMax(t, f) {
  return Belt_Array.reduce(t, 0, (acc, x) => {
    if (f(x) > acc) {
      return f(x);
    } else {
      return acc;
    }
  });
}

function findMaxX(t) {
  return findMax(t, maxX);
}

function findMaxY(t) {
  return findMax(t, maxY);
}

function make$1(lines) {
  return Js_array.map(makeClaim, lines);
}

let Claims = {
  findMax: findMax,
  findMaxX: findMaxX,
  findMaxY: findMaxY,
  make: make$1
};

function w$1(t) {
  return t.w;
}

function h$1(t) {
  return t.h;
}

function matrix(t) {
  return t.matrix;
}

function make$2(w, h) {
  return {
    w: w,
    h: h,
    matrix: Belt_Array.reduce(Belt_Array.range(0, w), undefined, (acc, i) => Belt_MapInt.set(acc, i, Belt_MutableMapInt.make()))
  };
}

function toString(t) {
  Belt_MapInt.forEach(t.matrix, (x, col) => Belt_MutableMapInt.forEach(col, (y, vs) => {
    console.log("x:" + String(x) + " y:" + String(y));
    Belt_Array.forEach(vs, v => {
      console.log("  " + String(v));
    });
  }));
}

function twoOrMore(x) {
  return x >= 2;
}

function oneOrMore(x) {
  return x >= 1;
}

function isOne(x) {
  return x === 1;
}

function addPoint(t, x, y, p) {
  Belt_MutableMapInt.update(Belt_MapInt.getExn(t.matrix, x), y, a => {
    if (a !== undefined) {
      return Belt_Array.concat(a, [p]);
    } else {
      return [p];
    }
  });
  return t;
}

function getPoint(t, x, y) {
  return Belt_MutableMapInt.get(Belt_Option.getExn(Belt_MapInt.get(t.matrix, x)), y);
}

function fill(t, f) {
  return Belt_Array.reduce(Belt_Array.range(0, t.w), t, (_acc, x) => Belt_Array.reduce(Belt_Array.range(0, t.h), t, (acc, y) => addPoint(acc, x, y, f(x, y))));
}

function claimAreaIter(c, t, f) {
  return Belt_Array.reduce(Belt_Array.range(c.x, (c.x + c.w | 0) - 1 | 0), t, (_acc, x) => Belt_Array.reduce(Belt_Array.range(c.y, (c.y + c.h | 0) - 1 | 0), t, (acc, y) => f(acc, x, y, c)));
}

function addClaimIdToPoint(t, x, y, c) {
  return addPoint(t, x, y, c.id);
}

function addClaim(t, c) {
  return claimAreaIter(c, t, addClaimIdToPoint);
}

function getClaimIdFromPointIf(t, _c, x, y, _c$1) {
  let point = getPoint(t, x, y);
  let len = Belt_Option.getExn(point).length;
  if (len === 1) {
    return Primitive_option.some(point);
  }
  
}

function getClaimIdsFromArea(t, c) {
  let cids = Belt_Array.concatMany(Belt_Array.reduce(Belt_Array.range(c.x, (c.x + c.w | 0) - 1 | 0), [], (accX, x) => Belt_Array.concat(accX, Belt_Array.reduce(Belt_Array.range(c.y, (c.y + c.h | 0) - 1 | 0), [], (accY, y) => {
    let p = getPoint(t, x, y);
    if (p !== undefined) {
      return Belt_Array.concat(accY, [p]);
    } else {
      return accY;
    }
  }))));
  if (Math.imul(c.w, c.h) === cids.length) {
    return Primitive_option.some(Belt_Array.get(cids, 0));
  }
  
}

function countNonOverlapClaim(t, xs) {
  let reducer = (extra, extra$1) => {
    let cid = getClaimIdsFromArea(t, extra$1);
    if (cid !== undefined) {
      return Belt_Array.concat(extra, [Primitive_option.valFromOption(cid)]);
    } else {
      return extra;
    }
  };
  return Belt_Array.reduce(xs, [], reducer);
}

function countOverlap(t, p) {
  return Belt_MapInt.reduce(t.matrix, 0, (acc, _x, col) => acc + Belt_MutableMapInt.reduce(col, 0, (acc, _y, vs) => {
    if (p(vs.length)) {
      return acc + 1 | 0;
    } else {
      return acc;
    }
  }) | 0);
}

let Fabric = {
  w: w$1,
  h: h$1,
  matrix: matrix,
  make: make$2,
  toString: toString,
  twoOrMore: twoOrMore,
  oneOrMore: oneOrMore,
  isOne: isOne,
  addPoint: addPoint,
  getPoint: getPoint,
  fill: fill,
  claimAreaIter: claimAreaIter,
  addClaimIdToPoint: addClaimIdToPoint,
  addClaim: addClaim,
  getClaimIdFromPointIf: getClaimIdFromPointIf,
  getClaimIdsFromArea: getClaimIdsFromArea,
  countNonOverlapClaim: countNonOverlapClaim,
  countOverlap: countOverlap
};

function solvePart1() {
  let allClaims = Js_array.map(makeClaim, AOC2018_Day3_Data.data.split("\n"));
  let fab = make$2(findMax(allClaims, maxX), findMax(allClaims, maxY));
  let fab$1 = Belt_Array.reduce(allClaims, fab, (acc, i) => claimAreaIter(i, acc, addClaimIdToPoint));
  return countOverlap(fab$1, twoOrMore);
}

function solvePart2() {
  let allClaims = Js_array.map(makeClaim, AOC2018_Day3_Data.data.split("\n"));
  let fab = make$2(findMax(allClaims, maxX), findMax(allClaims, maxY));
  let fab$1 = Belt_Array.reduce(allClaims, fab, (acc, i) => claimAreaIter(i, acc, addClaimIdToPoint));
  return countNonOverlapClaim(fab$1, allClaims);
}

let allClaims = Js_array.map(makeClaim, [
  "#3 @ 1,3: 4x4",
  "#7 @ 3,1: 4x4",
  "#11 @ 5,5: 2x2"
]);

let w$2 = findMax(allClaims, maxX);

let h$2 = findMax(allClaims, maxY);

let test_fab = make$2(w$2, h$2);

let test_fab$1 = Belt_Array.reduce(allClaims, test_fab, (acc, i) => claimAreaIter(i, acc, addClaimIdToPoint));

let solvePart2Demo = undefined === (countNonOverlapClaim(test_fab$1, allClaims), undefined);

let data = AOC2018_Day3_Data.data;

export {
  data,
  Claim,
  Claims,
  Fabric,
  solvePart1,
  solvePart2,
  solvePart2Demo,
}
/* solvePart2Demo Not a pure module */
