// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_MapInt = require("bs-platform/lib/js/belt_MapInt.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Belt_MutableMapInt = require("bs-platform/lib/js/belt_MutableMapInt.js");
var Day3_Data$AdventOfCode = require("./Day3_Data.bs.js");

function id(t) {
  return t.id;
}

function x(t) {
  return t.x;
}

function y(t) {
  return t.y;
}

function w(t) {
  return t.w;
}

function h(t) {
  return t.h;
}

function maxX(t) {
  return t.x + t.w | 0;
}

function maxY(t) {
  return t.y + t.h | 0;
}

var claimRe = /#(\d+)\s+@\s+(\d+),(\d+):\s(\d+)x(\d+)/i;

function parseLine(s) {
  var x = claimRe.exec(s.trim());
  if (x !== null) {
    return Belt_Array.map(x, (function (x) {
                  return Belt_Option.getExn((x == null) ? undefined : Caml_option.some(x));
                }));
  } else {
    return [];
  }
}

function make(id, x, y, w, h) {
  return {
          id: id,
          x: x,
          y: y,
          w: w,
          h: h
        };
}

function makeClaim(l) {
  var xs = parseLine(l);
  return make(Caml_format.caml_int_of_string(Belt_Option.getExn(Belt_Array.get(xs, 1))), Caml_format.caml_int_of_string(Belt_Option.getExn(Belt_Array.get(xs, 2))), Caml_format.caml_int_of_string(Belt_Option.getExn(Belt_Array.get(xs, 3))), Caml_format.caml_int_of_string(Belt_Option.getExn(Belt_Array.get(xs, 4))), Caml_format.caml_int_of_string(Belt_Option.getExn(Belt_Array.get(xs, 5))));
}

var Claim = {
  id: id,
  x: x,
  y: y,
  w: w,
  h: h,
  maxX: maxX,
  maxY: maxY,
  parseLine: parseLine,
  make: make,
  makeClaim: makeClaim
};

function findMax(t, f) {
  return Belt_Array.reduce(t, 0, (function (acc, x) {
                if (Curry._1(f, x) > acc) {
                  return Curry._1(f, x);
                } else {
                  return acc;
                }
              }));
}

function findMaxX(t) {
  return findMax(t, maxX);
}

function findMaxY(t) {
  return findMax(t, maxY);
}

function make$1(lines) {
  return lines.map(makeClaim);
}

var Claims = {
  findMax: findMax,
  findMaxX: findMaxX,
  findMaxY: findMaxY,
  make: make$1
};

function w$1(t) {
  return t.w;
}

function h$1(t) {
  return t.h;
}

function matrix(t) {
  return t.matrix;
}

function make$2(w, h) {
  return {
          w: w,
          h: h,
          matrix: Belt_Array.reduce(Belt_Array.range(0, w), undefined, (function (acc, i) {
                  return Belt_MapInt.set(acc, i, Belt_MutableMapInt.make(undefined));
                }))
        };
}

function dump(t) {
  return Belt_MapInt.forEach(t.matrix, (function (x, col) {
                return Belt_MutableMapInt.forEach(col, (function (y, vs) {
                              console.log("x:" + String(x) + " y:" + String(y));
                              return Belt_Array.forEach(vs, (function (v) {
                                            console.log("  " + String(v));
                                            
                                          }));
                            }));
              }));
}

function addPoint(t, x, y, p) {
  Belt_MutableMapInt.update(Belt_Option.getExn(Belt_MapInt.get(t.matrix, x)), y, (function (a) {
          if (a !== undefined) {
            return Belt_Array.concat(a, [p]);
          } else {
            return [p];
          }
        }));
  return t;
}

function getPoint(t, x, y) {
  return Belt_MutableMapInt.get(Belt_Option.getExn(Belt_MapInt.get(t.matrix, x)), y);
}

function fill(t, f) {
  return Belt_Array.reduce(Belt_Array.range(0, t.w), t, (function (acc, x) {
                return Belt_Array.reduce(Belt_Array.range(0, t.h), t, (function (acc, y) {
                              return addPoint(acc, x, y, Curry._2(f, x, y));
                            }));
              }));
}

function addClaim(t, c) {
  return Belt_Array.reduce(Belt_Array.range(c.x, (c.x + c.w | 0) - 1 | 0), t, (function (acc, x) {
                return Belt_Array.reduce(Belt_Array.range(c.y, (c.y + c.h | 0) - 1 | 0), t, (function (acc, y) {
                              return addPoint(acc, x, y, c.id);
                            }));
              }));
}

function twoOrMore(x) {
  return x >= 2;
}

function oneOrMore(x) {
  return x >= 1;
}

function countOverlap(t, f) {
  return Belt_MapInt.reduce(t.matrix, 0, (function (acc, x, col) {
                return acc + Belt_MutableMapInt.reduce(col, 0, (function (acc, y, vs) {
                              var len = vs.length;
                              if (Curry._1(f, len)) {
                                return acc + 1 | 0;
                              } else {
                                return acc;
                              }
                            })) | 0;
              }));
}

var Fabric = {
  w: w$1,
  h: h$1,
  matrix: matrix,
  make: make$2,
  dump: dump,
  addPoint: addPoint,
  getPoint: getPoint,
  fill: fill,
  addClaim: addClaim,
  twoOrMore: twoOrMore,
  oneOrMore: oneOrMore,
  countOverlap: countOverlap
};

function solvePart1(param) {
  var lines = Day3_Data$AdventOfCode.data.split("\n");
  var allClaims = lines.map(makeClaim);
  var fab = make$2(findMax(allClaims, maxX), findMax(allClaims, maxY));
  var __x = Belt_Array.reduce(allClaims, fab, addClaim);
  return countOverlap(__x, twoOrMore);
}

var data = Day3_Data$AdventOfCode.data;

exports.data = data;
exports.Claim = Claim;
exports.Claims = Claims;
exports.Fabric = Fabric;
exports.solvePart1 = solvePart1;
/* No side effect */
