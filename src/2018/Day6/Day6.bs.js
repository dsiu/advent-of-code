// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Js_int = require("rescript/lib/js/js_int.js");
var Belt_Int = require("rescript/lib/js/belt_Int.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_MapInt = require("rescript/lib/js/belt_MapInt.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_splice_call = require("rescript/lib/js/caml_splice_call.js");
var Utils$AdventOfCode = require("../Utils.bs.js");
var Day6_Data$AdventOfCode = require("./Day6_Data.bs.js");
var Day6_Data_Test$AdventOfCode = require("./Day6_Data_Test.bs.js");

function log(prim) {
  console.log(prim);
  
}

function x(t) {
  return t.x;
}

function y(t) {
  return t.y;
}

function make(x, y) {
  return {
          x: x,
          y: y
        };
}

function makeFromArray(xs) {
  return {
          x: Belt_Option.getExn(Belt_Array.get(xs, 0)),
          y: Belt_Option.getExn(Belt_Array.get(xs, 1))
        };
}

function findXY(f, init, xs) {
  return Belt_Array.reduce(xs, {
              x: init,
              y: init
            }, (function (a, c) {
                return {
                        x: Curry._2(f, a.x, c.x),
                        y: Curry._2(f, a.y, c.y)
                      };
              }));
}

function maxXY(param) {
  return findXY((function (prim0, prim1) {
                return Math.max(prim0, prim1);
              }), Js_int.min, param);
}

function minXY(param) {
  return findXY((function (prim0, prim1) {
                return Math.min(prim0, prim1);
              }), Js_int.max, param);
}

function dist(a, b) {
  return Math.abs(b.x - a.x | 0) + Math.abs(b.y - a.y | 0) | 0;
}

function parse(l) {
  return makeFromArray(Belt_Array.map(l.trim().split(","), (function (x) {
                    return Belt_Option.getExn(Belt_Int.fromString(x.trim()));
                  })));
}

function parseCoords(__x) {
  return Belt_Array.map(__x, parse);
}

var Coord = {
  x: x,
  y: y,
  make: make,
  makeFromArray: makeFromArray,
  findXY: findXY,
  maxXY: maxXY,
  minXY: minXY,
  dist: dist,
  parse: parse,
  parseCoords: parseCoords
};

function w(t) {
  return t.w;
}

function h(t) {
  return t.h;
}

function grid(t) {
  return t.grid;
}

function distsFromPins(at, pins) {
  return Belt_MapInt.reduce(pins, undefined, (function (a, k, v) {
                return Belt_MapInt.set(a, k, dist(at, v));
              }));
}

function findMinDists(__x) {
  return Belt_MapInt.reduce(__x, Js_int.max, (function (a, k, v) {
                if (v < a) {
                  return v;
                } else {
                  return a;
                }
              }));
}

function keepOnly(value, xs) {
  return Belt_MapInt.keep(xs, (function (k, v) {
                return v === value;
              }));
}

function makeCellShortest(at, pins) {
  console.log(" ");
  var prim = "at " + String(at.x) + "," + String(at.y);
  console.log(prim);
  var dists = distsFromPins(at, pins);
  Utils$AdventOfCode.dump_mapInt_of_int(dists);
  var minDist = findMinDists(dists);
  var prim$1 = "minDist:" + String(minDist);
  console.log(prim$1);
  var onlyMins = keepOnly(minDist, dists);
  console.log("onlyMins: ");
  Utils$AdventOfCode.dump_mapInt_of_int(onlyMins);
  if (Belt_MapInt.size(onlyMins) <= 0) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Day6.res",
            97,
            4
          ],
          Error: new Error()
        };
  }
  var ret = Belt_MapInt.size(onlyMins) > 1 ? -1 : Belt_MapInt.reduce(onlyMins, Js_int.min, (function (a, k, v) {
            return k;
          }));
  console.log(ret);
  return ret;
}

function alloc(t) {
  var filled = Belt_Array.reduce(Belt_Array.range(0, t.w - 1 | 0), undefined, (function (a, x) {
          return Belt_MapInt.set(a, x, Belt_Array.reduce(Belt_Array.range(0, t.h - 1 | 0), undefined, (function (b, y) {
                            return Belt_MapInt.set(b, y, -1);
                          })));
        }));
  return {
          pins: t.pins,
          grid: filled,
          w: t.w,
          h: t.h,
          maxBound: t.maxBound,
          minBound: t.minBound
        };
}

function fill(t) {
  var filled = Belt_MapInt.reduce(t.grid, undefined, (function (a, kx, x) {
          return Belt_MapInt.set(a, kx, Belt_MapInt.reduce(x, undefined, (function (a, ky, y) {
                            return Belt_MapInt.set(a, ky, makeCellShortest({
                                            x: kx,
                                            y: ky
                                          }, t.pins));
                          })));
        }));
  return {
          pins: t.pins,
          grid: filled,
          w: t.w,
          h: t.h,
          maxBound: t.maxBound,
          minBound: t.minBound
        };
}

function make$1(xs) {
  var maxBound = maxXY(xs);
  var minBound = minXY(xs);
  console.log(maxBound);
  console.log(minBound);
  var pinsMap = Belt_Array.reduceWithIndex(xs, undefined, (function (a, x, i) {
          return Belt_MapInt.set(a, i, x);
        }));
  Utils$AdventOfCode.dump_mapInt_of(pinsMap, (function (c) {
          return String(c.x) + " " + String(c.y);
        }));
  return fill(alloc({
                  pins: pinsMap,
                  grid: undefined,
                  w: maxBound.x + 1 | 0,
                  h: maxBound.y + 1 | 0,
                  maxBound: maxBound,
                  minBound: minBound
                }));
}

function countCellWith(value, t) {
  return Belt_MapInt.reduce(t.grid, 0, (function (a, kx, x) {
                return a + Belt_MapInt.size(keepOnly(value, x)) | 0;
              }));
}

function getNonInfPin(t) {
  var minBound = t.minBound;
  var maxBound = t.maxBound;
  return Belt_MapInt.keep(t.pins, (function (k, v) {
                return !(v.x === maxBound.x || v.x === minBound.x || v.y === minBound.y || v.y === minBound.y);
              }));
}

function findLandingAreasOfPins(t) {
  return Belt_MapInt.mapWithKey(t.pins, (function (k, v) {
                return countCellWith(k, t);
              }));
}

function getMaxArea(m) {
  return Belt_MapInt.reduce(m, 0, (function (a, k, v) {
                return Math.max(a, v);
              }));
}

function numToChar(xs) {
  return Belt_Array.map(xs, (function (x) {
                if (x !== -1) {
                  return String.fromCharCode(97 + x | 0);
                } else {
                  return ".";
                }
              }));
}

function dump(t) {
  console.log("dump");
  console.log("x, y, v");
  return Belt_MapInt.forEach(t.grid, (function (kx, vx) {
                Caml_splice_call.spliceApply(console.log, [numToChar(Belt_MapInt.valuesToArray(vx))]);
                
              }));
}

var LandingMap = {
  w: w,
  h: h,
  grid: grid,
  distsFromPins: distsFromPins,
  findMinDists: findMinDists,
  keepOnly: keepOnly,
  makeCellShortest: makeCellShortest,
  alloc: alloc,
  fill: fill,
  make: make$1,
  countCellWith: countCellWith,
  getNonInfPin: getNonInfPin,
  findLandingAreasOfPins: findLandingAreasOfPins,
  getMaxArea: getMaxArea,
  numToChar: numToChar,
  dump: dump
};

function solvePart1(data) {
  var map = make$1(Belt_Array.map(data.split("\n"), parse));
  var areas = findLandingAreasOfPins(map);
  dump(map);
  console.log(" ========= landing areas");
  Utils$AdventOfCode.dump_mapInt_of_int(areas);
  console.log(" ======== target pins");
  var targetPins = getNonInfPin(map);
  Utils$AdventOfCode.dump_mapInt_of(targetPins, (function (c) {
          return String(c.x) + " " + String(c.y);
        }));
  var match = Belt_Option.getExn(Belt_MapInt.maximum(Belt_MapInt.keep(areas, (function (k, v) {
                  return Belt_MapInt.has(targetPins, k);
                }))));
  console.log(" ======== answer");
  var prim = "targetPin = " + String(match[0]);
  console.log(prim);
  var prim$1 = "maxArea = " + String(match[1]);
  console.log(prim$1);
  
}

var data = Day6_Data$AdventOfCode.data;

var testData = Day6_Data_Test$AdventOfCode.data;

exports.log = log;
exports.data = data;
exports.testData = testData;
exports.Coord = Coord;
exports.LandingMap = LandingMap;
exports.solvePart1 = solvePart1;
/* No side effect */
