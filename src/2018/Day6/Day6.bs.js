// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Js_int = require("bs-platform/lib/js/js_int.js");
var Belt_Int = require("bs-platform/lib/js/belt_Int.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_MapInt = require("bs-platform/lib/js/belt_MapInt.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Day6_Data$AdventOfCode = require("./Day6_Data.bs.js");
var Day6_Data_Test$AdventOfCode = require("./Day6_Data_Test.bs.js");

function log(prim) {
  console.log(prim);
  
}

function x(t) {
  return t.x;
}

function y(t) {
  return t.y;
}

function make(x, y) {
  return {
          x: x,
          y: y
        };
}

function makeFromArray(xs) {
  return {
          x: Belt_Option.getExn(Belt_Array.get(xs, 0)),
          y: Belt_Option.getExn(Belt_Array.get(xs, 1))
        };
}

function maxXY(xs) {
  return Belt_Array.reduce(xs, {
              x: 0,
              y: 0
            }, (function (a, c) {
                var match = a.x < c.x;
                var match$1 = a.y < c.y;
                if (match) {
                  if (match$1) {
                    return {
                            x: c.x,
                            y: c.y
                          };
                  } else {
                    return {
                            x: c.x,
                            y: a.y
                          };
                  }
                } else if (match$1) {
                  return {
                          x: a.x,
                          y: c.y
                        };
                } else {
                  return a;
                }
              }));
}

function dist(a, b) {
  return Math.abs(b.x - a.x | 0) + Math.abs(b.y - a.y | 0) | 0;
}

var Coord = {
  x: x,
  y: y,
  make: make,
  makeFromArray: makeFromArray,
  maxXY: maxXY,
  dist: dist
};

function w(t) {
  return t.w;
}

function h(t) {
  return t.h;
}

function grid(t) {
  return t.grid;
}

function makeCell_full(at, locs) {
  return Belt_Array.reduceWithIndex(locs, undefined, (function (a, l, i) {
                return Belt_MapInt.set(a, i, dist(at, l));
              }));
}

function makeCellShortest(at, locs) {
  console.log("makeCellShortest");
  var allDists = makeCell_full(at, locs);
  var minDist = Belt_MapInt.reduce(allDists, Js_int.max, (function (a, k, v) {
          if (v < a) {
            return v;
          } else {
            return a;
          }
        }));
  console.log(at);
  console.log(minDist);
  var match = Belt_MapInt.reduce(allDists, [
        minDist,
        []
      ], (function (a, k, v) {
          var minDist = a[0];
          if (v === minDist) {
            return [
                    minDist,
                    Belt_Array.concat(a[1], [v])
                  ];
          } else {
            return a;
          }
        }));
  var foundMinDist = match[1];
  if (foundMinDist.length >= 1) {
    return -1;
  } else {
    return Belt_Option.getExn(Belt_Array.get(foundMinDist, 0));
  }
}

function alloc(t) {
  console.log("alloc");
  console.log([
        t.w,
        t.h
      ]);
  var filled = Belt_Array.reduce(Belt_Array.range(0, t.w - 1 | 0), undefined, (function (a, x) {
          return Belt_MapInt.set(a, x, Belt_Array.reduce(Belt_Array.range(0, t.h - 1 | 0), undefined, (function (b, y) {
                            return Belt_MapInt.set(b, y, -1);
                          })));
        }));
  return {
          locs: t.locs,
          grid: filled,
          w: t.w,
          h: t.h
        };
}

function fill(t) {
  var filled = Belt_MapInt.reduce(alloc(t).grid, undefined, (function (a, kx, x) {
          return Belt_MapInt.set(a, kx, Belt_MapInt.reduce(x, undefined, (function (a, ky, y) {
                            return Belt_MapInt.set(a, ky, makeCellShortest({
                                            x: kx,
                                            y: ky
                                          }, t.locs));
                          })));
        }));
  console.log("fill");
  console.log(filled);
  return {
          locs: t.locs,
          grid: filled,
          w: t.w,
          h: t.h
        };
}

function make$1(xs) {
  var s = maxXY(xs);
  return fill({
              locs: xs,
              grid: undefined,
              w: s.x,
              h: s.y
            });
}

function dump(t) {
  console.log("dump");
  return Belt_MapInt.forEach(t.grid, (function (kx, vx) {
                console.log(kx);
                return Belt_MapInt.forEach(vx, (function (ky, vy) {
                              console.log(ky);
                              console.log([
                                    kx,
                                    ky,
                                    vy
                                  ]);
                              
                            }));
              }));
}

var $$Map = {
  w: w,
  h: h,
  grid: grid,
  makeCell_full: makeCell_full,
  makeCellShortest: makeCellShortest,
  alloc: alloc,
  fill: fill,
  make: make$1,
  dump: dump
};

function parse(l) {
  return makeFromArray(Belt_Array.map(l.trim().split(","), (function (x) {
                    return Belt_Option.getExn(Belt_Int.fromString(x.trim()));
                  })));
}

var data = Day6_Data$AdventOfCode.data;

var testData = Day6_Data_Test$AdventOfCode.data;

exports.log = log;
exports.data = data;
exports.testData = testData;
exports.Coord = Coord;
exports.$$Map = $$Map;
exports.parse = parse;
/* No side effect */
