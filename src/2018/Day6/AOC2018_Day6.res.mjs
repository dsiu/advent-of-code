// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Utils from "../../Utils.res.mjs";
import * as Js_int from "rescript/lib/es6/Js_int.js";
import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Belt_MapInt from "rescript/lib/es6/Belt_MapInt.js";
import * as AOC2018_Day6_Data from "./AOC2018_Day6_Data.res.mjs";
import * as AOC2018_Day6_Data_Sample from "./AOC2018_Day6_Data_Sample.res.mjs";

function log(prim) {
  console.log(prim);
}

function x(t) {
  return t.x;
}

function y(t) {
  return t.y;
}

function make(x, y) {
  return {
    x: x,
    y: y
  };
}

function makeFromArray(xs) {
  return {
    x: Belt_Array.getExn(xs, 0),
    y: Belt_Array.getExn(xs, 1)
  };
}

function findXY(f, init, xs) {
  return Belt_Array.reduce(xs, {
    x: init,
    y: init
  }, (a, c) => ({
    x: f(a.x, c.x),
    y: f(a.y, c.y)
  }));
}

function maxXY(__x) {
  return findXY((prim0, prim1) => Math.max(prim0, prim1), Js_int.min, __x);
}

function minXY(__x) {
  return findXY((prim0, prim1) => Math.min(prim0, prim1), Js_int.max, __x);
}

function dist(a, b) {
  return Math.abs(b.x - a.x | 0) + Math.abs(b.y - a.y | 0) | 0;
}

function parse(l) {
  return makeFromArray(Belt_Array.map(l.trim().split(","), Utils.intFromStringExn));
}

function parseCoords(__x) {
  return Belt_Array.map(__x, parse);
}

let Coord = {
  x: x,
  y: y,
  make: make,
  makeFromArray: makeFromArray,
  findXY: findXY,
  maxXY: maxXY,
  minXY: minXY,
  dist: dist,
  parse: parse,
  parseCoords: parseCoords
};

function w(t) {
  return t.w;
}

function h(t) {
  return t.h;
}

function grid(t) {
  return t.grid;
}

function distsFromPins(at, pins) {
  return Belt_MapInt.map(pins, v => dist(at, v));
}

function findMinDists(__x) {
  return Belt_MapInt.reduce(__x, Js_int.max, (a, _k, v) => {
    if (v < a) {
      return v;
    } else {
      return a;
    }
  });
}

function keepOnly(value, xs) {
  return Belt_MapInt.keep(xs, (_k, v) => v === value);
}

function makeCellShortest(at, pins) {
  let dists = distsFromPins(at, pins);
  let minDist = findMinDists(dists);
  let onlyMins = keepOnly(minDist, dists);
  if (Belt_MapInt.size(onlyMins) <= 0) {
    throw {
      RE_EXN_ID: "Assert_failure",
      _1: [
        "AOC2018_Day6.res",
        93,
        4
      ],
      Error: new Error()
    };
  }
  if (Belt_MapInt.size(onlyMins) > 1) {
    return -1;
  } else {
    return Belt_MapInt.reduce(onlyMins, Js_int.min, (_a, k, _v) => k);
  }
}

function alloc(t) {
  let filled = Belt_Array.reduce(Belt_Array.range(0, t.w), undefined, (a, x) => Belt_MapInt.set(a, x, Belt_Array.reduce(Belt_Array.range(0, t.h), undefined, (b, y) => Belt_MapInt.set(b, y, -99))));
  return {
    pins: t.pins,
    grid: filled,
    w: t.w,
    h: t.h,
    maxBound: t.maxBound,
    minBound: t.minBound
  };
}

function fill(t) {
  let filled = Belt_MapInt.reduce(t.grid, undefined, (a, kx, x) => Belt_MapInt.set(a, kx, Belt_MapInt.reduce(x, undefined, (a, ky, _y) => Belt_MapInt.set(a, ky, makeCellShortest({
    x: kx,
    y: ky
  }, t.pins)))));
  return {
    pins: t.pins,
    grid: filled,
    w: t.w,
    h: t.h,
    maxBound: t.maxBound,
    minBound: t.minBound
  };
}

function make$1(xs) {
  let maxBound = maxXY(xs);
  let minBound = minXY(xs);
  console.log(maxBound);
  console.log(minBound);
  let pinsMap = Belt_Array.reduceWithIndex(xs, undefined, (a, x, i) => Belt_MapInt.set(a, i, x));
  let prim = Utils.Printable.MapInt.toString(pinsMap, c => String(c.x) + " " + String(c.y));
  console.log(prim);
  return fill(alloc({
    pins: pinsMap,
    grid: undefined,
    w: maxBound.x,
    h: maxBound.y,
    maxBound: maxBound,
    minBound: minBound
  }));
}

function countCellWith(pinId, t) {
  return Belt_MapInt.reduce(t.grid, 0, (a, _kx, x) => a + Belt_MapInt.size(keepOnly(pinId, x)) | 0);
}

function getNonInfPin(t) {
  let minBound = t.minBound;
  let maxBound = t.maxBound;
  return Belt_MapInt.keep(t.pins, (_k, v) => v.x !== maxBound.x && v.x !== minBound.x && v.y !== maxBound.y && v.y !== minBound.y);
}

function findLandingAreasOfPins(t) {
  return Belt_MapInt.mapWithKey(t.pins, (k, _v) => countCellWith(k, t));
}

function getMaxArea(m) {
  return Belt_MapInt.reduce(m, 0, (a, _k, v) => Math.max(a, v));
}

function numToChar(xs) {
  return Belt_Array.map(xs, x => {
    if (x !== -1) {
      return String.fromCharCode(97 + x | 0);
    } else {
      return ".";
    }
  });
}

function toString(t) {
  console.log("x, y, v");
  Belt_MapInt.forEach(t.grid, (_kx, vx) => {
    console.log(...numToChar(Belt_MapInt.valuesToArray(vx)));
  });
}

let LandingMap = {
  w: w,
  h: h,
  grid: grid,
  distsFromPins: distsFromPins,
  findMinDists: findMinDists,
  keepOnly: keepOnly,
  makeCellShortest: makeCellShortest,
  alloc: alloc,
  fill: fill,
  make: make$1,
  countCellWith: countCellWith,
  getNonInfPin: getNonInfPin,
  findLandingAreasOfPins: findLandingAreasOfPins,
  getMaxArea: getMaxArea,
  numToChar: numToChar,
  toString: toString
};

function solvePart1(data) {
  let map = make$1(Belt_Array.map(data.split("\n"), parse));
  let areas = findLandingAreasOfPins(map);
  let prim = " ========= landing areas (size = " + String(Belt_MapInt.size(areas)) + ")";
  console.log(prim);
  let prim$1 = Utils.Printable.MapInt.Int.toString(areas, undefined);
  console.log(prim$1);
  let targetPins = getNonInfPin(map);
  let prim$2 = " ======== target pins (size = " + String(Belt_MapInt.size(targetPins)) + ")";
  console.log(prim$2);
  let prim$3 = Utils.Printable.MapInt.toString(targetPins, c => String(c.x) + " " + String(c.y));
  console.log(prim$3);
  let maxArea = Belt_MapInt.reduce(Belt_MapInt.keep(areas, (k, _v) => Belt_MapInt.has(targetPins, k)), Js_int.min, (a, _k, v) => {
    if (v > a) {
      return v;
    } else {
      return a;
    }
  });
  console.log(" ======== answer");
  let prim$4 = "maxArea = " + String(maxArea);
  console.log(prim$4);
}

function solvePart2(data) {
  console.log(data);
  return 2;
}

let data = AOC2018_Day6_Data.data;

let sampleData = AOC2018_Day6_Data_Sample.data;

export {
  log,
  data,
  sampleData,
  Coord,
  LandingMap,
  solvePart1,
  solvePart2,
}
/* Utils Not a pure module */
