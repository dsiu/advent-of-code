// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Id from "rescript/lib/es6/Belt_Id.js";
import * as Belt_Option from "rescript/lib/es6/Belt_Option.js";
import * as Belt_MutableSet from "rescript/lib/es6/Belt_MutableSet.js";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";
import * as Primitive_string from "rescript/lib/es6/Primitive_string.js";
import * as Belt_MutableMapString from "rescript/lib/es6/Belt_MutableMapString.js";
import * as Belt_MutableSetString from "rescript/lib/es6/Belt_MutableSetString.js";

function Make(BASE) {
  let containerMake = BASE.containerMake;
  let containerAdd = BASE.containerAdd;
  let containerRemove = BASE.containerRemove;
  let containerHas = BASE.containerHas;
  let containerToArray = BASE.containerToArray;
  let addVertex = (t, x) => {
    let match = Belt_MutableMapString.get(t, x);
    if (match !== undefined) {
      return;
    } else {
      return Belt_MutableMapString.set(t, x, containerMake());
    }
  };
  let removeVertex = Belt_MutableMapString.remove;
  let getVertex = (t, x) => {
    addVertex(t, x);
    let v = Belt_MutableMapString.get(t, x);
    if (v !== undefined) {
      return Primitive_option.valFromOption(v);
    }
    throw {
      RE_EXN_ID: "Not_found",
      Error: new Error()
    };
  };
  let addEdge = (t, x, e) => containerAdd(getVertex(t, x), e);
  let removeEdge = (t, x, y) => {
    if (Belt_MutableMapString.has(t, x)) {
      return containerRemove(getVertex(t, x), y);
    }
    
  };
  let adjacent = (t, x, y) => {
    let v = Belt_MutableMapString.get(t, x);
    if (v !== undefined) {
      return containerHas(Primitive_option.valFromOption(v), y);
    } else {
      return false;
    }
  };
  let neighbors = (t, x) => Belt_Option.getWithDefault(Belt_MutableMapString.get(t, x), containerMake());
  let toString = t => {
    let str = {
      contents: ""
    };
    Belt_MutableMapString.forEach(t, (k, v) => {
      str.contents = str.contents + k + ": [ " + containerToArray(v).join(",") + " ]\n";
    });
    return str.contents;
  };
  return {
    make: Belt_MutableMapString.make,
    addVertex: addVertex,
    removeVertex: removeVertex,
    getVertex: getVertex,
    addEdge: addEdge,
    removeEdge: removeEdge,
    adjacent: adjacent,
    neighbors: neighbors,
    toString: toString
  };
}

function addVertex(t, x) {
  let match = Belt_MutableMapString.get(t, x);
  if (match !== undefined) {
    return;
  } else {
    return Belt_MutableMapString.set(t, x, Belt_MutableSetString.make());
  }
}

let removeVertex = Belt_MutableMapString.remove;

function getVertex(t, x) {
  addVertex(t, x);
  let v = Belt_MutableMapString.get(t, x);
  if (v !== undefined) {
    return Primitive_option.valFromOption(v);
  }
  throw {
    RE_EXN_ID: "Not_found",
    Error: new Error()
  };
}

function addEdge(t, x, e) {
  Belt_MutableSetString.add(getVertex(t, x), e);
}

function removeEdge(t, x, y) {
  if (Belt_MutableMapString.has(t, x)) {
    return Belt_MutableSetString.remove(getVertex(t, x), y);
  }
  
}

function adjacent(t, x, y) {
  let v = Belt_MutableMapString.get(t, x);
  if (v !== undefined) {
    return Belt_MutableSetString.has(Primitive_option.valFromOption(v), y);
  } else {
    return false;
  }
}

function neighbors(t, x) {
  return Belt_Option.getWithDefault(Belt_MutableMapString.get(t, x), Belt_MutableSetString.make());
}

function toString(t) {
  let str = {
    contents: ""
  };
  Belt_MutableMapString.forEach(t, (k, v) => {
    str.contents = str.contents + k + ": [ " + Belt_MutableSetString.toArray(v).join(",") + " ]\n";
  });
  return str.contents;
}

let $$String = {
  make: Belt_MutableMapString.make,
  addVertex: addVertex,
  removeVertex: removeVertex,
  getVertex: getVertex,
  addEdge: addEdge,
  removeEdge: removeEdge,
  adjacent: adjacent,
  neighbors: neighbors,
  toString: toString
};

function eq(param, param$1) {
  return param[0] === param$1[0];
}

function cmp(param, param$1) {
  return Primitive_string.compare(param[0], param$1[0]);
}

function hash(param) {
  return caml_hash_final_mix(caml_hash_mix_string(0, param[0]));
}

let T = {
  eq: eq,
  cmp: cmp,
  hash: hash
};

let MutableSetTuple = Belt_Id.MakeComparable({
  cmp: cmp
});

let TupleImpl = {
  T: T,
  MutableSetTuple: MutableSetTuple
};

function addVertex$1(t, x) {
  let match = Belt_MutableMapString.get(t, x);
  if (match !== undefined) {
    return;
  } else {
    return Belt_MutableMapString.set(t, x, Belt_MutableSet.make(MutableSetTuple));
  }
}

let removeVertex$1 = Belt_MutableMapString.remove;

function getVertex$1(t, x) {
  addVertex$1(t, x);
  let v = Belt_MutableMapString.get(t, x);
  if (v !== undefined) {
    return Primitive_option.valFromOption(v);
  }
  throw {
    RE_EXN_ID: "Not_found",
    Error: new Error()
  };
}

function addEdge$1(t, x, e) {
  Belt_MutableSet.add(getVertex$1(t, x), e);
}

function removeEdge$1(t, x, y) {
  if (Belt_MutableMapString.has(t, x)) {
    return Belt_MutableSet.remove(getVertex$1(t, x), y);
  }
  
}

function adjacent$1(t, x, y) {
  let v = Belt_MutableMapString.get(t, x);
  if (v !== undefined) {
    return Belt_MutableSet.has(Primitive_option.valFromOption(v), y);
  } else {
    return false;
  }
}

function neighbors$1(t, x) {
  return Belt_Option.getWithDefault(Belt_MutableMapString.get(t, x), Belt_MutableSet.make(MutableSetTuple));
}

function toString$1(t) {
  let str = {
    contents: ""
  };
  Belt_MutableMapString.forEach(t, (k, v) => {
    str.contents = str.contents + k + ": [ " + Belt_MutableSet.toArray(v).join(",") + " ]\n";
  });
  return str.contents;
}

let Tuple = {
  make: Belt_MutableMapString.make,
  addVertex: addVertex$1,
  removeVertex: removeVertex$1,
  getVertex: getVertex$1,
  addEdge: addEdge$1,
  removeEdge: removeEdge$1,
  adjacent: adjacent$1,
  neighbors: neighbors$1,
  toString: toString$1
};

export {
  Make,
  $$String,
  TupleImpl,
  Tuple,
}
/* MutableSetTuple Not a pure module */
