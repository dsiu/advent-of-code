// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Stdlib__Int from "@dsiu/rescript-stdlib-fp/src/Stdlib__Int.mjs";
import * as Stdlib__Array from "@dsiu/rescript-stdlib-fp/src/Stdlib__Array.mjs";
import * as Stdlib__Tuple2 from "@dsiu/rescript-stdlib-fp/src/Stdlib__Tuple2.mjs";
import * as Utils$AdventOfCode from "../../Utils.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function ruleMapUpdate(m, key, f) {
  let value = m.get(key);
  if (value !== undefined) {
    m.set(key, f(value));
  } else {
    m.set(key, f([
      new Set(),
      new Set()
    ]));
  }
}

function makeRules(rulesData) {
  return Stdlib__Array.reduce(rulesData, new Map(), (acc, param) => {
    let after = param[1];
    let before = param[0];
    ruleMapUpdate(acc, before, param => {
      let v = param[1];
      v.add(after);
      return [
        param[0],
        v
      ];
    });
    ruleMapUpdate(acc, after, param => {
      let u = param[0];
      u.add(before);
      return [
        u,
        param[1]
      ];
    });
    return acc;
  });
}

function isOrderValid(update, rules) {
  let match = Stdlib__Array.reduceWithIndex(update, [
    [],
    [],
    [],
    update
  ], (acc, x, i) => {
    let update = acc[3];
    let u = acc[1];
    let cur = Stdlib__Array.getUnsafe(update, i);
    let v$p = update.slice(i + 1 | 0);
    let param = rules.get(cur);
    let left = new Set(u).isSubsetOf(param[0]);
    let right = new Set(v$p).isSubsetOf(param[1]);
    let result$p = left && right;
    u.push(cur);
    return [
      Belt_Array.concatMany([
        acc[0],
        [result$p]
      ]),
      u,
      v$p,
      update
    ];
  });
  return match[0].every(x => x);
}

function parse(data) {
  let match = Utils$AdventOfCode.splitDoubleNewline(data).map(Utils$AdventOfCode.splitNewline);
  if (match.length !== 2) {
    throw {
      RE_EXN_ID: "Match_failure",
      _1: [
        "AOC2024_Day5.res",
        66,
        6
      ],
      Error: new Error()
    };
  }
  let rules = match[0];
  let updates = match[1];
  return [
    rules.map(l => Stdlib__Tuple2.fromArray(l.trim().split("|").map(x => Stdlib__Int.fromString(x, undefined)))),
    updates.map(l => l.trim().split(",").map(x => Stdlib__Int.fromString(x, undefined)))
  ];
}

function solvePart1(data) {
  let match = parse(data);
  let rules = makeRules(match[0]);
  return Utils$AdventOfCode.sumIntArray(match[1].filter(x => isOrderValid(x, rules)).map(x => Stdlib__Array.getUnsafe(x, x.length / 2 | 0)));
}

function solvePart2(data) {
  return 2;
}

export {
  log,
  log2,
  ruleMapUpdate,
  makeRules,
  isOrderValid,
  parse,
  solvePart1,
  solvePart2,
}
/* Stdlib__Int Not a pure module */
