// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Utils from "../../Utils.res.mjs";
import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Relude_Int from "rescript-relude/src/Relude_Int.res.mjs";
import * as Relude_Map from "rescript-relude/src/Relude_Map.res.mjs";
import * as Relude_Set from "rescript-relude/src/Relude_Set.res.mjs";
import * as Stdlib__Int from "@dsiu/rescript-stdlib-fp/src/Stdlib__Int.res.mjs";
import * as Stdlib__List from "@dsiu/rescript-stdlib-fp/src/Stdlib__List.res.mjs";
import * as Stdlib__Array from "@dsiu/rescript-stdlib-fp/src/Stdlib__Array.res.mjs";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";
import * as Primitive_exceptions from "rescript/lib/es6/Primitive_exceptions.js";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

let M = Relude_Map.WithOrd(Relude_Int.Ord);

let S = Relude_Set.WithOrd(Relude_Int.Ord);

function union(a, b) {
  return M.merge((_k, v1, v2) => {
    if (v1 !== undefined) {
      return Primitive_option.some(Primitive_option.valFromOption(v1));
    } else if (v2 !== undefined) {
      return Primitive_option.some(Primitive_option.valFromOption(v2));
    } else {
      return;
    }
  }, a, b);
}

function mapDeleteFindMax(m) {
  let match = M.max(m);
  let k = match[0];
  return [
    [
      k,
      match[1]
    ],
    M.remove(k, m)
  ];
}

function setDeleteFindMin(s) {
  let k = S.minimum(s);
  return [
    k,
    S.remove(k, s)
  ];
}

function fileID(r) {
  if (r.TAG === "Free") {
    return -1;
  } else {
    return r._1;
  }
}

function freeSize(r) {
  if (r.TAG === "Free") {
    return r._0;
  } else {
    return 0;
  }
}

function expandRegion(acc, size) {
  if (acc[0]) {
    let fID = acc[2];
    return [
      false,
      acc[1] + size | 0,
      fID + 1 | 0,
      Belt_Array.concatMany([
        [{
            TAG: "Used",
            _0: size,
            _1: fID
          }],
        acc[3]
      ])
    ];
  }
  let disk = acc[3];
  let fID$1 = acc[2];
  let pos = acc[1];
  if (size !== 0) {
    return [
      true,
      pos + size | 0,
      fID$1,
      Belt_Array.concatMany([
        [{
            TAG: "Free",
            _0: size
          }],
        disk
      ])
    ];
  } else {
    return [
      true,
      pos,
      fID$1,
      disk
    ];
  }
}

function expandRDisk(diskMap) {
  let diskMap$1 = diskMap.toReversed();
  return Stdlib__Array.reduce(diskMap$1, [
      true,
      0,
      0,
      []
    ], expandRegion)[3];
}

function toBlock(acc, r) {
  let free = acc[2];
  let disk = acc[1];
  let pos = acc[0];
  if (r.TAG === "Free") {
    let size = r._0;
    let gap = Stdlib__List.fromInitializer(size, i => pos + i | 0);
    let free$p = S.union(free, S.fromArray(Stdlib__List.toArray(gap)));
    return [
      pos + size | 0,
      disk,
      free$p
    ];
  }
  let size$1 = r._0;
  let fileExtent = Stdlib__Array.zip(Stdlib__Array.fromInitializer(size$1, i => pos + i | 0), Stdlib__Array.make(size$1, r._1));
  let file = M.fromArray(fileExtent);
  let disk$p = union(disk, file);
  return [
    pos + size$1 | 0,
    disk$p,
    free
  ];
}

function toBlocks(rdisk) {
  let match = Stdlib__Array.reduce(rdisk, [
    0,
    M.make(),
    S.empty
  ], toBlock);
  return [
    match[1],
    match[2]
  ];
}

function findFree(size, disk) {
  let match = Stdlib__Array.$$break(disk, r => freeSize(r) >= size);
  let suffix = match[1];
  if (size !== 0) {
    return [
      match[0],
      Stdlib__Array.headUnsafe(suffix),
      Stdlib__Array.tail(suffix)
    ];
  }
  
}

let Impossible = /* @__PURE__ */Primitive_exceptions.create("AOC2024_Day9.Impossible");

function tidyRegion(_rdisk, _r) {
  while (true) {
    let r = _r;
    let rdisk = _rdisk;
    if (r.TAG !== "Free") {
      return Belt_Array.concatMany([
        [r],
        rdisk
      ]);
    }
    let size = r._0;
    if (size === 0) {
      return rdisk;
    }
    let head = rdisk[0];
    if (head === undefined) {
      return Belt_Array.concatMany([
        [r],
        rdisk
      ]);
    }
    if (head.TAG !== "Free") {
      return Belt_Array.concatMany([
        [r],
        rdisk
      ]);
    }
    let rdisk$p = Stdlib__Array.tail(rdisk);
    _r = {
      TAG: "Free",
      _0: size + head._0 | 0
    };
    _rdisk = rdisk$p;
    continue;
  };
}

function tidy(disk) {
  return Stdlib__Array.reduceRight(disk, [], tidyRegion);
}

function packFile(fid, disk) {
  let match = Stdlib__Array.span(disk, r => fileID(r) !== fid);
  let suffix0 = match[1];
  let match$1 = suffix0[0];
  if (match$1.TAG === "Free") {
    throw {
      RE_EXN_ID: "Match_failure",
      _1: [
        "AOC2024_Day9.res",
        129,
        6
      ],
      Error: new Error()
    };
  }
  let fSize = match$1._0;
  let suffix = Stdlib__Array.tail(suffix0);
  let gap = findFree(fSize, match[0]);
  if (gap === undefined) {
    return disk;
  }
  let gapSize = gap[1];
  if (gapSize.TAG === "Free") {
    return Belt_Array.concatMany([
      gap[0],
      [
        {
          TAG: "Used",
          _0: fSize,
          _1: fid
        },
        {
          TAG: "Free",
          _0: gapSize._0 - fSize | 0
        }
      ],
      gap[2],
      [{
          TAG: "Free",
          _0: fSize
        }],
      suffix
    ]);
  }
  throw {
    RE_EXN_ID: "Match_failure",
    _1: [
      "AOC2024_Day9.res",
      134,
      2
    ],
    Error: new Error()
  };
}

function packBelow(_fid, _disk) {
  while (true) {
    let disk = _disk;
    let fid = _fid;
    if (disk.length === 0) {
      return [];
    }
    if (fid === 0) {
      return disk;
    }
    let disk$1 = packFile(fid, disk);
    let disk$p = Stdlib__Array.reduceRight(disk$1, [], tidyRegion);
    _disk = disk$p;
    _fid = fid - 1 | 0;
    continue;
  };
}

function packFiles(disk) {
  let maxID = Utils.maxIntInArray(disk.map(fileID));
  return packBelow(maxID, disk);
}

function expandMapItem(acc, size) {
  let free = acc[4];
  let disk = acc[3];
  let fileID = acc[2];
  let pos = acc[1];
  if (acc[0]) {
    let fileExtent = Stdlib__Array.zip(Stdlib__Array.fromInitializer(size, i => pos + i | 0), Stdlib__Array.make(size, fileID));
    let file = M.fromArray(fileExtent);
    let disk$p = union(disk, file);
    return [
      false,
      pos + size | 0,
      fileID + 1 | 0,
      disk$p,
      free
    ];
  }
  let gap = S.fromArray(Stdlib__Array.fromInitializer(size, i => pos + i | 0));
  let free$p = S.union(free, gap);
  return [
    true,
    pos + size | 0,
    fileID,
    disk,
    free$p
  ];
}

function expand(diskMap) {
  let match = Stdlib__Array.reduce(diskMap, [
    true,
    0,
    0,
    M.make(),
    S.empty
  ], expandMapItem);
  return [
    match[3],
    match[4]
  ];
}

function showDisk(disk) {
  let pMax = M.maxKey(disk);
  let str = "";
  for (let i = 0; i <= pMax; ++i) {
    let v = M.get(i, disk);
    let char = v !== undefined ? v.toString() : ".";
    str = str + char;
  }
  return str;
}

function showFree(free) {
  let pMax = S.maximum(free);
  let str = "";
  for (let i = 0; i <= pMax; ++i) {
    let char = S.contains(i, free) ? "+" : ".";
    str = str + char;
  }
  return str;
}

function showDiskFree(disk, free) {
  return showDisk(disk) + "\n" + showFree(free);
}

function isPackedBlock(disk, free) {
  let dMax = M.maxKey(disk);
  let fMin = S.minimum(free);
  return dMax < fMin;
}

function packBlocksStep(disk, free) {
  if (isPackedBlock(disk, free)) {
    return [
      disk,
      free
    ];
  }
  let match = mapDeleteFindMax(disk);
  let match$1 = match[0];
  let match$2 = setDeleteFindMin(free);
  return [
    M.set(match$2[0], match$1[1], match[1]),
    S.add(match$1[0], match$2[1])
  ];
}

function packBlocks(disk, free) {
  let _disk = disk;
  let _free = free;
  while (true) {
    let free$1 = _free;
    let disk$1 = _disk;
    if (isPackedBlock(disk$1, free$1)) {
      return [
        disk$1,
        free$1
      ];
    }
    let match = packBlocksStep(disk$1, free$1);
    _free = match[1];
    _disk = match[0];
    continue;
  };
}

function parse(data) {
  return data.trim().split("").map(s => Stdlib__Int.fromString(s, undefined));
}

function solvePart1(data) {
  let diskMap = parse(data);
  let match = expand(diskMap);
  let match$1 = packBlocks(match[0], match[1]);
  let __x = M.toArray(match$1[0]).map(param => BigInt(param[0]) * BigInt(param[1]));
  return Stdlib__Array.reduce(__x, 0n, (prim0, prim1) => prim0 + prim1);
}

function solvePart2(data) {
  let diskMap = parse(data);
  console.log("diskMap", diskMap);
  let rDisk = expandRDisk(diskMap);
  console.log("rDisk", rDisk);
  let rDisk$p = packFiles(rDisk);
  console.log("rDisk'", rDisk$p);
  let match = toBlocks(rDisk$p);
  let __x = M.toArray(match[0]).map(param => BigInt(param[0]) * BigInt(param[1]));
  return Stdlib__Array.reduce(__x, 0n, (prim0, prim1) => prim0 + prim1);
}

export {
  log,
  log2,
  M,
  S,
  union,
  mapDeleteFindMax,
  setDeleteFindMin,
  fileID,
  freeSize,
  expandRegion,
  expandRDisk,
  toBlock,
  toBlocks,
  findFree,
  Impossible,
  tidyRegion,
  tidy,
  packFile,
  packBelow,
  packFiles,
  expandMapItem,
  expand,
  showDisk,
  showFree,
  showDiskFree,
  isPackedBlock,
  packBlocksStep,
  packBlocks,
  parse,
  solvePart1,
  solvePart2,
}
/* M Not a pure module */
