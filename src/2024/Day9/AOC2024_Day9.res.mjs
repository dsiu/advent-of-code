// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Belt_MapInt from "rescript/lib/es6/Belt_MapInt.js";
import * as Belt_SetInt from "rescript/lib/es6/Belt_SetInt.js";
import * as Stdlib__Int from "@dsiu/rescript-stdlib-fp/src/Stdlib__Int.res.mjs";
import * as Stdlib__List from "@dsiu/rescript-stdlib-fp/src/Stdlib__List.res.mjs";
import * as Stdlib__Array from "@dsiu/rescript-stdlib-fp/src/Stdlib__Array.res.mjs";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function union(a, b) {
  return Belt_MapInt.merge(a, b, (_k, v1, v2) => {
    if (v1 !== undefined) {
      return Primitive_option.some(Primitive_option.valFromOption(v1));
    } else if (v2 !== undefined) {
      return Primitive_option.some(Primitive_option.valFromOption(v2));
    } else {
      return;
    }
  });
}

function mapDeleteFindMax(m) {
  let match = Belt_MapInt.maximum(m);
  let k = match[0];
  return [
    [
      k,
      match[1]
    ],
    Belt_MapInt.remove(m, k)
  ];
}

function setDeleteFindMin(s) {
  let k = Belt_SetInt.minimum(s);
  return [
    k,
    Belt_SetInt.remove(s, k)
  ];
}

function fileID(r) {
  if (r.TAG === "Free") {
    return -1;
  } else {
    return r._1;
  }
}

function freeSize(r) {
  if (r.TAG === "Free") {
    return r._0;
  } else {
    return 0;
  }
}

function expandRegion(acc, size) {
  if (acc[0]) {
    let fID = acc[2];
    return [
      false,
      acc[1] + size | 0,
      fID + 1 | 0,
      Belt_Array.concatMany([
        [{
            TAG: "Used",
            _0: size,
            _1: fID
          }],
        acc[3]
      ])
    ];
  }
  let disk = acc[3];
  let fID$1 = acc[2];
  let pos = acc[1];
  if (size !== 0) {
    return [
      true,
      pos + size | 0,
      fID$1,
      Belt_Array.concatMany([
        [{
            TAG: "Free",
            _0: size
          }],
        disk
      ])
    ];
  } else {
    return [
      true,
      pos,
      fID$1,
      disk
    ];
  }
}

function toBlock(acc, r) {
  let free = acc[2];
  let disk = acc[1];
  let pos = acc[0];
  if (r.TAG === "Free") {
    let size = r._0;
    let gap = Stdlib__List.fromInitializer(size, i => pos + i | 0);
    let free$p = Belt_SetInt.union(free, Belt_SetInt.fromArray(Stdlib__List.toArray(gap)));
    return [
      pos + size | 0,
      disk,
      free$p
    ];
  }
  let size$1 = r._0;
  let fileExtent = Stdlib__Array.zip(Stdlib__Array.fromInitializer(size$1, i => pos + i | 0), Stdlib__Array.make(size$1, r._1));
  let file = Belt_MapInt.fromArray(fileExtent);
  let disk$p = union(disk, file);
  return [
    pos + size$1 | 0,
    disk$p,
    free
  ];
}

function toBlocks(rdisk) {
  let match = Stdlib__Array.reduce(rdisk, [
    0,
    undefined,
    undefined
  ], toBlock);
  return [
    match[1],
    match[2]
  ];
}

function expandMapItem(acc, size) {
  let free = acc[4];
  let disk = acc[3];
  let fileID = acc[2];
  let pos = acc[1];
  if (acc[0]) {
    let fileExtent = Stdlib__Array.zip(Stdlib__Array.fromInitializer(size, i => pos + i | 0), Stdlib__Array.make(size, fileID));
    let file = Belt_MapInt.fromArray(fileExtent);
    let disk$p = union(disk, file);
    return [
      false,
      pos + size | 0,
      fileID + 1 | 0,
      disk$p,
      free
    ];
  }
  let gap = Belt_SetInt.fromArray(Stdlib__Array.fromInitializer(size, i => pos + i | 0));
  let free$p = Belt_SetInt.union(free, gap);
  return [
    true,
    pos + size | 0,
    fileID,
    disk,
    free$p
  ];
}

function expand(diskMap) {
  let match = Stdlib__Array.reduce(diskMap, [
    true,
    0,
    0,
    undefined,
    undefined
  ], expandMapItem);
  return [
    match[3],
    match[4]
  ];
}

function showDisk(disk) {
  let pMax = Belt_MapInt.maxKey(disk);
  let str = "";
  for (let i = 0; i <= pMax; ++i) {
    let v = Belt_MapInt.get(disk, i);
    let char = v !== undefined ? v.toString() : ".";
    str = str + char;
  }
  return str;
}

function showFree(free) {
  let pMax = Belt_SetInt.maximum(free);
  let str = "";
  for (let i = 0; i <= pMax; ++i) {
    let char = Belt_SetInt.has(free, i) ? "+" : ".";
    str = str + char;
  }
  return str;
}

function showDiskFree(disk, free) {
  return showDisk(disk) + "\n" + showFree(free);
}

function isPackedBlock(disk, free) {
  let dMax = Belt_MapInt.maxKey(disk);
  let fMin = Belt_SetInt.minimum(free);
  return dMax < fMin;
}

function packBlocksStep(disk, free) {
  if (isPackedBlock(disk, free)) {
    return [
      disk,
      free
    ];
  }
  let match = mapDeleteFindMax(disk);
  let match$1 = match[0];
  let match$2 = setDeleteFindMin(free);
  return [
    Belt_MapInt.set(match[1], match$2[0], match$1[1]),
    Belt_SetInt.add(match$2[1], match$1[0])
  ];
}

function packBlocks(disk, free) {
  let _disk = disk;
  let _free = free;
  while (true) {
    let free$1 = _free;
    let disk$1 = _disk;
    if (isPackedBlock(disk$1, free$1)) {
      return [
        disk$1,
        free$1
      ];
    }
    let match = packBlocksStep(disk$1, free$1);
    _free = match[1];
    _disk = match[0];
    continue;
  };
}

function parse(data) {
  return data.trim().split("").map(s => Stdlib__Int.fromString(s, undefined));
}

function solvePart1(data) {
  let diskMap = parse(data);
  let match = expand(diskMap);
  let match$1 = packBlocks(match[0], match[1]);
  let __x = Belt_MapInt.toArray(match$1[0]).map(param => BigInt(param[0]) * BigInt(param[1]));
  return Stdlib__Array.reduce(__x, 0n, (prim0, prim1) => prim0 + prim1);
}

function solvePart2(data) {
  return 2;
}

let M;

let S;

export {
  log,
  log2,
  M,
  S,
  union,
  mapDeleteFindMax,
  setDeleteFindMin,
  fileID,
  freeSize,
  expandRegion,
  toBlock,
  toBlocks,
  expandMapItem,
  expand,
  showDisk,
  showFree,
  showDiskFree,
  isPackedBlock,
  packBlocksStep,
  packBlocks,
  parse,
  solvePart1,
  solvePart2,
}
/* Stdlib__Int Not a pure module */
