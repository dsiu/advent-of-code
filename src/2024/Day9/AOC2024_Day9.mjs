// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_MapInt from "rescript/lib/es6/Belt_MapInt.js";
import * as Belt_SetInt from "rescript/lib/es6/Belt_SetInt.js";
import * as Stdlib__Int from "@dsiu/rescript-stdlib-fp/src/Stdlib__Int.mjs";
import * as Stdlib__Array from "@dsiu/rescript-stdlib-fp/src/Stdlib__Array.mjs";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function union(a, b) {
  return Belt_MapInt.merge(a, b, (_k, v1, v2) => {
    if (v1 !== undefined) {
      return Primitive_option.some(Primitive_option.valFromOption(v1));
    } else if (v2 !== undefined) {
      return Primitive_option.some(Primitive_option.valFromOption(v2));
    } else {
      return;
    }
  });
}

function mapDeleteFindMax(m) {
  let match = Belt_MapInt.maximum(m);
  let k = match[0];
  return [
    [
      k,
      match[1]
    ],
    Belt_MapInt.remove(m, k)
  ];
}

function setDeleteFindMin(s) {
  let k = Belt_SetInt.minimum(s);
  return [
    k,
    Belt_SetInt.remove(s, k)
  ];
}

function expandMapItem(acc, size) {
  let free = acc[4];
  let disk = acc[3];
  let fileID = acc[2];
  let pos = acc[1];
  if (acc[0]) {
    let fileExtent = Stdlib__Array.zip(Stdlib__Array.fromInitializer(size, i => pos + i | 0), Stdlib__Array.make(size, fileID));
    let file = Belt_MapInt.fromArray(fileExtent);
    let disk$p = union(disk, file);
    return [
      false,
      pos + size | 0,
      fileID + 1 | 0,
      disk$p,
      free
    ];
  }
  let gap = Belt_SetInt.fromArray(Stdlib__Array.fromInitializer(size, i => pos + i | 0));
  let free$p = Belt_SetInt.union(free, gap);
  return [
    true,
    pos + size | 0,
    fileID,
    disk,
    free$p
  ];
}

function expand(diskMap) {
  let match = Stdlib__Array.reduce(diskMap, [
    true,
    0,
    0,
    undefined,
    undefined
  ], expandMapItem);
  return [
    match[3],
    match[4]
  ];
}

function showDisk(disk) {
  let pMax = Belt_MapInt.maxKey(disk);
  let str = "";
  for (let i = 0; i <= pMax; ++i) {
    let v = Belt_MapInt.get(disk, i);
    let char = v !== undefined ? v.toString() : ".";
    str = str + char;
  }
  return str;
}

function showFree(free) {
  let pMax = Belt_SetInt.maximum(free);
  let str = "";
  for (let i = 0; i <= pMax; ++i) {
    let char = Belt_SetInt.has(free, i) ? "+" : ".";
    str = str + char;
  }
  return str;
}

function showDiskFree(disk, free) {
  return showDisk(disk) + "\n" + showFree(free);
}

function isPackedBlock(disk, free) {
  let dMax = Belt_MapInt.maxKey(disk);
  let fMin = Belt_SetInt.minimum(free);
  return dMax < fMin;
}

function packBlocksStep(disk, free) {
  if (isPackedBlock(disk, free)) {
    return [
      disk,
      free
    ];
  }
  let match = mapDeleteFindMax(disk);
  let match$1 = match[0];
  let match$2 = setDeleteFindMin(free);
  return [
    Belt_MapInt.set(match[1], match$2[0], match$1[1]),
    Belt_SetInt.add(match$2[1], match$1[0])
  ];
}

function packBlocks(disk, free) {
  let _disk = disk;
  let _free = free;
  while (true) {
    let free$1 = _free;
    let disk$1 = _disk;
    if (isPackedBlock(disk$1, free$1)) {
      return [
        disk$1,
        free$1
      ];
    }
    let match = packBlocksStep(disk$1, free$1);
    _free = match[1];
    _disk = match[0];
    continue;
  };
}

function parse(data) {
  return data.trim().split("").map(s => Stdlib__Int.fromString(s, undefined));
}

function solvePart1(data) {
  let diskMap = parse(data);
  let match = expand(diskMap);
  let match$1 = packBlocks(match[0], match[1]);
  let disk$p = match$1[0];
  let prim = showDiskFree(disk$p, match$1[1]);
  console.log(prim);
  let prim$1 = Belt_MapInt.toArray(disk$p);
  console.log(prim$1);
  let __x = Belt_MapInt.toArray(disk$p).map(param => BigInt(param[0]) * BigInt(param[1]));
  return Stdlib__Array.reduce(__x, 0n, (prim0, prim1) => prim0 + prim1);
}

function solvePart2(data) {
  return 2;
}

let M;

let S;

export {
  log,
  log2,
  M,
  S,
  union,
  mapDeleteFindMax,
  setDeleteFindMin,
  expandMapItem,
  expand,
  showDisk,
  showFree,
  showDiskFree,
  isPackedBlock,
  packBlocksStep,
  packBlocks,
  parse,
  solvePart1,
  solvePart2,
}
/* Stdlib__Int Not a pure module */
