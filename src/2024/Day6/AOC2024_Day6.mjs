// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Pervasives from "rescript/lib/es6/Pervasives.js";
import * as Stdlib__Array from "@dsiu/rescript-stdlib-fp/src/Stdlib__Array.mjs";
import * as Stdlib__Option from "@dsiu/rescript-stdlib-fp/src/Stdlib__Option.mjs";
import * as Stdlib__Tuple2 from "@dsiu/rescript-stdlib-fp/src/Stdlib__Tuple2.mjs";
import * as Utils$AdventOfCode from "../../Utils.mjs";
import * as Coord_V2$AdventOfCode from "../../Coord_V2.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function fromArray(arr) {
  return new Map(arr.map((row, i) => row.map((col, j) => [
    Coord_V2$AdventOfCode.toString([
      i,
      j
    ]),
    col
  ])).flat());
}

function findValueWithKey(map, f) {
  return Stdlib__Option.map(Stdlib__Array.find(Array.from(map.entries()), param => f(param[0], param[1])), param => param[0]);
}

function bounds(map) {
  let keys = Array.from(map.keys()).map(Coord_V2$AdventOfCode.fromString);
  let rows = keys.map(Stdlib__Tuple2.first);
  let cols = keys.map(Stdlib__Tuple2.second);
  return [
    [
      Utils$AdventOfCode.minIntInArray(rows),
      Utils$AdventOfCode.minIntInArray(cols)
    ],
    [
      Utils$AdventOfCode.maxIntInArray(rows),
      Utils$AdventOfCode.maxIntInArray(cols)
    ]
  ];
}

function inRange(param, c) {
  let max = param[1];
  let min = param[0];
  let c$1 = c[1];
  let r = c[0];
  if (r >= min[0] && r <= max[0] && c$1 >= min[1]) {
    return c$1 <= max[1];
  } else {
    return false;
  }
}

let CoordMap = {
  fromArray: fromArray,
  findValueWithKey: findValueWithKey,
  bounds: bounds,
  inRange: inRange
};

function fromString(s) {
  switch (s) {
    case "#" :
      return "#";
    case "." :
      return ".";
    case "^" :
      return "^";
    default:
      return Pervasives.failwith("Invalid value");
  }
}

let MapValue = {
  fromString: fromString
};

let up = {
  TAG: "Up",
  _0: [
    -1,
    0
  ]
};

let down = {
  TAG: "Down",
  _0: [
    1,
    0
  ]
};

let left = {
  TAG: "Left",
  _0: [
    0,
    -1
  ]
};

let right = {
  TAG: "Right",
  _0: [
    0,
    1
  ]
};

function turnRight(dir) {
  switch (dir.TAG) {
    case "Up" :
      return right;
    case "Down" :
      return left;
    case "Left" :
      return up;
    case "Right" :
      return down;
  }
}

function step(grid, guard) {
  
}

function walk(grid, guard) {
  return Stdlib__Array.unfoldr(guard, __x => {});
}

function parse(data) {
  return Utils$AdventOfCode.splitNewline(data).map(l => l.trim().split("").map(fromString));
}

function solvePart1(data) {
  let grid = fromArray(parse(data));
  let guard_pos = Stdlib__Option.flatMap(findValueWithKey(grid, (k, v) => v === "^"), Coord_V2$AdventOfCode.fromString);
  let guard = {
    pos: guard_pos,
    dir: up
  };
  let prim = walk(grid, guard);
  console.log(prim);
  return 1;
}

function solvePart2(data) {
  return 2;
}

export {
  log,
  log2,
  CoordMap,
  MapValue,
  up,
  down,
  left,
  right,
  turnRight,
  step,
  walk,
  parse,
  solvePart1,
  solvePart2,
}
/* Stdlib__Array Not a pure module */
