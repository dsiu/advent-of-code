// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Pervasives from "rescript/lib/es6/Pervasives.js";
import * as Stdlib__Array from "@dsiu/rescript-stdlib-fp/src/Stdlib__Array.mjs";
import * as Stdlib__Option from "@dsiu/rescript-stdlib-fp/src/Stdlib__Option.mjs";
import * as Stdlib__Tuple2 from "@dsiu/rescript-stdlib-fp/src/Stdlib__Tuple2.mjs";
import * as Utils$AdventOfCode from "../../Utils.mjs";
import * as Coord_V2$AdventOfCode from "../../Coord_V2.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function fromString(s) {
  switch (s) {
    case "#" :
      return "#";
    case "." :
      return ".";
    case "^" :
      return "^";
    default:
      return Pervasives.failwith("Invalid value");
  }
}

let MapValue = {
  fromString: fromString
};

function bounds(grid) {
  let keys = Array.from(grid.keys()).map(Coord_V2$AdventOfCode.fromString);
  let rows = keys.map(Stdlib__Tuple2.first);
  let cols = keys.map(Stdlib__Tuple2.second);
  return [
    [
      Utils$AdventOfCode.minIntInArray(rows),
      Utils$AdventOfCode.minIntInArray(cols)
    ],
    [
      Utils$AdventOfCode.maxIntInArray(rows),
      Utils$AdventOfCode.maxIntInArray(cols)
    ]
  ];
}

function fromArray(arr) {
  let grid = new Map(arr.map((row, i) => row.map((col, j) => [
    Coord_V2$AdventOfCode.toString([
      i,
      j
    ]),
    col
  ])).flat());
  let bounds$1 = bounds(grid);
  return {
    grid: grid,
    bounds: bounds$1
  };
}

function find(grid, f) {
  return Stdlib__Array.find(Array.from(grid.entries()), param => f(param[0], param[1]));
}

function inRange(param, c) {
  let max = param[1];
  let min = param[0];
  let c$1 = c[1];
  let r = c[0];
  if (r >= min[0] && r <= max[0] && c$1 >= min[1]) {
    return c$1 <= max[1];
  } else {
    return false;
  }
}

function walkAble(grid, c) {
  let y = Stdlib__Option.map(find(grid, (k, v) => k === Coord_V2$AdventOfCode.toString(c)), Stdlib__Tuple2.second);
  if (y !== undefined) {
    return y !== "#";
  } else {
    return true;
  }
}

let CoordMap = {
  bounds: bounds,
  fromArray: fromArray,
  find: find,
  inRange: inRange,
  walkAble: walkAble
};

let up = {
  TAG: "Up",
  _0: [
    -1,
    0
  ]
};

let down = {
  TAG: "Down",
  _0: [
    1,
    0
  ]
};

let left = {
  TAG: "Left",
  _0: [
    0,
    -1
  ]
};

let right = {
  TAG: "Right",
  _0: [
    0,
    1
  ]
};

function delta(dir) {
  return dir._0;
}

function turnRight(dir) {
  switch (dir.TAG) {
    case "Up" :
      return right;
    case "Down" :
      return left;
    case "Left" :
      return up;
    case "Right" :
      return down;
  }
}

function step(param, guard) {
  let bounds = param.bounds;
  let ahead = Coord_V2$AdventOfCode.add(guard.pos, guard.dir._0);
  if (inRange(bounds, guard.pos)) {
    if (!inRange(bounds, ahead) || walkAble(param.grid, ahead)) {
      return [
        guard.pos,
        {
          pos: ahead,
          dir: guard.dir
        }
      ];
    } else {
      return [
        guard.pos,
        {
          pos: guard.pos,
          dir: turnRight(guard.dir)
        }
      ];
    }
  }
  
}

function walk(map, guard) {
  return Stdlib__Array.unfoldr(guard, __x => step(map, __x));
}

function parse(data) {
  return Utils$AdventOfCode.splitNewline(data).map(l => l.trim().split("").map(fromString));
}

function solvePart1(data) {
  let m = fromArray(parse(data));
  let guard_pos = Stdlib__Option.flatMap(Stdlib__Option.map(find(m.grid, (k, v) => v === "^"), param => param[0]), Coord_V2$AdventOfCode.fromString);
  let guard = {
    pos: guard_pos,
    dir: up
  };
  let ret = walk(m, guard);
  return Stdlib__Array.uniq(ret).length;
}

function solvePart2(data) {
  return 2;
}

export {
  log,
  log2,
  MapValue,
  CoordMap,
  up,
  down,
  left,
  right,
  delta,
  turnRight,
  step,
  walk,
  parse,
  solvePart1,
  solvePart2,
}
/* Stdlib__Array Not a pure module */
