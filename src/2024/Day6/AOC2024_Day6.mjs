// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Pervasives from "rescript/lib/es6/Pervasives.js";
import * as Stdlib__Array from "@dsiu/rescript-stdlib-fp/src/Stdlib__Array.mjs";
import * as Stdlib__Option from "@dsiu/rescript-stdlib-fp/src/Stdlib__Option.mjs";
import * as Stdlib__Tuple2 from "@dsiu/rescript-stdlib-fp/src/Stdlib__Tuple2.mjs";
import * as Primitive_object from "rescript/lib/es6/Primitive_object.js";
import * as Stdlib__Function from "@dsiu/rescript-stdlib-fp/src/Stdlib__Function.mjs";
import * as Utils$AdventOfCode from "../../Utils.mjs";
import * as Coord_V2$AdventOfCode from "../../Coord_V2.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function fromString(s) {
  switch (s) {
    case "#" :
      return "#";
    case "." :
      return ".";
    case "^" :
      return "^";
    default:
      return Pervasives.failwith("Invalid value");
  }
}

let MapValue = {
  fromString: fromString
};

function bounds(grid) {
  let keys = Array.from(grid.keys()).map(x => Stdlib__Option.getExn(Coord_V2$AdventOfCode.fromString(x), undefined));
  let rows = keys.map(Stdlib__Tuple2.first);
  let cols = keys.map(Stdlib__Tuple2.second);
  return [
    [
      Utils$AdventOfCode.minIntInArray(rows),
      Utils$AdventOfCode.minIntInArray(cols)
    ],
    [
      Utils$AdventOfCode.maxIntInArray(rows),
      Utils$AdventOfCode.maxIntInArray(cols)
    ]
  ];
}

function fromArray(arr) {
  let grid = new Map(arr.map((row, i) => row.map((col, j) => [
    Coord_V2$AdventOfCode.toString([
      i,
      j
    ]),
    col
  ])).flat());
  let bounds$1 = bounds(grid);
  return {
    grid: grid,
    bounds: bounds$1
  };
}

function find(grid, f) {
  return Array.from(grid.entries()).find(param => f(param[0], param[1]));
}

function clone(__x) {
  return Stdlib__Function.compose(prim => prim.entries(), prim => new Map(prim), __x);
}

function inRange(param, c) {
  let max = param[1];
  let min = param[0];
  let c$1 = c[1];
  let r = c[0];
  if (r >= min[0] && r <= max[0] && c$1 >= min[1]) {
    return c$1 <= max[1];
  } else {
    return false;
  }
}

function toString(grid) {
  let bounds$1 = bounds(grid);
  let match = bounds$1[1];
  let maxC = match[1];
  let match$1 = bounds$1[0];
  let minC = match$1[1];
  let minR = match$1[0];
  let rows = Stdlib__Array.fromInitializer((match[0] - minR | 0) + 1 | 0, i => {
    let cols = Stdlib__Array.fromInitializer((maxC - minC | 0) + 1 | 0, j => {
      let c_0 = i + minR | 0;
      let c_1 = j + minC | 0;
      let c = [
        c_0,
        c_1
      ];
      return String(Stdlib__Option.getExn(grid.get(Coord_V2$AdventOfCode.toString(c)), undefined));
    });
    return cols.join("");
  });
  return rows.join("\n");
}

function walkAble(grid, c) {
  let y = grid.get(Coord_V2$AdventOfCode.toString(c));
  if (y !== undefined) {
    return y !== "#";
  } else {
    return true;
  }
}

let CoordMap = {
  bounds: bounds,
  fromArray: fromArray,
  find: find,
  clone: clone,
  inRange: inRange,
  toString: toString,
  walkAble: walkAble
};

let up = {
  TAG: "Up",
  _0: [
    -1,
    0
  ]
};

let down = {
  TAG: "Down",
  _0: [
    1,
    0
  ]
};

let left = {
  TAG: "Left",
  _0: [
    0,
    -1
  ]
};

let right = {
  TAG: "Right",
  _0: [
    0,
    1
  ]
};

function delta(dir) {
  return dir._0;
}

function turnRight(dir) {
  switch (dir.TAG) {
    case "Up" :
      return right;
    case "Down" :
      return left;
    case "Left" :
      return up;
    case "Right" :
      return down;
  }
}

function dirEq(a, b) {
  switch (a.TAG) {
    case "Up" :
      return b.TAG === "Up";
    case "Down" :
      return b.TAG === "Down";
    case "Left" :
      return b.TAG === "Left";
    case "Right" :
      return b.TAG === "Right";
  }
}

function guardEq(a, b) {
  if (Coord_V2$AdventOfCode.compare(a.pos, b.pos) === 0) {
    return dirEq(a.dir, b.dir);
  } else {
    return false;
  }
}

function step(param, guard) {
  let bounds = param.bounds;
  let ahead = Coord_V2$AdventOfCode.add(guard.pos, guard.dir._0);
  if (inRange(bounds, guard.pos)) {
    if (!inRange(bounds, ahead) || walkAble(param.grid, ahead)) {
      return [
        guard.pos,
        {
          pos: ahead,
          dir: guard.dir
        }
      ];
    } else {
      return [
        guard.pos,
        {
          pos: guard.pos,
          dir: turnRight(guard.dir)
        }
      ];
    }
  }
  
}

function walk(map, guard) {
  return Stdlib__Array.unfoldr(guard, __x => step(map, __x));
}

function isLoop(_guard, _trail, map) {
  while (true) {
    let trail = _trail;
    let guard = _guard;
    let stepped = step(map, guard);
    if (Stdlib__Option.isNone(stepped)) {
      return false;
    }
    let match = Stdlib__Option.getExn(stepped, undefined);
    let guard$p = match[1];
    let hasTurned = Primitive_object.notequal(guard.dir, guard$p.dir);
    let beenThere = Stdlib__Option.isSome(trail.find(__x => guardEq(guard, __x)));
    if (hasTurned && beenThere) {
      return true;
    }
    if (hasTurned) {
      _trail = Belt_Array.concatMany([
        [guard],
        trail
      ]);
      _guard = guard$p;
      continue;
    }
    _guard = guard$p;
    continue;
  };
}

function parse(data) {
  return Utils$AdventOfCode.splitNewline(data).map(l => l.trim().split("").map(fromString));
}

function init(data) {
  let m = fromArray(parse(data));
  let guard_pos = Stdlib__Option.getExn(Stdlib__Option.flatMap(Stdlib__Option.map(find(m.grid, (_k, v) => v === "^"), param => param[0]), Coord_V2$AdventOfCode.fromString), undefined);
  let guard = {
    pos: guard_pos,
    dir: up
  };
  return [
    m,
    guard
  ];
}

function solvePart1(data) {
  let match = init(data);
  return Stdlib__Array.uniq(walk(match[0], match[1])).length;
}

function solvePart2(data) {
  let match = init(data);
  let m = match[0];
  let bounds = m.bounds;
  let grid = m.grid;
  let guard = match[1];
  let news = Stdlib__Array.uniq(walk(m, guard)).filter(x => Coord_V2$AdventOfCode.compare(x, guard.pos) !== 0);
  return news.filter(g => {
    let m$p = clone(grid);
    m$p.set(Coord_V2$AdventOfCode.toString(g), "#");
    return isLoop(guard, [], {
      grid: m$p,
      bounds: bounds
    });
  }).length;
}

export {
  log,
  log2,
  MapValue,
  CoordMap,
  up,
  down,
  left,
  right,
  delta,
  turnRight,
  dirEq,
  guardEq,
  step,
  walk,
  isLoop,
  parse,
  init,
  solvePart1,
  solvePart2,
}
/* Stdlib__Array Not a pure module */
