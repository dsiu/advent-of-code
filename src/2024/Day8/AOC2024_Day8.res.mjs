// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Utils from "../../Utils.res.mjs";
import * as Coord_V2 from "../../Coord_V2.res.mjs";
import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Stdlib__Array from "@dsiu/rescript-stdlib-fp/src/Stdlib__Array.res.mjs";
import * as Stdlib__Option from "@dsiu/rescript-stdlib-fp/src/Stdlib__Option.res.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function getWithDefault(m, k, d) {
  return Stdlib__Option.getOr(m.get(k), d);
}

function inRange(param, c) {
  let max = param[1];
  let min = param[0];
  let c$1 = c[1];
  let r = c[0];
  if (r >= min[0] && r <= max[0] && c$1 >= min[1]) {
    return c$1 <= max[1];
  } else {
    return false;
  }
}

function antinodeOfNode(a, b) {
  return Coord_V2.sub(Coord_V2.mul(a, 2), b);
}

function antinodesOf(bounds, ps) {
  return Stdlib__Array.combinationIf2(ps, ps, (a, b) => {
    let match = Coord_V2.compare(a, b);
    if (match !== 0) {
      return antinodeOfNode(a, b);
    }
    
  }).filter(p => inRange(bounds, p));
}

function allFreqAntinodes(bounds, grid) {
  return Array.from(grid.values()).flatMap(ps => antinodesOf(bounds, ps));
}

function harmonicAntinodesOfNode(bounds, a, b) {
  return Stdlib__Array.fromInitializer(bounds[1][0], k => Coord_V2.sub(a, Coord_V2.mul(Coord_V2.sub(a, b), k)));
}

function harmonicAntinodesOf(bounds, ps) {
  return Stdlib__Array.combinationIf2(ps, ps, (a, b) => {
    let match = Coord_V2.compare(a, b);
    if (match !== 0) {
      return harmonicAntinodesOfNode(bounds, a, b);
    }
    
  }).flatMap(x => x).filter(p => inRange(bounds, p));
}

function allFreqHarmonicAntinodes(bounds, grid) {
  return Array.from(grid.values()).flatMap(ps => harmonicAntinodesOf(bounds, ps));
}

function parse(data) {
  let rows = Utils.splitNewline(data).map(r => r.trim().split(""));
  let rMax = rows.length - 1 | 0;
  let cMax = Stdlib__Option.getExn(Stdlib__Option.map(rows[0], prim => prim.length), undefined) - 1 | 0;
  let grid = Stdlib__Array.reduce(rows.flatMap((row, r) => Stdlib__Array.keepSome(row.map((elem, c) => {
    if (elem === ".") {
      return;
    } else {
      return [
        elem,
        [
          r,
          c
        ]
      ];
    }
  }))), new Map(), (m, param) => {
    let elem = param[0];
    m.set(elem, Belt_Array.concatMany([
      [param[1]],
      getWithDefault(m, elem, [])
    ]));
    return m;
  });
  return [
    grid,
    [
      [
        0,
        0
      ],
      [
        rMax,
        cMax
      ]
    ]
  ];
}

function solvePart1(data) {
  let match = parse(data);
  return Stdlib__Array.uniq(allFreqAntinodes(match[1], match[0])).length;
}

function solvePart2(data) {
  let match = parse(data);
  return Stdlib__Array.uniq(allFreqHarmonicAntinodes(match[1], match[0])).length;
}

export {
  log,
  log2,
  getWithDefault,
  inRange,
  antinodeOfNode,
  antinodesOf,
  allFreqAntinodes,
  harmonicAntinodesOfNode,
  harmonicAntinodesOf,
  allFreqHarmonicAntinodes,
  parse,
  solvePart1,
  solvePart2,
}
/* Utils Not a pure module */
