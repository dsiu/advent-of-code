// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Utils$AdventOfCode from "../../Utils.mjs";
import * as Array2D$AdventOfCode from "../../Array2D.mjs";
import * as Coordinate$AdventOfCode from "../../Coordinate.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function pointExtensions(c, n) {
  let directions = [
    Coordinate$AdventOfCode.StepFunctions.stepNW,
    Coordinate$AdventOfCode.StepFunctions.stepN,
    Coordinate$AdventOfCode.StepFunctions.stepNE,
    Coordinate$AdventOfCode.StepFunctions.stepW,
    Coordinate$AdventOfCode.StepFunctions.stepE,
    Coordinate$AdventOfCode.StepFunctions.stepSW,
    Coordinate$AdventOfCode.StepFunctions.stepS,
    Coordinate$AdventOfCode.StepFunctions.stepSE
  ];
  return directions.map(f => {
    let _acc = [c];
    let _cur = c;
    let _i = 0;
    while (true) {
      let i = _i;
      let cur = _cur;
      let acc = _acc;
      let next = f(cur);
      if (i >= (n - 1 | 0)) {
        return acc;
      }
      _i = i + 1 | 0;
      _cur = next;
      _acc = Belt_Array.concatMany([
        acc,
        [next]
      ]);
      continue;
    };
  });
}

function xExtensions(c) {
  let directions = [
    Coordinate$AdventOfCode.StepFunctions.stepNW,
    Coordinate$AdventOfCode.StepFunctions.stepNE,
    Coordinate$AdventOfCode.StepFunctions.stepSW,
    Coordinate$AdventOfCode.StepFunctions.stepSE
  ];
  return [Belt_Array.concatMany([
      [c],
      directions.map(f => f(c))
    ])];
}

function potentialWords(exts, grid) {
  return Array2D$AdventOfCode.reduceWithIndex(grid, [], (acc, param, pos) => Belt_Array.concatMany([
    acc,
    exts(pos)
  ]));
}

function validWords(words, grid) {
  return words.filter(word => word.map(c => Array2D$AdventOfCode.isValidXY(grid, c)).every(x => x));
}

function foundWords(words, grid) {
  return words.map(word => word.map(c => Array2D$AdventOfCode.getExn(grid, c)).join(""));
}

function isXmas(word) {
  switch (word) {
    case "AMMSS" :
    case "AMSMS" :
    case "ASMSM" :
    case "ASSMM" :
      return true;
    default:
      return false;
  }
}

function part1(grid, word) {
  let len = word.length;
  return foundWords(validWords(potentialWords(__x => pointExtensions(__x, len), grid), grid), grid).filter(w => w === word).length;
}

function part2(grid) {
  return foundWords(validWords(potentialWords(xExtensions, grid), grid), grid).filter(isXmas).length;
}

function parse(data) {
  return Utils$AdventOfCode.splitNewline(data).map(x => x.trim().split(""));
}

function solvePart1(data) {
  return part1(parse(data), "XMAS");
}

function solvePart2(data) {
  return part2(parse(data));
}

export {
  log,
  log2,
  pointExtensions,
  xExtensions,
  potentialWords,
  validWords,
  foundWords,
  isXmas,
  part1,
  part2,
  parse,
  solvePart1,
  solvePart2,
}
/* Utils-AdventOfCode Not a pure module */
