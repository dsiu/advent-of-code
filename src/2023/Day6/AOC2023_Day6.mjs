// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Stdlib__Int from "@dsiu/rescript-stdlib-fp/src/Stdlib__Int.mjs";
import * as Stdlib__List from "@dsiu/rescript-stdlib-fp/src/Stdlib__List.mjs";
import * as Stdlib__Array from "@dsiu/rescript-stdlib-fp/src/Stdlib__Array.mjs";
import * as Stdlib__Option from "@dsiu/rescript-stdlib-fp/src/Stdlib__Option.mjs";
import * as Stdlib__Result from "@dsiu/rescript-stdlib-fp/src/Stdlib__Result.mjs";
import * as Stdlib__String from "@dsiu/rescript-stdlib-fp/src/Stdlib__String.mjs";
import * as Stdlib__Function from "@dsiu/rescript-stdlib-fp/src/Stdlib__Function.mjs";
import * as ReludeParse_Parser from "relude-parse/src/ReludeParse_Parser.mjs";
import * as Utils$AdventOfCode from "../../Utils.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function mkRaceFromInt(time, distance) {
  return {
          time: BigInt(time),
          distance: BigInt(distance)
        };
}

function raceToString(param) {
  return "(time: " + param.time.toString() + ", distance: " + param.distance.toString() + ")";
}

function raceListToString(__x) {
  return Curry._2(Utils$AdventOfCode.Printable.List.toString, __x, raceToString);
}

function raceArrayToString(__x) {
  return Curry._2(Utils$AdventOfCode.Printable.$$Array.toString, __x, raceToString);
}

function fromInitializer(length, f) {
  if (Caml_obj.lessequal(length, BigInt(0))) {
    return [];
  }
  var arr = new Array(length);
  var init = BigInt(0);
  var end = length - BigInt(1);
  var i = init;
  while(Caml_obj.lessequal(i, end)) {
    arr[i] = f(i);
    i = i + BigInt(1);
  };
  return arr;
}

var BigArray = {
  fromInitializer: fromInitializer
};

function waysToWin(param) {
  var distance = param.distance;
  var time = param.time;
  var h = fromInitializer(time - BigInt(1), (function (i) {
          return i + BigInt(1);
        }));
  return Stdlib__Array.filterMap(h, (function (h) {
                var d = (time - h) * h;
                if (Caml_obj.greaterthan(d, distance)) {
                  return Caml_option.some(d);
                }
                
              })).length;
}

function part1(races) {
  return Stdlib__Array.fold(Stdlib__Array.map(races, waysToWin), 1, Stdlib__Int.multiply);
}

function part2(races) {
  var r$p = Stdlib__Array.fold(races, [
        "",
        ""
      ], (function (param, param$1) {
          return [
                  param[0] + param$1.time.toString(),
                  param[1] + param$1.distance.toString()
                ];
        }));
  return waysToWin({
              time: BigInt(r$p[0]),
              distance: BigInt(r$p[1])
            });
}

var justSpaceP = Curry._1(ReludeParse_Parser.$$void, ReludeParse_Parser.many(ReludeParse_Parser.str(" ")));

var numbersP = ReludeParse_Parser.sepBy(justSpaceP, ReludeParse_Parser.anyInt);

var timesP = Curry._2(ReludeParse_Parser.Infix.$star$great, Curry._2(ReludeParse_Parser.Infix.$star$great, ReludeParse_Parser.str("Time:"), justSpaceP), numbersP);

var distancesP = Curry._2(ReludeParse_Parser.Infix.$star$great, Curry._2(ReludeParse_Parser.Infix.$star$great, Curry._2(ReludeParse_Parser.Infix.$star$great, justSpaceP, ReludeParse_Parser.str("Distance:")), justSpaceP), numbersP);

function mkRace(a, b) {
  return Stdlib__List.map2(a, b, (function (time, distance) {
                return mkRaceFromInt(time, distance);
              }));
}

var racesP = Curry._2(ReludeParse_Parser.Infix.$less$star$great, Curry._2(ReludeParse_Parser.Infix.$less$$great, mkRace, Curry._2(ReludeParse_Parser.Infix.$less$star, timesP, ReludeParse_Parser.eol)), distancesP);

function run(str) {
  return Stdlib__List.toArray(Stdlib__Result.getExn(ReludeParse_Parser.runParser(str, racesP)));
}

var SheetParser = {
  P: undefined,
  justSpaceP: justSpaceP,
  debug: ReludeParse_Parser.tapLog,
  numbersP: numbersP,
  timesP: timesP,
  distancesP: distancesP,
  mkRace: mkRace,
  racesP: racesP,
  run: run
};

function parse(data) {
  var lines = Stdlib__Array.map(Utils$AdventOfCode.splitNewline(data), (function (prim) {
          return prim.trim();
        }));
  var parseLine = function (line, prefix) {
    return Stdlib__Option.getExn(Stdlib__Option.map(line, (function (s) {
                      var partial_arg = function (eta) {
                        return Stdlib__Int.fromString(undefined, eta);
                      };
                      return Stdlib__Array.map(Stdlib__Array.filter(Utils$AdventOfCode.splitSpace(s.replace(prefix, "")), (function (param) {
                                        return Stdlib__Function.complement(Stdlib__String.isEmpty, param);
                                      })), (function (param) {
                                    return Stdlib__Function.compose(partial_arg, (function (prim) {
                                                  return prim;
                                                }), param);
                                  }));
                    })));
  };
  var times = parseLine(lines[0], "Time:");
  var distances = parseLine(lines[1], "Distance:");
  return Stdlib__Array.map2(times, distances, (function (time, distance) {
                return mkRaceFromInt(time, distance);
              }));
}

function solvePart1(data) {
  return part1(run(data));
}

function solvePart2(data) {
  console.warn("MUST use bigger heap to run.  try `node index.js --max-old-space-size=8192` (8GB of heap) or `export NODE_OPTIONS=--max-old-space-size=8192\n");
  return part2(run(data));
}

export {
  log ,
  log2 ,
  mkRaceFromInt ,
  raceToString ,
  raceListToString ,
  raceArrayToString ,
  BigArray ,
  waysToWin ,
  part1 ,
  part2 ,
  SheetParser ,
  parse ,
  solvePart1 ,
  solvePart2 ,
}
/* justSpaceP Not a pure module */
