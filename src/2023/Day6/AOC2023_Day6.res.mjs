// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Utils from "../../Utils.res.mjs";
import * as Stdlib__Int from "@dsiu/rescript-stdlib-fp/src/Stdlib__Int.res.mjs";
import * as Stdlib__List from "@dsiu/rescript-stdlib-fp/src/Stdlib__List.res.mjs";
import * as Stdlib__Array from "@dsiu/rescript-stdlib-fp/src/Stdlib__Array.res.mjs";
import * as Stdlib__Float from "@dsiu/rescript-stdlib-fp/src/Stdlib__Float.res.mjs";
import * as Stdlib__Option from "@dsiu/rescript-stdlib-fp/src/Stdlib__Option.res.mjs";
import * as Stdlib__Result from "@dsiu/rescript-stdlib-fp/src/Stdlib__Result.res.mjs";
import * as Stdlib__String from "@dsiu/rescript-stdlib-fp/src/Stdlib__String.res.mjs";
import * as Stdlib__Function from "@dsiu/rescript-stdlib-fp/src/Stdlib__Function.res.mjs";
import * as ReludeParse_Parser from "rescript-relude-parse/src/ReludeParse_Parser.res.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function mkRaceFromInt(time, distance) {
  return {
    time: BigInt(time),
    distance: BigInt(distance)
  };
}

function raceToString(param) {
  return "(time: " + param.time.toString() + ", distance: " + param.distance.toString() + ")";
}

function raceListToString(__x) {
  return Utils.Printable.List.toString(__x, raceToString);
}

function raceArrayToString(__x) {
  return Utils.Printable.$$Array.toString(__x, raceToString);
}

function fromInitializer(length, f) {
  if (length <= BigInt(0)) {
    return [];
  }
  let arr = new Array(length);
  let init = BigInt(0);
  let end = length - BigInt(1);
  let i = init;
  while (i <= end) {
    arr[i] = f(i);
    i = i + BigInt(1);
  };
  return arr;
}

let BigArray = {
  fromInitializer: fromInitializer
};

function waysToWinBurteForce(param) {
  let distance = param.distance;
  let time = param.time;
  let h = fromInitializer(time - BigInt(1), i => i + BigInt(1));
  return Stdlib__Array.filterMap(h, h => {
    let d = (time - h) * h;
    if (d > distance) {
      return d;
    }
    
  }).length;
}

function waysToWin(param) {
  let t = Number(param.time);
  let d = Number(param.distance);
  let a = (t - Math.sqrt(Math.pow(t, 2) - 4 * d)) / 2;
  let b = (t + Math.sqrt(Math.pow(t, 2) - 4 * d)) / 2;
  let a$1 = Stdlib__Float.isInteger(a) ? a + 1 : Math.ceil(a);
  let b$1 = Stdlib__Float.isInteger(b) ? b - 1 : Math.floor(b);
  return b$1 - a$1 + 1 | 0;
}

function part1(races) {
  return Stdlib__Array.fold(races.map(waysToWin), 1, Stdlib__Int.multiply);
}

function part2(races) {
  let r$p = Stdlib__Array.fold(races, [
    "",
    ""
  ], (param, param$1) => [
    param[0] + param$1.time.toString(),
    param[1] + param$1.distance.toString()
  ]);
  return waysToWin({
    time: BigInt(r$p[0]),
    distance: BigInt(r$p[1])
  });
}

let justSpaceP = ReludeParse_Parser.$$void(ReludeParse_Parser.many(ReludeParse_Parser.str(" ")));

let numbersP = ReludeParse_Parser.sepBy(justSpaceP, ReludeParse_Parser.anyInt);

let timesP = ReludeParse_Parser.Infix.$star$great(ReludeParse_Parser.Infix.$star$great(ReludeParse_Parser.str("Time:"), justSpaceP), numbersP);

let distancesP = ReludeParse_Parser.Infix.$star$great(ReludeParse_Parser.Infix.$star$great(ReludeParse_Parser.Infix.$star$great(justSpaceP, ReludeParse_Parser.str("Distance:")), justSpaceP), numbersP);

function mkRace(a) {
  return b => Stdlib__List.map2(a, b, mkRaceFromInt);
}

let racesP = ReludeParse_Parser.Infix.$less$star$great(ReludeParse_Parser.Infix.$less$$great(mkRace, ReludeParse_Parser.Infix.$less$star(timesP, ReludeParse_Parser.eol)), distancesP);

function run(str) {
  return Stdlib__List.toArray(Stdlib__Result.getExn(ReludeParse_Parser.runParser(str, racesP)));
}

let SheetParser = {
  P: undefined,
  justSpaceP: justSpaceP,
  debug: ReludeParse_Parser.tapLog,
  numbersP: numbersP,
  timesP: timesP,
  distancesP: distancesP,
  mkRace: mkRace,
  racesP: racesP,
  run: run
};

function parse(data) {
  let lines = Utils.splitNewline(data).map(prim => prim.trim());
  let parseLine = (line, prefix) => Stdlib__Option.getExn(Stdlib__Option.map(line, s => Utils.splitSpace(s.replace(prefix, "")).filter(extra => Stdlib__Function.complement(Stdlib__String.isEmpty, extra)).map(Utils.intFromStringExn)), undefined);
  let times = parseLine(lines[0], "Time:");
  let distances = parseLine(lines[1], "Distance:");
  return Stdlib__Array.map2(times, distances, mkRaceFromInt);
}

function solvePart1(data) {
  return part1(run(data));
}

function solvePart2(data) {
  console.warn("MUST use bigger heap to run.  try `node index.js --max-old-space-size=8192` (8GB of heap) or `export NODE_OPTIONS=--max-old-space-size=8192\n");
  return part2(run(data));
}

export {
  log,
  log2,
  mkRaceFromInt,
  raceToString,
  raceListToString,
  raceArrayToString,
  BigArray,
  waysToWinBurteForce,
  waysToWin,
  part1,
  part2,
  SheetParser,
  parse,
  solvePart1,
  solvePart2,
}
/* justSpaceP Not a pure module */
