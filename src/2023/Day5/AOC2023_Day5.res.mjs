// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Utils from "../../Utils.res.mjs";
import * as Interval from "../../Interval.res.mjs";
import * as Stdlib__Array from "@dsiu/rescript-stdlib-fp/src/Stdlib__Array.res.mjs";
import * as Stdlib__Option from "@dsiu/rescript-stdlib-fp/src/Stdlib__Option.res.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function toString(t) {
  return "Rule(Src:" + Interval.toString(t.srcInterval) + ", Dest:" + t.dest.toString() + ", Offset:" + t.offset.toString() + ")";
}

function run(t, srcNum) {
  if (Interval.contains(t.srcInterval, srcNum)) {
    return srcNum + t.offset;
  }
  
}

function runWithInterval(t, src) {
  let intersection = Interval.intersect(src, t.srcInterval);
  let newSrc = Stdlib__Option.getOr(Stdlib__Option.map(intersection, i => Interval.remove(src, i)), src);
  let newDest = Stdlib__Option.map(intersection, i => Interval.add(i, t.offset));
  return [
    newSrc,
    newDest
  ];
}

let Rule = {
  toString: toString,
  run: run,
  runWithInterval: runWithInterval
};

function toString$1(t) {
  return "AlmanacMap(" + t.srcCategory + ", " + t.destCategory + ", [" + t.rules.map(toString).join(", ") + "])";
}

function runRules(t, srcNum) {
  return Stdlib__Option.getOr(Stdlib__Array.findMap(t.rules, __x => run(__x, srcNum)), srcNum);
}

function runRulesWithInterval(t, src) {
  return Stdlib__Array.reduce(t.rules, [
    src,
    []
  ], (param, r) => {
    let d = param[1];
    let s = param[0];
    if (s === undefined) {
      return [
        undefined,
        d
      ];
    }
    let match = runWithInterval(r, s);
    let dest = match[1];
    let newDest = dest !== undefined ? [dest].concat(d) : d;
    return [
      match[0],
      newDest
    ];
  });
}

function runRulesWithMultiIntervals(t, xs) {
  return xs.flatMap(x => {
    let match = runRulesWithInterval(t, x);
    let newSrc = Stdlib__Option.getOr(Stdlib__Option.flatMap(match[0], s => [s]), []);
    return newSrc.concat(match[1]);
  });
}

let AlmanacMap = {
  toString: toString$1,
  runRules: runRules,
  runRulesWithInterval: runRulesWithInterval,
  runRulesWithMultiIntervals: runRulesWithMultiIntervals
};

function toString$2(t) {
  return "Almanac (Seeds: [" + t.seeds.map(__x => __x.toString()).join(", ") + "],\n[" + t.maps.map(toString$1).join("\n") + ")]";
}

function getMap(t, src) {
  return Stdlib__Option.getExn(t.maps.find(m => m.srcCategory === src), undefined);
}

let Almanac = {
  toString: toString$2,
  getMap: getMap
};

function parse(data) {
  let lines = Utils.splitDoubleNewline(data).map(l => Utils.splitNewline(l).map(prim => prim.trim()));
  let seedLine = Stdlib__Option.getExn(Stdlib__Option.flatMap(lines[0], __x => __x[0]), undefined);
  let mapLines = lines.slice(1);
  let parseSeed = line => Utils.splitSpace(Stdlib__Option.getExn(line.split(": ")[1], undefined)).map(prim => BigInt(prim));
  let parseMap = lines => {
    let categoryLine = Stdlib__Option.getExn(lines[0], undefined);
    let srcDestLines = lines.slice(1);
    let match = Stdlib__Option.getExn(Stdlib__Option.flatMap(Utils.splitSpace(categoryLine)[0], s => s.split("-to-")), undefined);
    if (match.length !== 2) {
      throw {
        RE_EXN_ID: "Match_failure",
        _1: [
          "AOC2023_Day5.res",
          186,
          8
        ],
        Error: new Error()
      };
    }
    let srcCategory = match[0];
    let destCategory = match[1];
    let parseIntervalLine = l => {
      let match = Utils.splitSpace(l).map(prim => BigInt(prim));
      if (match.length !== 3) {
        throw {
          RE_EXN_ID: "Match_failure",
          _1: [
            "AOC2023_Day5.res",
            194,
            10
          ],
          Error: new Error()
        };
      }
      let destStart = match[0];
      let srcStart = match[1];
      let len = match[2];
      let one = BigInt(1);
      return {
        srcInterval: Interval.make(srcStart, srcStart + len - one),
        dest: destStart,
        offset: destStart - srcStart
      };
    };
    let rules = srcDestLines.map(parseIntervalLine);
    return {
      srcCategory: srcCategory,
      destCategory: destCategory,
      rules: rules
    };
  };
  let seeds = parseSeed(seedLine);
  let maps = mapLines.map(parseMap);
  return {
    seeds: seeds,
    maps: maps
  };
}

function part1_simple(almanac) {
  let locations = almanac.seeds.map(s => {
    let endCat = "location";
    let _curCat = "seed";
    let _curNum = s;
    while (true) {
      let curNum = _curNum;
      let curCat = _curCat;
      let map = getMap(almanac, curCat);
      let destCategory = map.destCategory;
      let nextNum = runRules(map, curNum);
      if (destCategory === endCat) {
        return nextNum;
      }
      _curNum = nextNum;
      _curCat = destCategory;
      continue;
    };
  });
  console.log(locations);
  return Utils.minBigIntInArray(locations);
}

function findLocation(almanac, seedTransform) {
  let newSeeds = seedTransform(almanac.seeds);
  let locations = newSeeds.flatMap(s => {
    let endCat = "location";
    let _curCat = "seed";
    let _cur = [s];
    while (true) {
      let cur = _cur;
      let curCat = _curCat;
      let map = getMap(almanac, curCat);
      let destCategory = map.destCategory;
      let next = runRulesWithMultiIntervals(map, cur);
      if (destCategory === endCat) {
        return next;
      }
      _cur = next;
      _curCat = destCategory;
      continue;
    };
  });
  return Utils.minBigIntInArray(locations.map(param => param[0]));
}

function makeSeedsInterval(seeds) {
  return seeds.map(__x => Interval.makeWithLength(__x, BigInt(1)));
}

function makeSeedsPair(seeds) {
  return seeds.map((a, i) => {
    if (i % 2 !== 0) {
      return;
    }
    let b = Stdlib__Option.getExn(seeds[i + 1 | 0], undefined);
    return Interval.makeWithLength(a, b);
  }).filter(Stdlib__Option.isSome).map(__x => Stdlib__Option.getExn(__x, undefined));
}

function part1(__x) {
  return findLocation(__x, makeSeedsInterval);
}

function part2(__x) {
  return findLocation(__x, makeSeedsPair);
}

function solvePart1(data) {
  return findLocation(parse(data), makeSeedsInterval);
}

function solvePart2(data) {
  return findLocation(parse(data), makeSeedsPair);
}

export {
  log,
  log2,
  Rule,
  AlmanacMap,
  Almanac,
  parse,
  part1_simple,
  findLocation,
  makeSeedsInterval,
  makeSeedsPair,
  part1,
  part2,
  solvePart1,
  solvePart2,
}
/* Utils Not a pure module */
