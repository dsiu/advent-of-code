// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.mjs";
import * as Utils$AdventOfCode from "../../Utils.mjs";
import * as Interval$AdventOfCode from "../../Interval.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function toString(t) {
  return "SrcDestInterval(Src:" + Interval$AdventOfCode.toString(t.srcInterval) + ", Dest:" + t.dest.toString() + ", Offset:" + t.offset.toString() + ")";
}

function srcToDest(t, srcNum) {
  if (Interval$AdventOfCode.contains(t.srcInterval, srcNum)) {
    return Caml_option.some(srcNum + t.offset);
  }
  
}

function srcToDestInterval(t, src) {
  return Core__Array.reduce(src, [], (function (acc, s) {
                var match = Interval$AdventOfCode.intersect(s, t.srcInterval);
                if (match !== undefined) {
                  return [[
                              match[0] + t.offset,
                              match[1] + t.offset
                            ]].concat(acc);
                } else {
                  return acc;
                }
              }));
}

var IntervalMap = {
  toString: toString,
  srcToDest: srcToDest,
  srcToDestInterval: srcToDestInterval
};

function toString$1(t) {
  return "AlmanacMap(" + t.srcCategory + ", " + t.destCategory + ", " + t.intervals.map(toString).join(", ") + ")";
}

function srcToDest$1(t, srcNum) {
  return Core__Option.getOr(Core__Array.findMap(t.intervals, (function (r) {
                    return srcToDest(r, srcNum);
                  })), srcNum);
}

function srcToDestInterval$1(t, src) {
  return Core__Array.reduce(t.intervals, [], (function (acc, s) {
                return srcToDestInterval(s, src).concat(acc);
              }));
}

var AlmanacMap = {
  toString: toString$1,
  srcToDest: srcToDest$1,
  srcToDestInterval: srcToDestInterval$1
};

function toString$2(t) {
  return "Almanac (Seeds: " + t.seeds.map(Interval$AdventOfCode.toString).join(", ") + "\n" + t.maps.map(toString$1).join("\n") + ")";
}

function getMap(t, src) {
  return Core__Option.getExn(t.maps.find(function (m) {
                  return m.srcCategory === src;
                }));
}

var Almanac = {
  toString: toString$2,
  getMap: getMap
};

function parse(data) {
  var lines = Utils$AdventOfCode.splitDoubleNewline(data).map(function (l) {
        return Utils$AdventOfCode.splitNewline(l).map(function (prim) {
                    return prim.trim();
                  });
      });
  var seedLine = Core__Option.getExn(Core__Option.flatMap(lines[0], (function (__x) {
              return __x[0];
            })));
  var mapLines = (function (__x) {
        return __x.slice(1);
      })(lines);
  var parseSeed = function (line) {
    return Utils$AdventOfCode.splitSpace(Core__Option.getExn(line.split(": ")[1])).map(function (prim) {
                return BigInt(prim);
              });
  };
  var parseMap = function (lines) {
    var categoryLine = Core__Option.getExn(lines[0]);
    var srcDestLines = lines.slice(1);
    var match = Core__Option.getExn(Core__Option.flatMap(Utils$AdventOfCode.splitSpace(categoryLine)[0], (function (s) {
                return (function (__x) {
                            return __x.split("-to-");
                          })(s);
              })));
    if (match.length !== 2) {
      throw {
            RE_EXN_ID: "Match_failure",
            _1: [
              "AOC2023_Day5.res",
              102,
              8
            ],
            Error: new Error()
          };
    }
    var srcCategory = match[0];
    var destCategory = match[1];
    var parseIntervalLine = function (l) {
      var match = Utils$AdventOfCode.splitSpace(l).map(function (prim) {
            return BigInt(prim);
          });
      if (match.length !== 3) {
        throw {
              RE_EXN_ID: "Match_failure",
              _1: [
                "AOC2023_Day5.res",
                110,
                10
              ],
              Error: new Error()
            };
      }
      var destStart = match[0];
      var srcStart = match[1];
      var len = match[2];
      var one = BigInt(1);
      return {
              srcInterval: Interval$AdventOfCode.make(srcStart, srcStart + len - one),
              dest: destStart,
              offset: destStart - srcStart
            };
    };
    var intervals = srcDestLines.map(parseIntervalLine);
    return {
            srcCategory: srcCategory,
            destCategory: destCategory,
            intervals: intervals
          };
  };
  var makeSeedsInterval = function (seeds) {
    return seeds.map(function (s) {
                return Interval$AdventOfCode.makeWithLength(s, BigInt(1));
              });
  };
  var seeds = makeSeedsInterval(parseSeed(seedLine));
  var maps = mapLines.map(parseMap);
  return {
          seeds: seeds,
          maps: maps
        };
}

function part1(almanac) {
  var locations = almanac.seeds.map(function (param) {
        var endCat = "location";
        var _curCat = "seed";
        var _curNum = param[0];
        while(true) {
          var curNum = _curNum;
          var curCat = _curCat;
          var map = getMap(almanac, curCat);
          var destCategory = map.destCategory;
          var nextNum = srcToDest$1(map, curNum);
          if (destCategory === endCat) {
            return nextNum;
          }
          _curNum = nextNum;
          _curCat = destCategory;
          continue ;
        };
      });
  console.log(locations);
  return Utils$AdventOfCode.minBigIntInArray(locations);
}

function solvePart1(data) {
  var almanac = parse(data);
  var prim = toString$2(almanac);
  console.log(prim);
  var m = getMap(almanac, "seed");
  var prim$1 = srcToDest$1(m, BigInt(79)).toString();
  console.log(prim$1);
  var prim$2 = srcToDest$1(m, BigInt(14)).toString();
  console.log(prim$2);
  var prim$3 = srcToDest$1(m, BigInt(55)).toString();
  console.log(prim$3);
  var prim$4 = srcToDest$1(m, BigInt(13)).toString();
  console.log(prim$4);
  return part1(almanac);
}

function solvePart2(data) {
  return 2;
}

export {
  log ,
  log2 ,
  IntervalMap ,
  AlmanacMap ,
  Almanac ,
  parse ,
  part1 ,
  solvePart1 ,
  solvePart2 ,
}
/* No side effect */
