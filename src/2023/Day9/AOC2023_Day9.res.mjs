// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Utils from "../../Utils.res.mjs";
import * as Stdlib__Int from "@dsiu/rescript-stdlib-fp/src/Stdlib__Int.res.mjs";
import * as Stdlib__Array from "@dsiu/rescript-stdlib-fp/src/Stdlib__Array.res.mjs";
import * as Stdlib__Function from "@dsiu/rescript-stdlib-fp/src/Stdlib__Function.res.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function differences(xs) {
  return Stdlib__Array.map2(Stdlib__Array.tail(xs), xs, Stdlib__Int.subtract);
}

function expand(seq) {
  return {
    TAG: "Sequence",
    _0: Stdlib__Array.unfoldr(seq, xs => {
      if (Stdlib__Array.all(xs, __x => Stdlib__Function.eq(0, __x))) {
        return;
      } else {
        return [
          xs,
          differences(xs)
        ];
      }
    })
  };
}

function extendRow(param, row) {
  let n$p = Stdlib__Array.lastUnsafe(row) + param[1] | 0;
  let row$p = row.concat([n$p]);
  return [
    [row$p].concat(param[0]),
    n$p
  ];
}

function extend(seq) {
  return {
    TAG: "Sequence",
    _0: Stdlib__Array.foldRight(seq._0, [
        [],
        0
      ], extendRow)[0]
  };
}

function evaluate(seq) {
  return Stdlib__Array.lastUnsafe(Stdlib__Array.headUnsafe(seq._0));
}

function part1(histories) {
  return Stdlib__Array.sum(histories.map(x => evaluate(extend(expand(x)))), {
    zero: Stdlib__Int.zero,
    add: Stdlib__Int.add
  });
}

function part2(histories) {
  return part1(histories.map(prim => prim.toReversed()));
}

function parse(data) {
  return Utils.splitNewline(data).map(l => l.trim().split(" ").map(Utils.intFromStringExn));
}

function solvePart1(data) {
  return part1(parse(data));
}

function solvePart2(data) {
  return part2(parse(data));
}

export {
  log,
  log2,
  differences,
  expand,
  extendRow,
  extend,
  evaluate,
  part1,
  part2,
  parse,
  solvePart1,
  solvePart2,
}
/* Utils Not a pure module */
