// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Stdlib__Array from "@dsiu/rescript-stdlib-fp/src/Stdlib__Array.mjs";
import * as Stdlib__Option from "@dsiu/rescript-stdlib-fp/src/Stdlib__Option.mjs";
import * as Utils$AdventOfCode from "../../Utils.mjs";
import * as Array2D$AdventOfCode from "../../Array2D.mjs";
import * as Coord_V2$AdventOfCode from "../../Coord_V2.mjs";

function log(prim) {
  console.log(prim);
}

function mkPipe($$char) {
  switch ($$char) {
    case "-" :
        return "WE";
    case "7" :
        return "WS";
    case "F" :
        return "SE";
    case "J" :
        return "NW";
    case "L" :
        return "NE";
    case "S" :
        return "Start";
    case "|" :
        return "NS";
    default:
      return "Empty";
  }
}

function findStart(grid) {
  return Array2D$AdventOfCode.reduceWithIndex(grid, [
              0,
              0
            ], (function (acc, elem, pos) {
                if (elem === "Start") {
                  return pos;
                } else {
                  return acc;
                }
              }));
}

function make(grid) {
  return {
          grid: grid,
          start: findStart(grid)
        };
}

var $$Map = {
  make: make
};

function deltas(pipe) {
  var north = [
    0,
    -1
  ];
  var south = [
    0,
    1
  ];
  var east = [
    1,
    0
  ];
  var west = [
    -1,
    0
  ];
  switch (pipe) {
    case "Empty" :
        return [];
    case "NW" :
        return [
                north,
                west
              ];
    case "NS" :
        return [
                north,
                south
              ];
    case "NE" :
        return [
                north,
                east
              ];
    case "WE" :
        return [
                west,
                east
              ];
    case "WS" :
        return [
                west,
                south
              ];
    case "SE" :
        return [
                south,
                east
              ];
    case "Start" :
        return deltas("NS").concat(deltas("WE"));
    
  }
}

function neighbours(param, p) {
  var grid = param.grid;
  return Stdlib__Array.filterMap(deltas(Array2D$AdventOfCode.getExn(grid, p)), (function (delta) {
                var nbr = Coord_V2$AdventOfCode.add(p, delta);
                if (Array2D$AdventOfCode.isValidXY(grid, nbr)) {
                  return nbr;
                }
                
              }));
}

function connectorsToStart(map) {
  var nbrs = neighbours(map, map.start);
  var nbrsNbrs = Stdlib__Array.map(nbrs, (function (nbr) {
          return [
                  nbr,
                  neighbours(map, nbr)
                ];
        }));
  var connectors = Stdlib__Array.filter(nbrsNbrs, (function (param) {
          var snbr = param[0];
          return Stdlib__Option.isSome(Stdlib__Array.find(param[1], (function (n) {
                            return Coord_V2$AdventOfCode.compare(n)(snbr) === 0;
                          })));
        }));
  return Stdlib__Array.map(connectors, (function (prim) {
                return prim[0];
              }));
}

function parse(data) {
  return Stdlib__Array.map(Utils$AdventOfCode.splitNewline(data), (function (x) {
                return Stdlib__Array.map(x.trim().split(""), mkPipe);
              }));
}

function solvePart1(data) {
  var map = make(parse(data));
  console.log(map);
  return 1;
}

function solvePart2(data) {
  return 2;
}

export {
  log ,
  mkPipe ,
  findStart ,
  $$Map ,
  deltas ,
  neighbours ,
  connectorsToStart ,
  parse ,
  solvePart1 ,
  solvePart2 ,
}
/* Stdlib__Array Not a pure module */
