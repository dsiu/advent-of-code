// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Stdlib__Int from "@dsiu/rescript-stdlib-fp/src/Stdlib__Int.mjs";
import * as Stdlib__Array from "@dsiu/rescript-stdlib-fp/src/Stdlib__Array.mjs";
import * as Stdlib__Option from "@dsiu/rescript-stdlib-fp/src/Stdlib__Option.mjs";
import * as Utils$AdventOfCode from "../../Utils.mjs";
import * as Array2D$AdventOfCode from "../../Array2D.mjs";
import * as Coord_V2$AdventOfCode from "../../Coord_V2.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function mkPipe($$char) {
  switch ($$char) {
    case "-" :
        return "WE";
    case "7" :
        return "WS";
    case "F" :
        return "SE";
    case "J" :
        return "NW";
    case "L" :
        return "NE";
    case "S" :
        return "Start";
    case "|" :
        return "NS";
    default:
      return "Empty";
  }
}

function deltas(pipe) {
  var north = [
    0,
    -1
  ];
  var south = [
    0,
    1
  ];
  var east = [
    1,
    0
  ];
  var west = [
    -1,
    0
  ];
  switch (pipe) {
    case "Empty" :
        return [];
    case "NW" :
        return [
                north,
                west
              ];
    case "NS" :
        return [
                north,
                south
              ];
    case "NE" :
        return [
                north,
                east
              ];
    case "WE" :
        return [
                west,
                east
              ];
    case "WS" :
        return [
                west,
                south
              ];
    case "SE" :
        return [
                south,
                east
              ];
    case "Start" :
        return deltas("NS").concat(deltas("WE"));
    
  }
}

function isVertex(pipe) {
  switch (pipe) {
    case "Empty" :
    case "NS" :
    case "WE" :
        return false;
    default:
      return true;
  }
}

function findStart(grid) {
  return Array2D$AdventOfCode.reduceWithIndex(grid, [
              0,
              0
            ], (function (acc, elem, pos) {
                if (elem === "Start") {
                  return pos;
                } else {
                  return acc;
                }
              }));
}

function make(grid) {
  return {
          grid: grid,
          start: findStart(grid)
        };
}

var $$Map = {
  make: make
};

function neighbours(param, p) {
  var grid = param.grid;
  return Stdlib__Array.filterMap(deltas(Array2D$AdventOfCode.getExn(grid, p)), (function (delta) {
                var nbr = Coord_V2$AdventOfCode.add(p, delta);
                if (Array2D$AdventOfCode.isValidXY(grid, nbr)) {
                  return nbr;
                }
                
              }));
}

function connectorsToPosition(map, pos) {
  var startNbrs = neighbours(map, pos);
  var nbrsNbrs = startNbrs.map(function (nbr) {
        return [
                nbr,
                neighbours(map, nbr)
              ];
      });
  var connectors = nbrsNbrs.filter(function (param) {
        return Stdlib__Option.isSome(Stdlib__Array.find(param[1], (function (n) {
                          return Coord_V2$AdventOfCode.compare(n, pos) === 0;
                        })));
      });
  return connectors.map(function (prim) {
              return prim[0];
            });
}

function connectorsToStart(map) {
  return connectorsToPosition(map, map.start);
}

function followPath(map, start) {
  var _acc = [];
  var _thisPos = start;
  var _lastPos = start;
  while(true) {
    var lastPos = _lastPos;
    var thisPos = _thisPos;
    var acc = _acc;
    var nbrs = connectorsToPosition(map, thisPos);
    var next = Stdlib__Array.getUnsafe(nbrs.filter((function(lastPos){
            return function (n) {
              return Coord_V2$AdventOfCode.compare(n, lastPos) !== 0;
            }
            }(lastPos))), 0);
    var acc$p = acc.concat([thisPos]);
    if (Coord_V2$AdventOfCode.compare(next, start) === 0) {
      return acc$p;
    }
    _lastPos = thisPos;
    _thisPos = next;
    _acc = acc$p;
    continue ;
  };
}

function part1(map) {
  var path = followPath(map, map.start);
  return path.length / 2 | 0;
}

function shoelaceFormula(v) {
  var v$p = Stdlib__Array.drop(v, 1).concat(Stdlib__Array.take(v, 1));
  return Math.abs(Stdlib__Array.sum(Stdlib__Array.map2(v, v$p, (function (param, param$1) {
                        return Math.imul(param[0], param$1[1]) - Math.imul(param[1], param$1[0]) | 0;
                      })), {
                  zero: Stdlib__Int.zero,
                  add: Stdlib__Int.add
                })) / 2 | 0;
}

function part2(map) {
  var path = followPath(map, map.start);
  var boundaryPointsCount = path.length;
  var vertices = path.filter(function (pos) {
        return isVertex(Array2D$AdventOfCode.getExn(map.grid, pos));
      });
  var loopArea = shoelaceFormula(vertices);
  return (loopArea - (boundaryPointsCount / 2 | 0) | 0) + 1 | 0;
}

function parse(data) {
  return Utils$AdventOfCode.splitNewline(data).map(function (x) {
              return x.trim().split("").map(mkPipe);
            });
}

function solvePart1(data) {
  var map = make(parse(data));
  return part1(map);
}

function solvePart2(data) {
  var map = make(parse(data));
  return part2(map);
}

export {
  log ,
  log2 ,
  mkPipe ,
  deltas ,
  isVertex ,
  findStart ,
  $$Map ,
  neighbours ,
  connectorsToPosition ,
  connectorsToStart ,
  followPath ,
  part1 ,
  shoelaceFormula ,
  part2 ,
  parse ,
  solvePart1 ,
  solvePart2 ,
}
/* Stdlib__Int Not a pure module */
