// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Int from "rescript/lib/es6/Int.js";
import * as Utils from "../../Utils.mjs";
import * as Belt_Id from "rescript/lib/es6/Belt_Id.js";
import * as Belt_Map from "rescript/lib/es6/Belt_Map.js";
import * as Belt_Set from "rescript/lib/es6/Belt_Set.js";
import * as Coord_V2 from "../../Coord_V2.mjs";
import * as Pervasives from "rescript/lib/es6/Pervasives.js";
import * as Primitive_int from "rescript/lib/es6/Primitive_int.js";
import * as Stdlib__Array from "@dsiu/rescript-stdlib-fp/src/Stdlib__Array.mjs";
import * as Stdlib__Option from "@dsiu/rescript-stdlib-fp/src/Stdlib__Option.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function cmp(a, b) {
  return Coord_V2.compare(a, b);
}

let Position = {
  compare: Coord_V2.compare,
  cmp: cmp
};

let PositionCmp = Belt_Id.MakeComparable({
  cmp: cmp
});

function cmp$1(param, param$1) {
  let match = param$1._0;
  let match$1 = param._0;
  let posEq = Coord_V2.compare(match$1[0], match[0]);
  let dirEq = match$1[1] === match[1] ? 0 : 1;
  if (posEq === 0) {
    return dirEq;
  } else {
    return posEq;
  }
}

let BeamHead = {
  cmp: cmp$1
};

let BeamHeadCmp = Belt_Id.MakeComparable(BeamHead);

function showBeamHead(param) {
  let match = param._0;
  let dirStr;
  switch (match[1]) {
    case "U" :
      dirStr = "U";
      break;
    case "D" :
      dirStr = "D";
      break;
    case "L" :
      dirStr = "L";
      break;
    case "R" :
      dirStr = "R";
      break;
  }
  return "(" + Coord_V2.show(match[0]) + ", " + dirStr + ")";
}

function bounds(grid) {
  let keys = Belt_Map.keysToArray(grid);
  let rows = keys.map(param => param[0]);
  let cols = keys.map(param => param[1]);
  return [
    Stdlib__Array.reduce(rows, Int.Constants.minValue, (prim0, prim1) => Math.max(prim0, prim1)),
    Stdlib__Array.reduce(cols, Int.Constants.minValue, (prim0, prim1) => Math.max(prim0, prim1))
  ];
}

function inRange(param, b) {
  let c1 = param[1];
  let r1 = param[0];
  if (r1 >= 0 && r1 <= b[0] && c1 >= 0) {
    return c1 <= b[1];
  } else {
    return false;
  }
}

function move(pos, dir) {
  switch (dir) {
    case "U" :
      return Coord_V2.add(pos, [
        -1,
        0
      ]);
    case "D" :
      return Coord_V2.add(pos, [
        1,
        0
      ]);
    case "L" :
      return Coord_V2.add(pos, [
        0,
        -1
      ]);
    case "R" :
      return Coord_V2.add(pos, [
        0,
        1
      ]);
  }
}

function propagateElem(element, beamHead) {
  switch (element) {
    case "Empty" :
      let match = beamHead._0;
      let dir = match[1];
      return [{
          TAG: "BeamHead",
          _0: [
            move(match[0], dir),
            dir
          ]
        }];
    case "SlashMirror" :
      let match$1 = beamHead._0;
      let pos = match$1[0];
      switch (match$1[1]) {
        case "U" :
          return [{
              TAG: "BeamHead",
              _0: [
                Coord_V2.add(pos, [
                  0,
                  1
                ]),
                "R"
              ]
            }];
        case "D" :
          return [{
              TAG: "BeamHead",
              _0: [
                Coord_V2.add(pos, [
                  0,
                  -1
                ]),
                "L"
              ]
            }];
        case "L" :
          return [{
              TAG: "BeamHead",
              _0: [
                Coord_V2.add(pos, [
                  1,
                  0
                ]),
                "D"
              ]
            }];
        case "R" :
          return [{
              TAG: "BeamHead",
              _0: [
                Coord_V2.add(pos, [
                  -1,
                  0
                ]),
                "U"
              ]
            }];
      }
    case "BackslashMirror" :
      let match$2 = beamHead._0;
      let pos$1 = match$2[0];
      switch (match$2[1]) {
        case "U" :
          return [{
              TAG: "BeamHead",
              _0: [
                Coord_V2.add(pos$1, [
                  0,
                  -1
                ]),
                "L"
              ]
            }];
        case "D" :
          return [{
              TAG: "BeamHead",
              _0: [
                Coord_V2.add(pos$1, [
                  0,
                  1
                ]),
                "R"
              ]
            }];
        case "L" :
          return [{
              TAG: "BeamHead",
              _0: [
                Coord_V2.add(pos$1, [
                  -1,
                  0
                ]),
                "U"
              ]
            }];
        case "R" :
          return [{
              TAG: "BeamHead",
              _0: [
                Coord_V2.add(pos$1, [
                  1,
                  0
                ]),
                "D"
              ]
            }];
      }
    case "HorizontalSplitter" :
      let match$3 = beamHead._0;
      let pos$2 = match$3[0];
      switch (match$3[1]) {
        case "U" :
        case "D" :
          break;
        case "L" :
          return [{
              TAG: "BeamHead",
              _0: [
                Coord_V2.add(pos$2, [
                  0,
                  -1
                ]),
                "L"
              ]
            }];
        case "R" :
          return [{
              TAG: "BeamHead",
              _0: [
                Coord_V2.add(pos$2, [
                  0,
                  1
                ]),
                "R"
              ]
            }];
      }
      return [
        {
          TAG: "BeamHead",
          _0: [
            Coord_V2.add(pos$2, [
              0,
              -1
            ]),
            "L"
          ]
        },
        {
          TAG: "BeamHead",
          _0: [
            Coord_V2.add(pos$2, [
              0,
              1
            ]),
            "R"
          ]
        }
      ];
    case "VerticalSplitter" :
      let match$4 = beamHead._0;
      let pos$3 = match$4[0];
      switch (match$4[1]) {
        case "U" :
          return [{
              TAG: "BeamHead",
              _0: [
                Coord_V2.add(pos$3, [
                  -1,
                  0
                ]),
                "U"
              ]
            }];
        case "D" :
          return [{
              TAG: "BeamHead",
              _0: [
                Coord_V2.add(pos$3, [
                  1,
                  0
                ]),
                "D"
              ]
            }];
        case "L" :
        case "R" :
          break;
      }
      return [
        {
          TAG: "BeamHead",
          _0: [
            Coord_V2.add(pos$3, [
              -1,
              0
            ]),
            "U"
          ]
        },
        {
          TAG: "BeamHead",
          _0: [
            Coord_V2.add(pos$3, [
              1,
              0
            ]),
            "D"
          ]
        }
      ];
  }
}

function propagate(grid, bounds, _energized, _beamHeads) {
  while (true) {
    let beamHeads = _beamHeads;
    let energized = _energized;
    if (beamHeads.length === 0) {
      return energized;
    }
    let bh = Stdlib__Array.headUnsafe(beamHeads);
    let bhs = Stdlib__Array.tail(beamHeads);
    if (Belt_Set.has(energized, bh)) {
      _beamHeads = bhs;
      continue;
    }
    let $$this = Belt_Map.get(grid, bh._0[0]);
    if ($$this === undefined) {
      return Pervasives.failwith("Beam head out of bounds");
    }
    let nexts = propagateElem($$this, bh);
    let nexts$p = nexts.filter(param => inRange(param._0[0], bounds));
    let energized$p = Belt_Set.add(energized, bh);
    _beamHeads = bhs.concat(nexts$p);
    _energized = energized$p;
    continue;
  };
}

function makeElement(s) {
  switch (s) {
    case "-" :
      return "HorizontalSplitter";
    case "." :
      return "Empty";
    case "/" :
      return "SlashMirror";
    case "\\" :
      return "BackslashMirror";
    case "|" :
      return "VerticalSplitter";
    default:
      return Pervasives.failwith("Unknown element");
  }
}

function makeGrid(xss) {
  return Belt_Map.fromArray(Stdlib__Array.flatten(xss.map((row, rowNum) => row.map((col, colNum) => [
    [
      rowNum,
      colNum
    ],
    makeElement(col)
  ]))), PositionCmp);
}

function countEnergized(grid, bounds, beamHead) {
  return Stdlib__Array.uniq(Belt_Set.toArray(propagate(grid, bounds, Belt_Set.make(BeamHeadCmp), [beamHead])).map(param => param._0[0])).length;
}

function getEdges(grid) {
  let bounds$1 = bounds(grid);
  let maxC = bounds$1[1];
  let maxR = bounds$1[0];
  let top = Stdlib__Array.fromInitializer(maxC + 1 | 0, c => ({
    TAG: "BeamHead",
    _0: [
      [
        0,
        c
      ],
      "D"
    ]
  }));
  let left = Stdlib__Array.fromInitializer(maxR + 1 | 0, r => ({
    TAG: "BeamHead",
    _0: [
      [
        r,
        0
      ],
      "R"
    ]
  }));
  let right = Stdlib__Array.fromInitializer(maxR + 1 | 0, r => ({
    TAG: "BeamHead",
    _0: [
      [
        r,
        maxC
      ],
      "L"
    ]
  }));
  let bottom = Stdlib__Array.fromInitializer(maxC + 1 | 0, c => ({
    TAG: "BeamHead",
    _0: [
      [
        maxR,
        c
      ],
      "U"
    ]
  }));
  return Stdlib__Array.foldl1([
    top,
    bottom,
    left,
    right
  ], (prim0, prim1) => prim0.concat(prim1));
}

function part1(xss) {
  let grid = makeGrid(xss);
  let bounds$1 = bounds(grid);
  return countEnergized(grid, bounds$1, {
    TAG: "BeamHead",
    _0: [
      [
        0,
        0
      ],
      "R"
    ]
  });
}

function part2(xss) {
  let grid = makeGrid(xss);
  let bounds$1 = bounds(grid);
  let edges = getEdges(grid);
  return Stdlib__Option.getExn(Stdlib__Array.maximum(edges.map(__x => countEnergized(grid, bounds$1, __x)), Primitive_int.compare), undefined);
}

function parse(data) {
  return Utils.splitNewline(data).map(l => l.trim().split(""));
}

function solvePart1(data) {
  return part1(parse(data));
}

function solvePart2(data) {
  return part2(parse(data));
}

let $$Map;

let $$Set;

export {
  $$Map,
  $$Set,
  log,
  log2,
  Position,
  PositionCmp,
  BeamHead,
  BeamHeadCmp,
  showBeamHead,
  bounds,
  inRange,
  move,
  propagateElem,
  propagate,
  makeElement,
  makeGrid,
  countEnergized,
  getEdges,
  part1,
  part2,
  parse,
  solvePart1,
  solvePart2,
}
/* PositionCmp Not a pure module */
