// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Utils from "../../Utils.mjs";
import * as Belt_Id from "rescript/lib/es6/Belt_Id.js";
import * as Coord_V2 from "../../Coord_V2.mjs";
import * as Stdlib__Array from "@dsiu/rescript-stdlib-fp/src/Stdlib__Array.mjs";
import * as Stdlib__Option from "@dsiu/rescript-stdlib-fp/src/Stdlib__Option.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function cmp(param, param$1) {
  let dir2 = param$1[0];
  let posCmp = Coord_V2.compare(param[1], param$1[1]);
  if (posCmp !== 0) {
    return posCmp;
  }
  switch (param[0]) {
    case "U" :
      if (dir2 === "U") {
        return 0;
      } else {
        return -1;
      }
    case "D" :
      if (dir2 === "D") {
        return 0;
      } else {
        return -1;
      }
    case "L" :
      if (dir2 === "L") {
        return 0;
      } else {
        return -1;
      }
    case "R" :
      if (dir2 === "R") {
        return 0;
      } else {
        return -1;
      }
  }
}

let DirectedPosition = {
  cmp: cmp
};

let DirectedPositionCmp = Belt_Id.MakeComparable(DirectedPosition);

function delta(dir) {
  switch (dir) {
    case "U" :
      return [
        -1,
        0
      ];
    case "D" :
      return [
        1,
        0
      ];
    case "L" :
      return [
        0,
        -1
      ];
    case "R" :
      return [
        0,
        1
      ];
  }
}

function toPositions(here, param) {
  let d = delta(param._0);
  return Stdlib__Array.fromInitializer(param._1 - 1 | 0, i => i + 1 | 0).map(i => Coord_V2.add(here, Coord_V2.mul(d, i)));
}

function endingDirPos(here, move) {
  return [
    move._0,
    Stdlib__Option.getExn(Stdlib__Array.last(toPositions(here, move)), undefined)
  ];
}

function turnDirections(dir) {
  switch (dir) {
    case "U" :
    case "D" :
      return [
        "L",
        "R"
      ];
    case "L" :
    case "R" :
      return [
        "U",
        "D"
      ];
  }
}

function parse(data) {
  return Utils.splitNewline(data).map(prim => prim.trim());
}

function solvePart1(data) {
  return 1;
}

function solvePart2(data) {
  return 2;
}

export {
  log,
  log2,
  DirectedPosition,
  DirectedPositionCmp,
  delta,
  toPositions,
  endingDirPos,
  turnDirections,
  parse,
  solvePart1,
  solvePart2,
}
/* DirectedPositionCmp Not a pure module */
