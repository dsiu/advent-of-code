// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Core__Int from "@rescript/core/src/Core__Int.mjs";
import * as Belt_SetInt from "rescript/lib/es6/belt_SetInt.js";
import * as Core__Array from "@rescript/core/src/Core__Array.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.mjs";
import * as Utils$AdventOfCode from "../../Utils.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function matchPerCard(param) {
  var winnerSet = Belt_SetInt.fromArray(param.winners);
  var actualSet = Belt_SetInt.fromArray(param.actuals);
  return Belt_SetInt.size(Belt_SetInt.intersect(winnerSet, actualSet));
}

function mkQueue(cards) {
  return cards.map(function (c) {
              return {
                      numMatches: matchPerCard(c),
                      queuedQuantity: 1
                    };
            });
}

function duplicateCards(n, scale, queue) {
  var qPre = queue.slice(0, n);
  var qPost = queue.slice(n);
  var dup = qPre.map(function (param) {
        return {
                numMatches: param.numMatches,
                queuedQuantity: param.queuedQuantity + scale | 0
              };
      });
  return dup.concat(qPost);
}

function calculatePoint(n) {
  if (n === 0) {
    return 0;
  } else {
    return Math.pow(2, n - 1 | 0);
  }
}

function part1(cards) {
  return Utils$AdventOfCode.sumIntArray(cards.map(function (param) {
                  return Utils$AdventOfCode.compose(matchPerCard, calculatePoint, param);
                }));
}

function part2(cards) {
  var queue = mkQueue(cards);
  var _n = 0;
  var _q = queue;
  while(true) {
    var q = _q;
    var n = _n;
    var match = q.length;
    if (match === 0) {
      return n;
    }
    var match$1 = Core__Option.getExn(q[0]);
    var queuedQuantity = match$1.queuedQuantity;
    var n$p = n + queuedQuantity | 0;
    var queue$p = duplicateCards(match$1.numMatches, queuedQuantity, q.slice(1));
    _q = queue$p;
    _n = n$p;
    continue ;
  };
}

function parse(data) {
  return Utils$AdventOfCode.splitNewline(data).map(function (l) {
              var cardAndNumbers = l.trim().split(": ");
              var cardId = Core__Option.flatMap(cardAndNumbers[0], (function (s) {
                      return Core__Int.fromString(undefined, s.replace("Card ", ""));
                    }));
              var numberStrs = Core__Option.flatMap(cardAndNumbers[1], (function (s) {
                      return s.split(" | ").map(function (nums) {
                                  var partial_arg = 10;
                                  return Core__Array.filterMap(nums.trim().split(" "), (function (param) {
                                                return Core__Int.fromString(partial_arg, param);
                                              }));
                                });
                    }));
              return {
                      id: Core__Option.getExn(cardId),
                      winners: Core__Option.getExn(Core__Option.flatMap(numberStrs, (function (__x) {
                                  return __x.at(0);
                                }))),
                      actuals: Core__Option.getExn(Core__Option.flatMap(numberStrs, (function (__x) {
                                  return __x.at(1);
                                })))
                    };
            });
}

function solvePart1(data) {
  return part1(parse(data));
}

function solvePart2(data) {
  return part2(parse(data));
}

export {
  log ,
  log2 ,
  matchPerCard ,
  mkQueue ,
  duplicateCards ,
  calculatePoint ,
  part1 ,
  part2 ,
  parse ,
  solvePart1 ,
  solvePart2 ,
}
/* No side effect */
