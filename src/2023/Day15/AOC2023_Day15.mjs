// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Stdlib__Int from "@dsiu/rescript-stdlib-fp/src/Stdlib__Int.mjs";
import * as Stdlib__List from "@dsiu/rescript-stdlib-fp/src/Stdlib__List.mjs";
import * as Stdlib__Array from "@dsiu/rescript-stdlib-fp/src/Stdlib__Array.mjs";
import * as Stdlib__Option from "@dsiu/rescript-stdlib-fp/src/Stdlib__Option.mjs";
import * as Stdlib__Result from "@dsiu/rescript-stdlib-fp/src/Stdlib__Result.mjs";
import * as Relude_NonEmpty from "relude/src/Relude_NonEmpty.mjs";
import * as ReludeParse_Parser from "relude-parse/src/ReludeParse_Parser.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function charToASCII(s) {
  return Stdlib__Option.getExn(s.codePointAt(0), undefined);
}

function hash(str) {
  return Stdlib__Array.reduce(str.split(""), 0, (acc, c) => Math.imul(acc + charToASCII(c) | 0, 17) % 256);
}

function process(facility, instruction) {
  if (instruction.TAG === "Remove") {
    let s = instruction._0;
    let label = hash(s);
    let updatedLenses = Stdlib__Option.mapOr(facility.get(label), [], lenses => lenses.filter(lens => lens.lensLabel !== s));
    facility.set(label, updatedLenses);
    return facility;
  }
  let s$1 = instruction._0;
  let label$1 = hash(s$1);
  let newLens_lensPower = instruction._1;
  let newLens = {
    lensLabel: s$1,
    lensPower: newLens_lensPower
  };
  let updatedLenses$1 = Stdlib__Option.mapOr(facility.get(label$1), [newLens], lenses => Stdlib__Option.mapOr(Stdlib__Array.findIndexOpt(lenses, lens => lens.lensLabel === s$1), lenses.concat([newLens]), i => {
    lenses[i] = newLens;
    return lenses;
  }));
  facility.set(label$1, updatedLenses$1);
  return facility;
}

function processAll(xs) {
  let facility = new Map();
  return Stdlib__Array.reduce(xs, facility, process);
}

function powerCell(param) {
  let i = param[0];
  return Stdlib__Array.sum(param[1].map((lens, index) => Math.imul(Math.imul(index + 1 | 0, lens.lensPower), i + 1 | 0)), {
    zero: Stdlib__Int.zero,
    add: Stdlib__Int.add
  });
}

function power(facility) {
  return Stdlib__Array.sum(Array.from(facility.entries()).map(powerCell), {
    zero: Stdlib__Int.zero,
    add: Stdlib__Int.add
  });
}

function nonEmptyListToString(x) {
  return Stdlib__List.join(Relude_NonEmpty.List.toList(x), "");
}

function mkRemove(a) {
  return {
    TAG: "Remove",
    _0: nonEmptyListToString(a)
  };
}

let removeP = ReludeParse_Parser.Infix.$less$$great(mkRemove, ReludeParse_Parser.Infix.$less$star(ReludeParse_Parser.many1(ReludeParse_Parser.anyAlpha), ReludeParse_Parser.str("-")));

function mkInsert(a) {
  return b => ({
    TAG: "Insert",
    _0: nonEmptyListToString(a),
    _1: b
  });
}

let insertP = ReludeParse_Parser.Infix.$less$star$great(ReludeParse_Parser.Infix.$less$$great(mkInsert, ReludeParse_Parser.Infix.$less$star(ReludeParse_Parser.many1(ReludeParse_Parser.anyAlpha), ReludeParse_Parser.str("="))), ReludeParse_Parser.anyInt);

let instructionP = ReludeParse_Parser.Infix.$less$pipe$great(ReludeParse_Parser.tries(removeP), ReludeParse_Parser.tries(insertP));

let instructionsP = ReludeParse_Parser.sepBy(ReludeParse_Parser.str(","), instructionP);

function run(str) {
  return Stdlib__Result.getExn(ReludeParse_Parser.runParser(str, instructionP));
}

let InstructionParser = {
  P: undefined,
  debug: ReludeParse_Parser.tapLog,
  nonEmptyListToString: nonEmptyListToString,
  mkRemove: mkRemove,
  removeP: removeP,
  mkInsert: mkInsert,
  insertP: insertP,
  instructionP: instructionP,
  instructionsP: instructionsP,
  run: run
};

function part2(data) {
  return power(processAll(data.split(",").map(run)));
}

function part1(xs) {
  return Stdlib__Array.sum(xs.map(hash), {
    zero: Stdlib__Int.zero,
    add: Stdlib__Int.add
  });
}

function parsePart1(data) {
  return data.trim().split(",");
}

function solvePart1(data) {
  return part1(data.trim().split(","));
}

let solvePart2 = part2;

export {
  log,
  log2,
  charToASCII,
  hash,
  process,
  processAll,
  powerCell,
  power,
  InstructionParser,
  part2,
  part1,
  parsePart1,
  solvePart1,
  solvePart2,
}
/* removeP Not a pure module */
