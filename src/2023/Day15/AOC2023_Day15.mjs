// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Stdlib__Int from "@dsiu/rescript-stdlib-fp/src/Stdlib__Int.mjs";
import * as Stdlib__List from "@dsiu/rescript-stdlib-fp/src/Stdlib__List.mjs";
import * as Stdlib__Array from "@dsiu/rescript-stdlib-fp/src/Stdlib__Array.mjs";
import * as Stdlib__Option from "@dsiu/rescript-stdlib-fp/src/Stdlib__Option.mjs";
import * as Stdlib__Result from "@dsiu/rescript-stdlib-fp/src/Stdlib__Result.mjs";
import * as Relude_NonEmpty from "relude/src/Relude_NonEmpty.mjs";
import * as ReludeParse_Parser from "relude-parse/src/ReludeParse_Parser.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function charToASCII(s) {
  return Stdlib__Option.getExn(s.codePointAt(0), undefined);
}

function hash(str) {
  return Stdlib__Array.reduce(str.split(""), 0, (function (acc, c) {
                return Math.imul(acc + charToASCII(c) | 0, 17) % 256;
              }));
}

function $$process(facility, instruction) {
  if (instruction.TAG === "Remove") {
    var s = instruction._0;
    var label = hash(s);
    var updatedLenses = Stdlib__Option.mapOr(facility.get(label), [], (function (lenses) {
            return lenses.filter(function (lens) {
                        return lens.lensLabel !== s;
                      });
          }));
    facility.set(label, updatedLenses);
    return facility;
  }
  var s$1 = instruction._0;
  var label$1 = hash(s$1);
  var newLens_lensPower = instruction._1;
  var newLens = {
    lensLabel: s$1,
    lensPower: newLens_lensPower
  };
  var updatedLenses$1 = Stdlib__Option.mapOr(facility.get(label$1), [newLens], (function (lenses) {
          return Stdlib__Option.mapOr(Stdlib__Array.findIndexOpt(lenses, (function (lens) {
                            return lens.lensLabel === s$1;
                          })), lenses.concat([newLens]), (function (i) {
                        lenses[i] = newLens;
                        return lenses;
                      }));
        }));
  facility.set(label$1, updatedLenses$1);
  return facility;
}

function processAll(xs) {
  var facility = new Map();
  return Stdlib__Array.reduce(xs, facility, $$process);
}

function powerCell(param) {
  var i = param[0];
  return Stdlib__Array.sum(param[1].map(function (lens, index) {
                  return Math.imul(Math.imul(index + 1 | 0, lens.lensPower), i + 1 | 0);
                }), {
              zero: Stdlib__Int.zero,
              add: Stdlib__Int.add
            });
}

function power(facility) {
  return Stdlib__Array.sum(Array.from(facility.entries()).map(powerCell), {
              zero: Stdlib__Int.zero,
              add: Stdlib__Int.add
            });
}

function nonEmptyListToString(x) {
  return Stdlib__List.join(Relude_NonEmpty.List.toList(x), "");
}

function mkRemove(a) {
  return {
          TAG: "Remove",
          _0: nonEmptyListToString(a)
        };
}

var removeP = ReludeParse_Parser.Infix.$less$$great(mkRemove, ReludeParse_Parser.Infix.$less$star(ReludeParse_Parser.many1(ReludeParse_Parser.anyAlpha), ReludeParse_Parser.str("-")));

function mkInsert(a) {
  return function (b) {
    return {
            TAG: "Insert",
            _0: nonEmptyListToString(a),
            _1: b
          };
  };
}

var insertP = ReludeParse_Parser.Infix.$less$star$great(ReludeParse_Parser.Infix.$less$$great(mkInsert, ReludeParse_Parser.Infix.$less$star(ReludeParse_Parser.many1(ReludeParse_Parser.anyAlpha), ReludeParse_Parser.str("="))), ReludeParse_Parser.anyInt);

var instructionP = ReludeParse_Parser.Infix.$less$pipe$great(ReludeParse_Parser.tries(removeP), ReludeParse_Parser.tries(insertP));

var instructionsP = ReludeParse_Parser.sepBy(ReludeParse_Parser.str(","), instructionP);

function run(str) {
  return Stdlib__Result.getExn((function (__x) {
                  return ReludeParse_Parser.runParser(str, __x);
                })(instructionP));
}

var InstructionParser = {
  P: undefined,
  debug: ReludeParse_Parser.tapLog,
  nonEmptyListToString: nonEmptyListToString,
  mkRemove: mkRemove,
  removeP: removeP,
  mkInsert: mkInsert,
  insertP: insertP,
  instructionP: instructionP,
  instructionsP: instructionsP,
  run: run
};

function part2(data) {
  return power(processAll(data.split(",").map(run)));
}

function part1(xs) {
  return Stdlib__Array.sum(xs.map(hash), {
              zero: Stdlib__Int.zero,
              add: Stdlib__Int.add
            });
}

function parsePart1(data) {
  return data.trim().split(",");
}

function solvePart1(data) {
  return part1(data.trim().split(","));
}

function solvePart2(data) {
  return part2(data);
}

export {
  log ,
  log2 ,
  charToASCII ,
  hash ,
  $$process ,
  processAll ,
  powerCell ,
  power ,
  InstructionParser ,
  part2 ,
  part1 ,
  parsePart1 ,
  solvePart1 ,
  solvePart2 ,
}
/* removeP Not a pure module */
