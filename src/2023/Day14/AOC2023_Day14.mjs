// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";
import * as Stdlib__Int from "@dsiu/rescript-stdlib-fp/src/Stdlib__Int.mjs";
import * as Stdlib__Array from "@dsiu/rescript-stdlib-fp/src/Stdlib__Array.mjs";
import * as Stdlib__Function from "@dsiu/rescript-stdlib-fp/src/Stdlib__Function.mjs";
import * as Utils$AdventOfCode from "../../Utils.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function readElement(str) {
  switch (str) {
    case "#" :
        return "Cube";
    case "." :
        return "Empty";
    case "O" :
        return "Round";
    default:
      return PervasivesU.failwith("Invalid element");
  }
}

function makeGrid(xss) {
  return Stdlib__Array.transpose(xss.map(function (__x) {
                  return __x.map(readElement);
                }));
}

function showElement(el) {
  switch (el) {
    case "Empty" :
        return ".";
    case "Cube" :
        return "#";
    case "Round" :
        return "O";
    
  }
}

function showGrid(grid) {
  return Stdlib__Array.transpose(grid).map(function (row) {
                return row.map(showElement).join("");
              }).join("\n");
}

function gridEq(g1, g2) {
  return showGrid(g1) === showGrid(g2);
}

function rollStep(param, source) {
  var target = param[1];
  var handled = param[0];
  switch (target) {
    case "Empty" :
        switch (source) {
          case "Empty" :
          case "Cube" :
              break;
          case "Round" :
              return [
                      handled.concat(["Round"]),
                      "Empty"
                    ];
          
        }
        break;
    case "Cube" :
    case "Round" :
        break;
    
  }
  return [
          handled.concat([target]),
          source
        ];
}

function roll(xs) {
  if (xs.length === 0) {
    return [];
  }
  var l = Stdlib__Array.headUnsafe(xs);
  var ls = Stdlib__Array.tail(xs);
  var match = Stdlib__Array.fold(ls, [
        [],
        l
      ], rollStep);
  return match[0].concat([match[1]]);
}

function rollGrid(__x) {
  return __x.map(roll);
}

function rollToCompletion(_grid) {
  while(true) {
    var grid = _grid;
    var grid$p = grid.map(roll);
    if (gridEq(grid, grid$p)) {
      return grid$p;
    }
    _grid = grid$p;
    continue ;
  };
}

function scoreGrid(grid) {
  var normalizedGrid = Stdlib__Array.transpose(grid);
  var l = normalizedGrid.length;
  var indexedGird = Stdlib__Array.zip(Stdlib__Array.fromInitializer(l, (function (i) {
              return i + 1 | 0;
            })), normalizedGrid.toReversed());
  var scoreRow = function (param) {
    return Math.imul(param[0], param[1].filter(function (el) {
                    return el === "Round";
                  }).length);
  };
  return Stdlib__Array.sum(indexedGird.map(scoreRow), {
              zero: Stdlib__Int.zero,
              add: Stdlib__Int.add
            });
}

function rotate1(extra) {
  return Stdlib__Function.compose((function (__x) {
                return __x.map(function (prim) {
                            return prim.toReversed();
                          });
              }), Stdlib__Array.transpose, extra);
}

function runNTimes(_n, f, _x) {
  while(true) {
    var x = _x;
    var n = _n;
    if (n === 0) {
      return x;
    }
    _x = f(x);
    _n = n - 1 | 0;
    continue ;
  };
}

function runNTimesWithCache(_n, f, _x, cacheFn, predFn) {
  while(true) {
    var x = _x;
    var n = _n;
    if (n === 0) {
      return [
              0,
              x
            ];
    }
    var x$p = f(x);
    if (predFn(x$p)) {
      console.log("done. cycles = ", n);
      return [
              n,
              x$p
            ];
    }
    cacheFn(x$p, n);
    _x = x$p;
    _n = n - 1 | 0;
    continue ;
  };
}

function rollCycle(grid) {
  var oneTurn = function (grid) {
    return rotate1(rollToCompletion(grid));
  };
  return runNTimes(4, oneTurn, grid);
}

function part1(grid) {
  return scoreGrid(rollToCompletion(grid));
}

function part2(grid) {
  var cache = new Map();
  var predFn = function (grid) {
    return cache.has(showGrid(grid));
  };
  var cacheFn = function (grid, i) {
    cache.set(showGrid(grid), [
          grid,
          1000000000 - i | 0
        ]);
  };
  var getCached = function (grid) {
    return cache.get(showGrid(grid));
  };
  var match = runNTimesWithCache(1000000000, rollCycle, grid, cacheFn, predFn);
  var repeatEnd = 1000000000 - match[0] | 0;
  var firstSeen = getCached(match[1]);
  var tmp;
  if (firstSeen !== undefined) {
    var repeatStart = firstSeen[1];
    var repeatLen = repeatEnd - repeatStart | 0;
    var finalIndex = Caml_int32.mod_(1000000000 - repeatStart | 0, repeatLen) + repeatStart | 0;
    var ret = Array.from(cache.entries()).filter(function (param) {
          return param[1][1] === (finalIndex - 1 | 0);
        });
    var match$1 = ret[0];
    if (match$1 !== undefined) {
      tmp = match$1[1][0];
    } else {
      throw {
            RE_EXN_ID: "Match_failure",
            _1: [
              "AOC2023_Day14.res",
              145,
              10
            ],
            Error: new Error()
          };
    }
  } else {
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  }
  return scoreGrid(tmp);
}

function trimAndSplit(str) {
  return str.trim().split("");
}

function parse(data) {
  return Utils$AdventOfCode.splitNewline(data).map(trimAndSplit);
}

function solvePart1(data) {
  return part1(makeGrid(parse(data)));
}

function solvePart2(data) {
  return part2(makeGrid(parse(data)));
}

export {
  log ,
  log2 ,
  readElement ,
  makeGrid ,
  showElement ,
  showGrid ,
  gridEq ,
  rollStep ,
  roll ,
  rollGrid ,
  rollToCompletion ,
  scoreGrid ,
  rotate1 ,
  runNTimes ,
  runNTimesWithCache ,
  rollCycle ,
  part1 ,
  part2 ,
  trimAndSplit ,
  parse ,
  solvePart1 ,
  solvePart2 ,
}
/* Stdlib__Int Not a pure module */
