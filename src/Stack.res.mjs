// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Primitive_int from "rescript/lib/es6/Primitive_int.js";
import * as Stdlib__Function from "@dsiu/rescript-stdlib-fp/src/Stdlib__Function.res.mjs";

function MakeStack(Item) {
  let push = (contents, x) => ({
    TAG: "Contents",
    _0: {
      hd: x,
      tl: contents._0
    }
  });
  let pop = contents => {
    let contents$1 = contents._0;
    if (contents$1) {
      let newStack = {
        TAG: "Contents",
        _0: contents$1.tl
      };
      return [
        contents$1.hd,
        newStack
      ];
    }
    throw {
      RE_EXN_ID: "Not_found",
      Error: new Error()
    };
  };
  let binary = (mathFn, stack) => {
    let match = pop(stack);
    let match$1 = pop(match[1]);
    let z = mathFn(match$1[0], match[0]);
    return push(match$1[1], z);
  };
  let unary = (f, stack) => {
    let match = pop(stack);
    return push(match[1], f(match[0]));
  };
  let show = stack => {
    let match = pop(stack);
    console.log(match[0]);
    return stack;
  };
  let show2 = (stack, str) => {
    let match = pop(stack);
    console.log(match[0], str);
    return stack;
  };
  let dup = stack => {
    let match = pop(stack);
    return push(stack, match[0]);
  };
  let swap = stack => {
    let match = pop(stack);
    let match$1 = pop(match[1]);
    return push(push(match$1[1], match[0]), match$1[0]);
  };
  let drop = stack => pop(stack)[1];
  let empty = {
    TAG: "Contents",
    _0: /* [] */0
  };
  let one = __x => push(__x, Item.one);
  let two = __x => push(__x, Item.two);
  let three = __x => push(__x, Item.three);
  let four = __x => push(__x, Item.four);
  let five = __x => push(__x, Item.five);
  let mul = __x => binary(Item.mul, __x);
  let add = __x => binary(Item.add, __x);
  let sub = __x => binary(Item.sub, __x);
  let div = __x => binary(Item.div, __x);
  let neg = __x => unary(x => Item.neg(x), __x);
  let square = extra => Stdlib__Function.compose(dup, mul, extra);
  let cube = extra => Stdlib__Function.compose4(dup, dup, mul, mul, extra);
  let sum_numbers_upto = extra => Stdlib__Function.compose(extra => Stdlib__Function.compose4(dup, one, add, mul, extra), extra => Stdlib__Function.compose(two, div, extra), extra);
  return {
    push: push,
    pop: pop,
    binary: binary,
    unary: unary,
    show: show,
    show2: show2,
    dup: dup,
    swap: swap,
    drop: drop,
    empty: empty,
    start: empty,
    one: one,
    two: two,
    three: three,
    four: four,
    five: five,
    mul: mul,
    add: add,
    sub: sub,
    div: div,
    neg: neg,
    compose: Stdlib__Function.compose,
    compose4: Stdlib__Function.compose4,
    square: square,
    cube: cube,
    sum_numbers_upto: sum_numbers_upto
  };
}

function add(x, y) {
  return x + y | 0;
}

function mul(x, y) {
  return Math.imul(x, y);
}

function sub(x, y) {
  return x - y | 0;
}

let div = Primitive_int.div;

function neg(x) {
  return -x | 0;
}

let IntOps = {
  one: 1,
  two: 2,
  three: 3,
  four: 4,
  five: 5,
  add: add,
  mul: mul,
  sub: sub,
  div: div,
  neg: neg
};

function push(contents, x) {
  return {
    TAG: "Contents",
    _0: {
      hd: x,
      tl: contents._0
    }
  };
}

function pop(contents) {
  let contents$1 = contents._0;
  if (contents$1) {
    let newStack = {
      TAG: "Contents",
      _0: contents$1.tl
    };
    return [
      contents$1.hd,
      newStack
    ];
  }
  throw {
    RE_EXN_ID: "Not_found",
    Error: new Error()
  };
}

function binary(mathFn, stack) {
  let match = pop(stack);
  let match$1 = pop(match[1]);
  let z = mathFn(match$1[0], match[0]);
  return push(match$1[1], z);
}

function unary(f, stack) {
  let match = pop(stack);
  return push(match[1], f(match[0]));
}

function show(stack) {
  let match = pop(stack);
  console.log(match[0]);
  return stack;
}

function show2(stack, str) {
  let match = pop(stack);
  console.log(match[0], str);
  return stack;
}

function dup(stack) {
  let match = pop(stack);
  return push(stack, match[0]);
}

function swap(stack) {
  let match = pop(stack);
  let match$1 = pop(match[1]);
  return push(push(match$1[1], match[0]), match$1[0]);
}

function drop(stack) {
  return pop(stack)[1];
}

let empty = {
  TAG: "Contents",
  _0: /* [] */0
};

function one(__x) {
  return push(__x, 1);
}

function two(__x) {
  return push(__x, 2);
}

function three(__x) {
  return push(__x, 3);
}

function four(__x) {
  return push(__x, 4);
}

function five(__x) {
  return push(__x, 5);
}

function mul$1(__x) {
  return binary(mul, __x);
}

function add$1(__x) {
  return binary(add, __x);
}

function sub$1(__x) {
  return binary(sub, __x);
}

function div$1(__x) {
  return binary(div, __x);
}

function neg$1(__x) {
  return unary(x => -x | 0, __x);
}

function square(extra) {
  return Stdlib__Function.compose(dup, mul$1, extra);
}

function cube(extra) {
  return Stdlib__Function.compose4(dup, dup, mul$1, mul$1, extra);
}

function sum_numbers_upto(extra) {
  return Stdlib__Function.compose(extra => Stdlib__Function.compose4(dup, one, add$1, mul$1, extra), extra => Stdlib__Function.compose(two, div$1, extra), extra);
}

let StackInt = {
  push: push,
  pop: pop,
  binary: binary,
  unary: unary,
  show: show,
  show2: show2,
  dup: dup,
  swap: swap,
  drop: drop,
  empty: empty,
  start: empty,
  one: one,
  two: two,
  three: three,
  four: four,
  five: five,
  mul: mul$1,
  add: add$1,
  sub: sub$1,
  div: div$1,
  neg: neg$1,
  compose: Stdlib__Function.compose,
  compose4: Stdlib__Function.compose4,
  square: square,
  cube: cube,
  sum_numbers_upto: sum_numbers_upto
};

function add$2(x, y) {
  return x + y;
}

function mul$2(x, y) {
  return x * y;
}

function sub$2(x, y) {
  return x - y;
}

function div$2(x, y) {
  return x / y;
}

function neg$2(x) {
  return 0.0 - x;
}

let FloatOps = {
  one: 1.0,
  two: 2.0,
  three: 3.0,
  four: 4.0,
  five: 5.0,
  add: add$2,
  mul: mul$2,
  sub: sub$2,
  div: div$2,
  neg: neg$2
};

function push$1(contents, x) {
  return {
    TAG: "Contents",
    _0: {
      hd: x,
      tl: contents._0
    }
  };
}

function pop$1(contents) {
  let contents$1 = contents._0;
  if (contents$1) {
    let newStack = {
      TAG: "Contents",
      _0: contents$1.tl
    };
    return [
      contents$1.hd,
      newStack
    ];
  }
  throw {
    RE_EXN_ID: "Not_found",
    Error: new Error()
  };
}

function binary$1(mathFn, stack) {
  let match = pop$1(stack);
  let match$1 = pop$1(match[1]);
  let z = mathFn(match$1[0], match[0]);
  return push$1(match$1[1], z);
}

function unary$1(f, stack) {
  let match = pop$1(stack);
  return push$1(match[1], f(match[0]));
}

function show$1(stack) {
  let match = pop$1(stack);
  console.log(match[0]);
  return stack;
}

function show2$1(stack, str) {
  let match = pop$1(stack);
  console.log(match[0], str);
  return stack;
}

function dup$1(stack) {
  let match = pop$1(stack);
  return push$1(stack, match[0]);
}

function swap$1(stack) {
  let match = pop$1(stack);
  let match$1 = pop$1(match[1]);
  return push$1(push$1(match$1[1], match[0]), match$1[0]);
}

function drop$1(stack) {
  return pop$1(stack)[1];
}

let empty$1 = {
  TAG: "Contents",
  _0: /* [] */0
};

function one$1(__x) {
  return push$1(__x, 1.0);
}

function two$1(__x) {
  return push$1(__x, 2.0);
}

function three$1(__x) {
  return push$1(__x, 3.0);
}

function four$1(__x) {
  return push$1(__x, 4.0);
}

function five$1(__x) {
  return push$1(__x, 5.0);
}

function mul$3(__x) {
  return binary$1(mul$2, __x);
}

function add$3(__x) {
  return binary$1(add$2, __x);
}

function sub$3(__x) {
  return binary$1(sub$2, __x);
}

function div$3(__x) {
  return binary$1(div$2, __x);
}

function neg$3(__x) {
  return unary$1(x => 0.0 - x, __x);
}

function square$1(extra) {
  return Stdlib__Function.compose(dup$1, mul$3, extra);
}

function cube$1(extra) {
  return Stdlib__Function.compose4(dup$1, dup$1, mul$3, mul$3, extra);
}

function sum_numbers_upto$1(extra) {
  return Stdlib__Function.compose(extra => Stdlib__Function.compose4(dup$1, one$1, add$3, mul$3, extra), extra => Stdlib__Function.compose(two$1, div$3, extra), extra);
}

let StackFloat = {
  push: push$1,
  pop: pop$1,
  binary: binary$1,
  unary: unary$1,
  show: show$1,
  show2: show2$1,
  dup: dup$1,
  swap: swap$1,
  drop: drop$1,
  empty: empty$1,
  start: empty$1,
  one: one$1,
  two: two$1,
  three: three$1,
  four: four$1,
  five: five$1,
  mul: mul$3,
  add: add$3,
  sub: sub$3,
  div: div$3,
  neg: neg$3,
  compose: Stdlib__Function.compose,
  compose4: Stdlib__Function.compose4,
  square: square$1,
  cube: cube$1,
  sum_numbers_upto: sum_numbers_upto$1
};

export {
  MakeStack,
  IntOps,
  StackInt,
  FloatOps,
  StackFloat,
}
/* No side effect */
