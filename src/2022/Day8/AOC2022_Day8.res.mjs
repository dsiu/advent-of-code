// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Utils from "../../Utils.res.mjs";
import * as Stdlib__Int from "@dsiu/rescript-stdlib-fp/src/Stdlib__Int.res.mjs";
import * as Stdlib__Array from "@dsiu/rescript-stdlib-fp/src/Stdlib__Array.res.mjs";

function log(prim) {
  console.log(prim);
}

function isVisible(param) {
  return param._1;
}

function treeHeight(param) {
  return param._0;
}

function setVisibility(row) {
  let vis = (param, param$1) => {
    let height = param$1._0;
    let tagged = param[1];
    let highest = param[0];
    if (height > highest) {
      return [
        height,
        [{
            TAG: "Tree",
            _0: height,
            _1: true
          }].concat(tagged)
      ];
    } else {
      return [
        highest,
        [{
            TAG: "Tree",
            _0: height,
            _1: param$1._1
          }].concat(tagged)
      ];
    }
  };
  return Stdlib__Array.reduce(row, [
      -1,
      []
    ], vis)[1].toReversed();
}

function setVisibilityOrient(__x) {
  return __x.map(setVisibility);
}

function setVisibilityForest(forest) {
  let rotate = x => Stdlib__Array.transpose(x).map(prim => prim.toReversed());
  let f = Utils.compose(setVisibilityOrient, rotate);
  return f(f(f(f(forest))));
}

function countVisible(forest) {
  return [].concat(...forest).filter(isVisible).length;
}

let part1 = Utils.compose(setVisibilityForest, countVisible);

function tracks(forest, row, col) {
  let match = Stdlib__Array.splitAt(Stdlib__Array.getUnsafe(forest, row), col);
  let match$1 = Stdlib__Array.splitAt(Stdlib__Array.getUnsafe(Stdlib__Array.transpose(forest), col), row);
  return [
    match[0].toReversed(),
    Stdlib__Array.drop(match[1], 1),
    match$1[0].toReversed(),
    Stdlib__Array.drop(match$1[1], 1)
  ];
}

function takeWhile1(xs, f) {
  if (xs.length === 0) {
    return [];
  }
  let h = Stdlib__Array.headUnsafe(xs);
  let t = Stdlib__Array.tail(xs);
  let match = f(h);
  if (match) {
    return [h].concat(takeWhile1(t, f));
  } else {
    return [h];
  }
}

function viewDistance(trees, h) {
  return takeWhile1(trees.map(treeHeight), x => x < h).length;
}

function scenicScore(forest, row, col) {
  let directions = tracks(forest, row, col);
  let h = treeHeight(Stdlib__Array.getUnsafe(Stdlib__Array.getUnsafe(forest, row), col));
  return Stdlib__Array.reduce(directions.map(__x => viewDistance(__x, h)), 1, (a, x) => Math.imul(a, x));
}

function part2(forest) {
  let id = prim => prim;
  let nrows = forest.length;
  let ncols = Stdlib__Array.headUnsafe(forest).length;
  return Utils.maxIntInArray(Stdlib__Array.combination2(Stdlib__Array.makeBy(nrows - 1 | 0, id), Stdlib__Array.makeBy(ncols - 1 | 0, id), (r, c) => scenicScore(forest, r, c)));
}

function parse(data) {
  return Utils.splitNewline(data).map(x => Utils.splitChars(x.trim()).map(x => ({
    TAG: "Tree",
    _0: Stdlib__Int.fromString(x, 10),
    _1: false
  })));
}

function solvePart1(data) {
  return part1(parse(data));
}

function solvePart2(data) {
  return part2(parse(data));
}

let A;

let O;

export {
  log,
  A,
  O,
  isVisible,
  treeHeight,
  setVisibility,
  setVisibilityOrient,
  setVisibilityForest,
  countVisible,
  part1,
  tracks,
  takeWhile1,
  viewDistance,
  scenicScore,
  part2,
  parse,
  solvePart1,
  solvePart2,
}
/* part1 Not a pure module */
