// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Caml_format from "rescript/lib/es6/caml_format.js";
import * as Stdlib_Array from "@dsiu/rescript-stdlib-fp/src/Stdlib_Array.mjs";
import * as Stdlib_Option from "@dsiu/rescript-stdlib-fp/src/Stdlib_Option.mjs";
import * as Stdlib_Function from "@dsiu/rescript-stdlib-fp/src/Stdlib_Function.mjs";
import * as Utils$AdventOfCode from "../../Utils.mjs";

function log(prim) {
  console.log(prim);
}

function isVisible(param) {
  return param._1;
}

function treeHeight(param) {
  return param._0;
}

function setVisibility(row) {
  var vis = function (param, param$1) {
    var height = param$1._0;
    var tagged = param[1];
    var highest = param[0];
    if (height > highest) {
      return [
              height,
              Stdlib_Array.concat([/* Tree */{
                      _0: height,
                      _1: true
                    }], tagged)
            ];
    } else {
      return [
              highest,
              Stdlib_Array.concat([/* Tree */{
                      _0: height,
                      _1: param$1._1
                    }], tagged)
            ];
    }
  };
  return Stdlib_Array.reverse(Stdlib_Array.reduce(row, [
                    -1,
                    []
                  ], vis)[1]);
}

function setVisibilityOrient(__x) {
  return Stdlib_Array.map(__x, setVisibility);
}

function setVisibilityForest(forest) {
  var rotate = function (x) {
    return Stdlib_Array.map(Utils$AdventOfCode.transpose(x), Stdlib_Array.reverse);
  };
  return Utils$AdventOfCode.compose(setVisibilityOrient, rotate, Utils$AdventOfCode.compose(setVisibilityOrient, rotate, Utils$AdventOfCode.compose(setVisibilityOrient, rotate, Utils$AdventOfCode.compose(setVisibilityOrient, rotate, forest))));
}

function countVisible(forest) {
  return Stdlib_Array.keep(Stdlib_Array.concatMany(forest), isVisible).length;
}

function part1(param) {
  return Utils$AdventOfCode.compose(setVisibilityForest, countVisible, param);
}

function tracks(forest, row, col) {
  var match = Stdlib_Option.getExn(Stdlib_Array.splitAt(Stdlib_Array.getExn(forest, row), col));
  var match$1 = Stdlib_Option.getExn(Stdlib_Array.splitAt(Stdlib_Array.getExn(Utils$AdventOfCode.transpose(forest), col), row));
  return [
          Stdlib_Array.reverse(match[0]),
          Stdlib_Array.drop(match[1], 1),
          Stdlib_Array.reverse(match$1[0]),
          Stdlib_Array.drop(match$1[1], 1)
        ];
}

function takeWhile1(xs, f) {
  if (xs.length === 0) {
    return [];
  }
  var h = Stdlib_Array.head(xs);
  var t = Stdlib_Array.tail(xs);
  var match = Curry._1(f, h);
  if (match) {
    return Stdlib_Array.concat([h], takeWhile1(t, f));
  } else {
    return [h];
  }
}

function viewDistance(trees, h) {
  return takeWhile1(Stdlib_Array.map(trees, treeHeight), (function (x) {
                return x < h;
              })).length;
}

function scenicScore(forest, row, col) {
  var directions = tracks(forest, row, col);
  var h = treeHeight(Stdlib_Array.getExn(Stdlib_Array.getExn(forest, row), col));
  return Stdlib_Array.reduce(Stdlib_Array.map(directions, (function (__x) {
                    return viewDistance(__x, h);
                  })), 1, (function (a, x) {
                return Math.imul(a, x);
              }));
}

function part2(forest) {
  var nrows = forest.length;
  var ncols = Stdlib_Array.head(forest).length;
  return Utils$AdventOfCode.maxIntInArray(Stdlib_Array.combination2(Stdlib_Array.makeBy(nrows - 1 | 0, Stdlib_Function.identity), Stdlib_Array.makeBy(ncols - 1 | 0, Stdlib_Function.identity), (function (r, c) {
                    return scenicScore(forest, r, c);
                  })));
}

function parse(data) {
  return Stdlib_Array.map(Utils$AdventOfCode.splitNewline(data), (function (x) {
                return Stdlib_Array.map(Utils$AdventOfCode.splitChars(x.trim()), (function (x) {
                              return /* Tree */{
                                      _0: Caml_format.int_of_string(x),
                                      _1: false
                                    };
                            }));
              }));
}

function solvePart1(data) {
  return Utils$AdventOfCode.compose(setVisibilityForest, countVisible, parse(data));
}

function solvePart2(data) {
  return part2(parse(data));
}

var A;

var O;

export {
  log ,
  A ,
  O ,
  isVisible ,
  treeHeight ,
  setVisibility ,
  setVisibilityOrient ,
  setVisibilityForest ,
  countVisible ,
  part1 ,
  tracks ,
  takeWhile1 ,
  viewDistance ,
  scenicScore ,
  part2 ,
  parse ,
  solvePart1 ,
  solvePart2 ,
}
/* No side effect */
