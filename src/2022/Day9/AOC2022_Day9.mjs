// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Pervasives from "rescript/lib/es6/Pervasives.js";
import * as Stdlib__Int from "@dsiu/rescript-stdlib-fp/src/Stdlib__Int.mjs";
import * as Primitive_int from "rescript/lib/es6/Primitive_int.js";
import * as Stdlib__Array from "@dsiu/rescript-stdlib-fp/src/Stdlib__Array.mjs";
import * as TableclothSet from "@dsiu/rescript-stdlib-fp/src/Tablecloth/TableclothSet.mjs";
import * as Stdlib__Option from "@dsiu/rescript-stdlib-fp/src/Stdlib__Option.mjs";
import * as Utils$AdventOfCode from "../../Utils.mjs";
import * as Primitive_exceptions from "rescript/lib/es6/Primitive_exceptions.js";
import * as Coord_V2$AdventOfCode from "../../Coord_V2.mjs";

function log(prim) {
  console.log(prim);
}

let emptyPositionSet = TableclothSet.empty({
  comparator: Coord_V2$AdventOfCode.comparator
});

function newRope(n) {
  return {
    TAG: "Rope",
    headK: [
      0,
      0
    ],
    knots: Stdlib__Array.make(n, [
      0,
      0
    ]),
    trace: TableclothSet.add(emptyPositionSet, [
      0,
      0
    ])
  };
}

let ParseError = /* @__PURE__ */Primitive_exceptions.create("AOC2022_Day9-AdventOfCode.ParseError");

function expandPath(directions) {
  let expandStep = step => {
    switch (step.TAG) {
      case "U" :
        return Stdlib__Array.make(step._0, [
          0,
          1
        ]);
      case "R" :
        return Stdlib__Array.make(step._0, [
          1,
          0
        ]);
      case "D" :
        return Stdlib__Array.make(step._0, [
          0,
          -1
        ]);
      case "L" :
        return Stdlib__Array.make(step._0, [
          -1,
          0
        ]);
    }
  };
  return directions.flatMap(expandStep);
}

function manhattan(p1, p2) {
  return Primitive_int.max(Pervasives.abs(p1[0] - p2[0] | 0), Pervasives.abs(p1[1] - p2[1] | 0));
}

function touching(p1, p2) {
  return manhattan(p1, p2) <= 1;
}

function sign(n) {
  return Primitive_int.compare(n, 0);
}

function towards(p1, p2) {
  return [
    Primitive_int.compare(p2[0] - p1[0] | 0, 0),
    Primitive_int.compare(p2[1] - p1[1] | 0, 0)
  ];
}

function knotStep(param, kt) {
  let h = param[0];
  let kt$p = touching(kt, h) ? kt : Coord_V2$AdventOfCode.add(kt, towards(kt, h));
  return [
    kt$p,
    [kt$p].concat(param[1])
  ];
}

function ropeStep(rope, step) {
  let h = Coord_V2$AdventOfCode.add(rope.headK, step);
  let match = Stdlib__Array.reduce(rope.knots, [
    h,
    []
  ], knotStep);
  return {
    TAG: "Rope",
    headK: h,
    knots: match[1].toReversed(),
    trace: TableclothSet.add(rope.trace, match[0])
  };
}

function ropeSteps(rope, steps) {
  return Stdlib__Array.reduce(steps, rope, ropeStep);
}

function part1(steps) {
  let rope = Stdlib__Array.reduce(steps, newRope(1), ropeStep);
  return TableclothSet.length(rope.trace);
}

function part2(steps) {
  let rope = Stdlib__Array.reduce(steps, newRope(9), ropeStep);
  return TableclothSet.length(rope.trace);
}

function parse(data) {
  return Utils$AdventOfCode.splitNewline(data).map(x => {
    let match = x.trim().split(" ");
    if (match.length !== 2) {
      throw {
        RE_EXN_ID: "Match_failure",
        _1: [
          "AOC2022_Day9.res",
          99,
          8
        ],
        Error: new Error()
      };
    }
    let dStr = match[0];
    let steps = match[1];
    let match$1 = Stdlib__Option.getExn(Stdlib__Int.fromString(steps, undefined), undefined);
    switch (dStr) {
      case "D" :
        return {
          TAG: "D",
          _0: match$1
        };
      case "L" :
        return {
          TAG: "L",
          _0: match$1
        };
      case "R" :
        return {
          TAG: "R",
          _0: match$1
        };
      case "U" :
        return {
          TAG: "U",
          _0: match$1
        };
      default:
        throw {
          RE_EXN_ID: ParseError,
          _1: dStr + steps,
          Error: new Error()
        };
    }
  });
}

function solvePart1(data) {
  return part1(expandPath(parse(data)));
}

function solvePart2(data) {
  return part2(expandPath(parse(data)));
}

let A;

let TC;

let Position;

export {
  log,
  A,
  TC,
  Position,
  emptyPositionSet,
  newRope,
  ParseError,
  expandPath,
  manhattan,
  touching,
  sign,
  towards,
  knotStep,
  ropeStep,
  ropeSteps,
  part1,
  part2,
  parse,
  solvePart1,
  solvePart2,
}
/* emptyPositionSet Not a pure module */
