// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Utils from "../../Utils.res.mjs";
import * as Stdlib__Array from "@dsiu/rescript-stdlib-fp/src/Stdlib__Array.res.mjs";

function log(prim) {
  console.log(prim);
}

function contains(param, param$1) {
  if (param._0 <= param$1._0) {
    return param._1 >= param$1._1;
  } else {
    return false;
  }
}

function before(param, param$1) {
  return param._1 < param$1._0;
}

function hasContainment(x, y) {
  if (contains(x, y)) {
    return true;
  } else {
    return contains(y, x);
  }
}

function disjoint(x, y) {
  if (before(x, y)) {
    return true;
  } else {
    return before(y, x);
  }
}

function overlaps(x, y) {
  return !disjoint(x, y);
}

function parse(data) {
  return Utils.splitNewline(data).map(l => l.trim().split(",").map(p => {
    let r = p.split("-").map(Utils.intFromStringExn);
    return {
      TAG: "Interval",
      _0: Stdlib__Array.getUnsafe(r, 0),
      _1: Stdlib__Array.getUnsafe(r, 1)
    };
  })).map(l => [
    Stdlib__Array.getUnsafe(l, 0),
    Stdlib__Array.getUnsafe(l, 1)
  ]);
}

function count(xs, fn) {
  return xs.filter(fn).length;
}

function part1(xs) {
  return xs.filter(param => hasContainment(param[0], param[1])).length;
}

function part2(xs) {
  return xs.filter(param => !disjoint(param[0], param[1])).length;
}

function solvePart1(data) {
  return part1(parse(data));
}

function solvePart2(data) {
  return part2(parse(data));
}

let A;

let S;

export {
  A,
  S,
  log,
  contains,
  before,
  hasContainment,
  disjoint,
  overlaps,
  parse,
  count,
  part1,
  part2,
  solvePart1,
  solvePart2,
}
/* Utils Not a pure module */
