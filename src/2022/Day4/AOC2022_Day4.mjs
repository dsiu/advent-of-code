// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Stdlib_Array from "@dsiu/rescript-stdlib-fp/src/Stdlib_Array.mjs";
import * as Utils$AdventOfCode from "../../Utils.mjs";

function log(prim) {
  console.log(prim);
}

function contains(param, param$1) {
  if (param._0 <= param$1._0) {
    return param._1 >= param$1._1;
  } else {
    return false;
  }
}

function before(param, param$1) {
  return param._1 < param$1._0;
}

function hasContainment(x, y) {
  if (contains(x, y)) {
    return true;
  } else {
    return contains(y, x);
  }
}

function disjoint(x, y) {
  if (before(x, y)) {
    return true;
  } else {
    return before(y, x);
  }
}

function overlaps(x, y) {
  return !disjoint(x, y);
}

function parse(data) {
  return Stdlib_Array.map(Stdlib_Array.map(Utils$AdventOfCode.splitNewline(data), (function (l) {
                    return Stdlib_Array.map(l.trim().split(","), (function (p) {
                                  var r = Stdlib_Array.map(p.split("-"), Utils$AdventOfCode.intFromStringExn);
                                  return {
                                          TAG: "Interval",
                                          _0: Stdlib_Array.getUnsafe(r, 0),
                                          _1: Stdlib_Array.getUnsafe(r, 1)
                                        };
                                }));
                  })), (function (l) {
                return [
                        Stdlib_Array.getUnsafe(l, 0),
                        Stdlib_Array.getUnsafe(l, 1)
                      ];
              }));
}

function count(xs, fn) {
  return Stdlib_Array.length(Stdlib_Array.filter(xs, fn));
}

function part1(xs) {
  return Stdlib_Array.length(Stdlib_Array.filter(xs, (function (param) {
                    return hasContainment(param[0], param[1]);
                  })));
}

function part2(xs) {
  return Stdlib_Array.length(Stdlib_Array.filter(xs, (function (param) {
                    return !disjoint(param[0], param[1]);
                  })));
}

function solvePart1(data) {
  return part1(parse(data));
}

function solvePart2(data) {
  return part2(parse(data));
}

var A;

var S;

export {
  A ,
  S ,
  log ,
  contains ,
  before ,
  hasContainment ,
  disjoint ,
  overlaps ,
  parse ,
  count ,
  part1 ,
  part2 ,
  solvePart1 ,
  solvePart2 ,
}
/* Stdlib_Array Not a pure module */
