// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Relude_Int from "relude/src/Relude_Int.mjs";
import * as Relude_Map from "relude/src/Relude_Map.mjs";
import * as Relude_List from "relude/src/Relude_List.mjs";
import * as Relude_Array from "relude/src/Relude_Array.mjs";
import * as Primitive_int from "rescript/lib/es6/Primitive_int.js";
import * as Relude_Result from "relude/src/Relude_Result.mjs";
import * as Relude_Function from "relude/src/Relude_Function.mjs";
import * as ReludeParse_Parser from "relude-parse/src/ReludeParse_Parser.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function uncurryFn6(fn) {
  return a => (b => (c => (d => (e => (f => fn(a, b, c, d, e, f))))));
}

function makeLiteral(i) {
  return {
    TAG: "Literal",
    _0: i
  };
}

function showExpression(param) {
  let operand = param._1;
  let tmp;
  tmp = param._0 === "Plus" ? " + " : " * ";
  let tmp$1;
  tmp$1 = typeof operand !== "object" ? "old" : operand._0.toString();
  return tmp + tmp$1;
}

let logExp = Relude_Function.compose(log, showExpression);

function makeExpression(op) {
  return operand => ({
    TAG: "Expression",
    _0: op,
    _1: operand
  });
}

let include = Relude_Map.WithOrd(Relude_Int.Ord);

let fromList = include.fromList;

let update = include.update;

let IntMap_Comparable = include.Comparable;

let IntMap_make = include.make;

let IntMap_set = include.set;

let IntMap_singleton = include.singleton;

let IntMap_isEmpty = include.isEmpty;

let IntMap_contains = include.contains;

let IntMap_compareInt = include.compareInt;

let IntMap_compareBy = include.compareBy;

let IntMap_eqBy = include.eqBy;

let IntMap_find = include.find;

let IntMap_forEach = include.forEach;

let IntMap_foldLeft = include.foldLeft;

let IntMap_all = include.all;

let IntMap_any = include.any;

let IntMap_length = include.length;

let IntMap_toArray = include.toArray;

let IntMap_fromArray = include.fromArray;

let IntMap_fromValueArray = include.fromValueArray;

let IntMap_toList = include.toList;

let IntMap_fromValueList = include.fromValueList;

let IntMap_keys = include.keys;

let IntMap_keyArray = include.keyArray;

let IntMap_values = include.values;

let IntMap_valueArray = include.valueArray;

let IntMap_minKey = include.minKey;

let IntMap_maxKey = include.maxKey;

let IntMap_min = include.min;

let IntMap_max = include.max;

let IntMap_get = include.get;

let IntMap_getOrElse = include.getOrElse;

let IntMap_remove = include.remove;

let IntMap_removeMany = include.removeMany;

let IntMap_merge = include.merge;

let IntMap_mergeMany = include.mergeMany;

let IntMap_filter = include.filter;

let IntMap_keep = include.keep;

let IntMap_filterNot = include.filterNot;

let IntMap_reject = include.reject;

let IntMap_partition = include.partition;

let IntMap_map = include.map;

let IntMap_mapWithKey = include.mapWithKey;

let IntMap_groupListBy = include.groupListBy;

let IntMap_groupArrayBy = include.groupArrayBy;

let IntMap = {
  Comparable: IntMap_Comparable,
  make: IntMap_make,
  set: IntMap_set,
  singleton: IntMap_singleton,
  isEmpty: IntMap_isEmpty,
  contains: IntMap_contains,
  compareInt: IntMap_compareInt,
  compareBy: IntMap_compareBy,
  eqBy: IntMap_eqBy,
  find: IntMap_find,
  forEach: IntMap_forEach,
  foldLeft: IntMap_foldLeft,
  all: IntMap_all,
  any: IntMap_any,
  length: IntMap_length,
  toArray: IntMap_toArray,
  fromArray: IntMap_fromArray,
  fromValueArray: IntMap_fromValueArray,
  toList: IntMap_toList,
  fromList: fromList,
  fromValueList: IntMap_fromValueList,
  keys: IntMap_keys,
  keyArray: IntMap_keyArray,
  values: IntMap_values,
  valueArray: IntMap_valueArray,
  minKey: IntMap_minKey,
  maxKey: IntMap_maxKey,
  min: IntMap_min,
  max: IntMap_max,
  get: IntMap_get,
  getOrElse: IntMap_getOrElse,
  remove: IntMap_remove,
  removeMany: IntMap_removeMany,
  update: update,
  merge: IntMap_merge,
  mergeMany: IntMap_mergeMany,
  filter: IntMap_filter,
  keep: IntMap_keep,
  filterNot: IntMap_filterNot,
  reject: IntMap_reject,
  partition: IntMap_partition,
  map: IntMap_map,
  mapWithKey: IntMap_mapWithKey,
  groupListBy: IntMap_groupListBy,
  groupArrayBy: IntMap_groupArrayBy
};

function updateWorry(current, param, threshold) {
  let evalOperand = operand => {
    if (typeof operand !== "object") {
      return current;
    } else {
      return operand._0;
    }
  };
  let n = evalOperand(param._1);
  if (param._0 === "Plus") {
    return threshold(current + n | 0);
  } else {
    return threshold(Math.imul(current, n));
  }
}

function worryTest(divisor, worry) {
  return Primitive_int.mod_(worry, divisor) === 0;
}

function receivesItem(mId, worry, items) {
  return update(mId, maybeItems => {
    if (maybeItems !== undefined) {
      return Relude_Array.concat(maybeItems, [worry]);
    }
    
  }, items);
}

let mIdP = ReludeParse_Parser.Infix.$less$star(ReludeParse_Parser.Infix.$less$star(ReludeParse_Parser.Infix.$star$great(ReludeParse_Parser.str("Monkey "), ReludeParse_Parser.anyInt), ReludeParse_Parser.str(":")), ReludeParse_Parser.eol);

let startingP = ReludeParse_Parser.Infix.$less$star(ReludeParse_Parser.Infix.$star$great(ReludeParse_Parser.str("  Starting items: "), ReludeParse_Parser.sepBy(ReludeParse_Parser.str(", "), ReludeParse_Parser.anyInt)), ReludeParse_Parser.eol);

let opP = ReludeParse_Parser.Infix.$less$pipe$great(ReludeParse_Parser.Infix.$less$("Plus", ReludeParse_Parser.str("+")), ReludeParse_Parser.Infix.$less$("Times", ReludeParse_Parser.str("*")));

let operandP = ReludeParse_Parser.Infix.$less$pipe$great(ReludeParse_Parser.Infix.$less$$great(makeLiteral, ReludeParse_Parser.anyInt), ReludeParse_Parser.Infix.$less$("Old", ReludeParse_Parser.str("old")));

let expressionP = ReludeParse_Parser.Infix.$less$star$great(ReludeParse_Parser.Infix.$less$$great(makeExpression, ReludeParse_Parser.Infix.$less$star(opP, ReludeParse_Parser.str(" "))), operandP);

let operatorP = ReludeParse_Parser.Infix.$less$star(ReludeParse_Parser.Infix.$star$great(ReludeParse_Parser.str("  Operation: new = old "), expressionP), ReludeParse_Parser.eol);

let testP = ReludeParse_Parser.Infix.$less$star(ReludeParse_Parser.Infix.$star$great(ReludeParse_Parser.str("  Test: divisible by "), ReludeParse_Parser.anyInt), ReludeParse_Parser.eol);

let trueTargetP = ReludeParse_Parser.Infix.$less$star(ReludeParse_Parser.Infix.$star$great(ReludeParse_Parser.str("    If true: throw to monkey "), ReludeParse_Parser.anyInt), ReludeParse_Parser.eol);

let falseTargetP = ReludeParse_Parser.Infix.$star$great(ReludeParse_Parser.str("    If false: throw to monkey "), ReludeParse_Parser.anyInt);

function mkMonkeyPair(mId, holding, operation, test, trueTarget, falseTarget) {
  return [
    [
      mId,
      {
        TAG: "MonkeyCode",
        operation: operation,
        test: test,
        trueTarget: trueTarget,
        falseTarget: falseTarget
      }
    ],
    [
      mId,
      holding
    ]
  ];
}

let monkeyP = ReludeParse_Parser.Infix.$less$star$great(ReludeParse_Parser.Infix.$less$star$great(ReludeParse_Parser.Infix.$less$star$great(ReludeParse_Parser.Infix.$less$star$great(ReludeParse_Parser.Infix.$less$star$great(ReludeParse_Parser.Infix.$less$$great(uncurryFn6(mkMonkeyPair), mIdP), startingP), operatorP), testP), trueTargetP), falseTargetP);

function makeMonkeyMaps(monkeys) {
  return [
    fromList(Relude_List.map(prim => prim[0], monkeys)),
    fromList(Relude_List.map(prim => prim[1], monkeys))
  ];
}

let monkeysP = ReludeParse_Parser.Infix.$less$$great(makeMonkeyMaps, ReludeParse_Parser.sepBy(ReludeParse_Parser.Infix.$less$star(ReludeParse_Parser.eol, ReludeParse_Parser.eol), monkeyP));

function parse(s) {
  return ReludeParse_Parser.runParser(s, monkeysP);
}

let MonkeyParser = {
  P: undefined,
  mIdP: mIdP,
  startingP: startingP,
  operatorP: operatorP,
  testP: testP,
  trueTargetP: trueTargetP,
  falseTargetP: falseTargetP,
  monkeyP: monkeyP,
  monkeysP: monkeysP,
  parse: parse
};

function solvePart1(data) {
  let result = ReludeParse_Parser.runParser(data, monkeysP);
  Relude_Result.tap(log, result);
  return 1;
}

function solvePart2(data) {
  return 2;
}

let S;

let A;

let L;

let O;

let R;

let F;

let compose = Relude_Function.compose;

export {
  log,
  log2,
  S,
  A,
  L,
  O,
  R,
  F,
  compose,
  uncurryFn6,
  makeLiteral,
  showExpression,
  logExp,
  makeExpression,
  IntMap,
  updateWorry,
  worryTest,
  receivesItem,
  MonkeyParser,
  solvePart1,
  solvePart2,
}
/* logExp Not a pure module */
