// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";
import * as Relude_Int from "relude/src/Relude_Int.mjs";
import * as Relude_Map from "relude/src/Relude_Map.mjs";
import * as Relude_List from "relude/src/Relude_List.mjs";
import * as Relude_Array from "relude/src/Relude_Array.mjs";
import * as Relude_Result from "relude/src/Relude_Result.mjs";
import * as Relude_Function from "relude/src/Relude_Function.mjs";
import * as ReludeParse_Parser from "relude-parse/src/ReludeParse_Parser.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function makeLiteral(i) {
  return {
          TAG: "Literal",
          _0: i
        };
}

function showExpression(param) {
  var operand = param._1;
  var tmp;
  tmp = param._0 === "Plus" ? " + " : " * ";
  var tmp$1;
  tmp$1 = typeof operand !== "object" ? "old" : String(operand._0);
  return tmp + tmp$1;
}

var logExp = Relude_Function.compose(log, showExpression);

function makeExpression(op) {
  return function (operand) {
    return {
            TAG: "Expression",
            _0: op,
            _1: operand
          };
  };
}

var include = Relude_Map.WithOrd(Relude_Int.Ord);

var fromList = include.fromList;

var update = include.update;

var IntMap_Comparable = include.Comparable;

var IntMap_make = include.make;

var IntMap_set = include.set;

var IntMap_singleton = include.singleton;

var IntMap_isEmpty = include.isEmpty;

var IntMap_contains = include.contains;

var IntMap_compareInt = include.compareInt;

var IntMap_compareBy = include.compareBy;

var IntMap_eqBy = include.eqBy;

var IntMap_find = include.find;

var IntMap_forEach = include.forEach;

var IntMap_foldLeft = include.foldLeft;

var IntMap_all = include.all;

var IntMap_any = include.any;

var IntMap_length = include.length;

var IntMap_toArray = include.toArray;

var IntMap_fromArray = include.fromArray;

var IntMap_fromValueArray = include.fromValueArray;

var IntMap_toList = include.toList;

var IntMap_fromValueList = include.fromValueList;

var IntMap_keys = include.keys;

var IntMap_keyArray = include.keyArray;

var IntMap_values = include.values;

var IntMap_valueArray = include.valueArray;

var IntMap_minKey = include.minKey;

var IntMap_maxKey = include.maxKey;

var IntMap_min = include.min;

var IntMap_max = include.max;

var IntMap_get = include.get;

var IntMap_getOrElse = include.getOrElse;

var IntMap_remove = include.remove;

var IntMap_removeMany = include.removeMany;

var IntMap_merge = include.merge;

var IntMap_mergeMany = include.mergeMany;

var IntMap_filter = include.filter;

var IntMap_keep = include.keep;

var IntMap_filterNot = include.filterNot;

var IntMap_reject = include.reject;

var IntMap_partition = include.partition;

var IntMap_map = include.map;

var IntMap_mapWithKey = include.mapWithKey;

var IntMap_groupListBy = include.groupListBy;

var IntMap_groupArrayBy = include.groupArrayBy;

var IntMap = {
  Comparable: IntMap_Comparable,
  make: IntMap_make,
  set: IntMap_set,
  singleton: IntMap_singleton,
  isEmpty: IntMap_isEmpty,
  contains: IntMap_contains,
  compareInt: IntMap_compareInt,
  compareBy: IntMap_compareBy,
  eqBy: IntMap_eqBy,
  find: IntMap_find,
  forEach: IntMap_forEach,
  foldLeft: IntMap_foldLeft,
  all: IntMap_all,
  any: IntMap_any,
  length: IntMap_length,
  toArray: IntMap_toArray,
  fromArray: IntMap_fromArray,
  fromValueArray: IntMap_fromValueArray,
  toList: IntMap_toList,
  fromList: fromList,
  fromValueList: IntMap_fromValueList,
  keys: IntMap_keys,
  keyArray: IntMap_keyArray,
  values: IntMap_values,
  valueArray: IntMap_valueArray,
  minKey: IntMap_minKey,
  maxKey: IntMap_maxKey,
  min: IntMap_min,
  max: IntMap_max,
  get: IntMap_get,
  getOrElse: IntMap_getOrElse,
  remove: IntMap_remove,
  removeMany: IntMap_removeMany,
  update: update,
  merge: IntMap_merge,
  mergeMany: IntMap_mergeMany,
  filter: IntMap_filter,
  keep: IntMap_keep,
  filterNot: IntMap_filterNot,
  reject: IntMap_reject,
  partition: IntMap_partition,
  map: IntMap_map,
  mapWithKey: IntMap_mapWithKey,
  groupListBy: IntMap_groupListBy,
  groupArrayBy: IntMap_groupArrayBy
};

function updateWorry(current, param, threshold) {
  var evalOperand = function (operand) {
    if (typeof operand !== "object") {
      return current;
    } else {
      return operand._0;
    }
  };
  var n = evalOperand(param._1);
  if (param._0 === "Plus") {
    return threshold(current + n | 0);
  } else {
    return threshold(Math.imul(current, n));
  }
}

function worryTest(divisor, worry) {
  return Caml_int32.mod_(worry, divisor) === 0;
}

function receivesItem(mId, worry, items) {
  return update(mId, (function (maybeItems) {
                if (maybeItems !== undefined) {
                  return Relude_Array.concat(maybeItems, [worry]);
                }
                
              }), items);
}

var mIdP = ReludeParse_Parser.Infix.$less$star(ReludeParse_Parser.Infix.$less$star(ReludeParse_Parser.Infix.$star$great(ReludeParse_Parser.str("Monkey "), ReludeParse_Parser.anyInt), ReludeParse_Parser.str(":")), ReludeParse_Parser.eol);

var startingP = ReludeParse_Parser.Infix.$less$star(ReludeParse_Parser.Infix.$star$great(ReludeParse_Parser.str("  Starting items: "), (function (__x) {
              return ReludeParse_Parser.sepBy(ReludeParse_Parser.str(", "), __x);
            })(ReludeParse_Parser.anyInt)), ReludeParse_Parser.eol);

var opP = ReludeParse_Parser.Infix.$less$pipe$great(ReludeParse_Parser.Infix.$less$("Plus", ReludeParse_Parser.str("+")), ReludeParse_Parser.Infix.$less$("Times", ReludeParse_Parser.str("*")));

var operandP = ReludeParse_Parser.Infix.$less$pipe$great(ReludeParse_Parser.Infix.$less$$great(makeLiteral, ReludeParse_Parser.anyInt), ReludeParse_Parser.Infix.$less$("Old", ReludeParse_Parser.str("old")));

var expressionP = ReludeParse_Parser.Infix.$less$star$great(ReludeParse_Parser.Infix.$less$$great(makeExpression, ReludeParse_Parser.Infix.$less$star(opP, ReludeParse_Parser.str(" "))), operandP);

var operatorP = ReludeParse_Parser.Infix.$less$star(ReludeParse_Parser.Infix.$star$great(ReludeParse_Parser.str("  Operation: new = old "), expressionP), ReludeParse_Parser.eol);

var testP = ReludeParse_Parser.Infix.$less$star(ReludeParse_Parser.Infix.$star$great(ReludeParse_Parser.str("  Test: divisible by "), ReludeParse_Parser.anyInt), ReludeParse_Parser.eol);

var trueTargetP = ReludeParse_Parser.Infix.$less$star(ReludeParse_Parser.Infix.$star$great(ReludeParse_Parser.str("    If true: throw to monkey "), ReludeParse_Parser.anyInt), ReludeParse_Parser.eol);

var falseTargetP = ReludeParse_Parser.Infix.$star$great(ReludeParse_Parser.str("    If false: throw to monkey "), ReludeParse_Parser.anyInt);

function mkMonkeyPair(mId) {
  return function (holding) {
    return function (operation) {
      return function (test) {
        return function (trueTarget) {
          return function (falseTarget) {
            return [
                    [
                      mId,
                      {
                        TAG: "MonkeyCode",
                        operation: operation,
                        test: test,
                        trueTarget: trueTarget,
                        falseTarget: falseTarget
                      }
                    ],
                    [
                      mId,
                      holding
                    ]
                  ];
          };
        };
      };
    };
  };
}

var monkeyP = ReludeParse_Parser.Infix.$less$star$great(ReludeParse_Parser.Infix.$less$star$great(ReludeParse_Parser.Infix.$less$star$great(ReludeParse_Parser.Infix.$less$star$great(ReludeParse_Parser.Infix.$less$star$great(ReludeParse_Parser.Infix.$less$$great(mkMonkeyPair, mIdP), startingP), operatorP), testP), trueTargetP), falseTargetP);

function makeMonkeyMaps(monkeys) {
  return [
          fromList(Relude_List.map((function (prim) {
                      return prim[0];
                    }), monkeys)),
          fromList(Relude_List.map((function (prim) {
                      return prim[1];
                    }), monkeys))
        ];
}

var monkeysP = ReludeParse_Parser.Infix.$less$$great(makeMonkeyMaps, (function (__x) {
          return ReludeParse_Parser.sepBy(ReludeParse_Parser.Infix.$less$star(ReludeParse_Parser.eol, ReludeParse_Parser.eol), __x);
        })(monkeyP));

function parse(s) {
  return ReludeParse_Parser.runParser(s, monkeysP);
}

var MonkeyParser = {
  P: undefined,
  mIdP: mIdP,
  startingP: startingP,
  operatorP: operatorP,
  testP: testP,
  trueTargetP: trueTargetP,
  falseTargetP: falseTargetP,
  monkeyP: monkeyP,
  monkeysP: monkeysP,
  parse: parse
};

function solvePart1(data) {
  var result = parse(data);
  ((function (__x) {
          return Relude_Result.tap(log, __x);
        })(result));
  return 1;
}

function solvePart2(data) {
  return 2;
}

var S;

var A;

var L;

var O;

var R;

var F;

var compose = Relude_Function.compose;

export {
  log ,
  log2 ,
  S ,
  A ,
  L ,
  O ,
  R ,
  F ,
  compose ,
  makeLiteral ,
  showExpression ,
  logExp ,
  makeExpression ,
  IntMap ,
  updateWorry ,
  worryTest ,
  receivesItem ,
  MonkeyParser ,
  solvePart1 ,
  solvePart2 ,
}
/* logExp Not a pure module */
