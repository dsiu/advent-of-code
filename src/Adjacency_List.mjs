// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Belt_HashMapString from "rescript/lib/es6/belt_HashMapString.js";
import * as Belt_HashSetString from "rescript/lib/es6/belt_HashSetString.js";

function toString(t) {
  var str = {
    contents: ""
  };
  Belt_HashMapString.forEach(t, (function (k, v) {
          str.contents = "" + str.contents + "" + k + ": [ " + Belt_HashSetString.toArray(v).join(",") + " ]\n";
        }));
  return str.contents;
}

function addVertex(t, x) {
  var match = Belt_HashMapString.get(t, x);
  if (match !== undefined) {
    return ;
  } else {
    return Belt_HashMapString.set(t, x, Belt_HashSetString.make(40));
  }
}

var removeVertex = Belt_HashMapString.remove;

function getVertex(t, x) {
  addVertex(t, x);
  var v = Belt_HashMapString.get(t, x);
  if (v !== undefined) {
    return Caml_option.valFromOption(v);
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function addEdge(t, x, y) {
  Belt_HashSetString.add(getVertex(t, x), y);
}

function removeEdge(t, x, y) {
  if (Belt_HashMapString.has(t, x)) {
    return Belt_HashSetString.remove(getVertex(t, x), y);
  }
  
}

function adjacent(t, x, y) {
  var v = Belt_HashMapString.get(t, x);
  if (v !== undefined) {
    return Belt_HashSetString.has(Caml_option.valFromOption(v), y);
  } else {
    return false;
  }
}

function neighbors(t, x) {
  return Belt_Option.getWithDefault(Belt_HashMapString.get(t, x), Belt_HashSetString.make(40));
}

var make = Belt_HashMapString.make;

export {
  make ,
  toString ,
  addVertex ,
  removeVertex ,
  getVertex ,
  addEdge ,
  removeEdge ,
  adjacent ,
  neighbors ,
}
/* No side effect */
