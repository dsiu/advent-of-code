// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_math from "rescript/lib/es6/Js_math.js";
import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/Belt_Option.js";
import * as Primitive_int from "rescript/lib/es6/Primitive_int.js";
import * as Primitive_bigint from "rescript/lib/es6/Primitive_bigint.js";

function mulInv(a, b) {
  let x0 = 0;
  let x1 = 1;
  if (b === 1) {
    return 1;
  }
  let aa = a;
  let bb = b;
  while (aa > 1) {
    let q = Js_math.floor_int(aa / bb);
    let c = Primitive_int.mod_(aa, bb);
    aa = bb;
    bb = c;
    let tmp = x0;
    x0 = x1 - Math.imul(q, x0) | 0;
    x1 = tmp;
  };
  if (x1 < 0) {
    x1 = x1 + b | 0;
  }
  return x1;
}

function crt(rem, num) {
  let sum = 0;
  let prod = Belt_Array.reduce(num, 1, (a, c) => Math.imul(a, c));
  for (let i = 0, i_finish = num.length; i < i_finish; ++i) {
    let ni = Belt_Option.getExn(Belt_Array.get(num, i));
    let ri = Belt_Option.getExn(Belt_Array.get(rem, i));
    let p = Js_math.floor_int(prod / ni);
    sum = sum + Math.imul(Math.imul(ri, p), mulInv(p, ni)) | 0;
  }
  return Primitive_int.mod_(sum, prod);
}

function add(prim0, prim1) {
  return prim0 + prim1;
}

function sub(prim0, prim1) {
  return prim0 - prim1;
}

function mul(prim0, prim1) {
  return prim0 * prim1;
}

function div(prim0, prim1) {
  return prim0 / prim1;
}

let mod = Primitive_bigint.mod_;

function mulInvBigInt(a, b) {
  let x0 = 0n;
  let x1 = 1n;
  if (b === 1n) {
    return 1n;
  }
  let aa = a;
  let bb = b;
  while ((aa > big_one)) {
    let q = aa / bb;
    let c = Primitive_bigint.mod_(aa, bb);
    aa = bb;
    bb = c;
    let tmp = x0;
    x0 = x1 - q * x0;
    x1 = tmp;
  };
  if ((x1 < big_zero)) {
    x1 = x1 + b;
  }
  return x1;
}

function crtBigInt(rem, num) {
  let sum = 0n;
  let prod = Belt_Array.reduce(num, 1n, (a, c) => a * c);
  for (let i = 0, i_finish = num.length; i < i_finish; ++i) {
    let ni = Belt_Option.getExn(Belt_Array.get(num, i));
    let ri = Belt_Option.getExn(Belt_Array.get(rem, i));
    let p = prod / ni;
    sum = sum + ri * p * mulInvBigInt(p, ni);
  }
  return Primitive_bigint.mod_(sum, prod);
}

let big_zero = 0n;

let big_one = 1n;

export {
  mulInv,
  crt,
  big_zero,
  big_one,
  add,
  sub,
  mul,
  div,
  mod,
  mulInvBigInt,
  crtBigInt,
}
/* No side effect */
