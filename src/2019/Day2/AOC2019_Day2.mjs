// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";
import * as Utils$AdventOfCode from "../../Utils.mjs";
import * as Stdlib_Array$AdventOfCode from "../../stdlib/Stdlib_Array.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function parse(data) {
  return Belt_Array.map(data.split(","), Utils$AdventOfCode.intFromStringExn);
}

function getVal(t, pos) {
  return Belt_Array.getExn(t.prog, pos);
}

function saveVal(t, pos, v) {
  Belt_Array.setExn(t.prog, pos, v);
  return t;
}

var InvalidOpCode = /* @__PURE__ */Caml_exceptions.create("AOC2019_Day2-AdventOfCode.IntCode.InvalidOpCode");

function executeInstr(t, instr) {
  var match = instr.op;
  if (match === 1) {
    return saveVal(t, instr.out, Belt_Array.getExn(t.prog, instr.arg1) + Belt_Array.getExn(t.prog, instr.arg2) | 0);
  }
  if (match !== 2) {
    throw {
          RE_EXN_ID: InvalidOpCode,
          _1: instr.op,
          Error: new Error()
        };
  }
  return saveVal(t, instr.out, Math.imul(Belt_Array.getExn(t.prog, instr.arg1), Belt_Array.getExn(t.prog, instr.arg2)));
}

function getInstr(t) {
  var op = Belt_Array.getExn(t.prog, t.pc);
  var arg1 = Belt_Array.getExn(t.prog, t.pc + 1 | 0);
  var arg2 = Belt_Array.getExn(t.prog, t.pc + 2 | 0);
  var out = Belt_Array.getExn(t.prog, t.pc + 3 | 0);
  if (op >= 3) {
    if (op === 99) {
      return ;
    }
    throw {
          RE_EXN_ID: InvalidOpCode,
          _1: op,
          Error: new Error()
        };
  }
  if (op > 0) {
    return {
            op: op,
            arg1: arg1,
            arg2: arg2,
            out: out
          };
  }
  throw {
        RE_EXN_ID: InvalidOpCode,
        _1: op,
        Error: new Error()
      };
}

function execute(_t) {
  while(true) {
    var t = _t;
    var i = getInstr(t);
    if (i === undefined) {
      return t;
    }
    var t$1 = executeInstr(t, i);
    _t = {
      prog: t$1.prog,
      pc: t$1.pc + 4 | 0
    };
    continue ;
  };
}

function setNounVerb(t, noun, verb) {
  return saveVal(saveVal(t, 1, noun), 2, verb);
}

function make(xs) {
  return {
          prog: xs,
          pc: 0
        };
}

function executeWithNounVerb(prog, noun, verb) {
  var result = execute(setNounVerb(prog, noun, verb));
  return Belt_Option.getExn(Belt_Array.get(result.prog, 0));
}

var IntCode = {
  getVal: getVal,
  saveVal: saveVal,
  InvalidOpCode: InvalidOpCode,
  executeInstr: executeInstr,
  getInstr: getInstr,
  execute: execute,
  setNounVerb: setNounVerb,
  make: make,
  executeWithNounVerb: executeWithNounVerb
};

function part1(xs) {
  return executeWithNounVerb({
              prog: xs,
              pc: 0
            }, 12, 2);
}

function part2(xs) {
  return Belt_Array.getExn(Stdlib_Array$AdventOfCode.combinationIfArray2(Belt_Array.range(0, 99), Belt_Array.range(0, 99), (function (noun, verb) {
                    if (executeWithNounVerb({
                            prog: xs.slice(0),
                            pc: 0
                          }, noun, verb) === 19690720) {
                      return Math.imul(noun, 100) + verb | 0;
                    }
                    
                  })), 0);
}

function solvePart1(data) {
  return part1(parse(data));
}

function solvePart2(data) {
  return part2(parse(data));
}

export {
  log ,
  log2 ,
  parse ,
  IntCode ,
  part1 ,
  part2 ,
  solvePart1 ,
  solvePart2 ,
}
/* No side effect */
