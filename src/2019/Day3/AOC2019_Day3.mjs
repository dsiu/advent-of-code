// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Map from "rescript/lib/es6/belt_Map.js";
import * as Stdlib__Int from "@dsiu/rescript-stdlib-fp/src/Stdlib__Int.mjs";
import * as Stdlib__List from "@dsiu/rescript-stdlib-fp/src/Stdlib__List.mjs";
import * as Stdlib__Array from "@dsiu/rescript-stdlib-fp/src/Stdlib__Array.mjs";
import * as TableclothMap from "@dsiu/rescript-stdlib-fp/src/Tablecloth/TableclothMap.mjs";
import * as Stdlib__Option from "@dsiu/rescript-stdlib-fp/src/Stdlib__Option.mjs";
import * as TableclothList from "@dsiu/rescript-stdlib-fp/src/Tablecloth/TableclothList.mjs";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";
import * as TableclothArray from "@dsiu/rescript-stdlib-fp/src/Tablecloth/TableclothArray.mjs";
import * as Utils$AdventOfCode from "../../Utils.mjs";
import * as Coord_V2$AdventOfCode from "../../Coord_V2.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function manhattan(param) {
  return Math.abs(param[0]) + Math.abs(param[1]) | 0;
}

var emptyVisited = TableclothMap.empty({
      comparator: Coord_V2$AdventOfCode.comparator
    });

var InvalidDirection = /* @__PURE__ */Caml_exceptions.create("AOC2019_Day3-AdventOfCode.InvalidDirection");

function makeSegment(str) {
  var direction = str[0];
  var steps = Stdlib__Option.getExn(Stdlib__Int.fromString(undefined, str.slice(1)));
  if (direction !== undefined) {
    switch (direction) {
      case "D" :
          return {
                  direction: "South",
                  steps: steps
                };
      case "L" :
          return {
                  direction: "West",
                  steps: steps
                };
      case "R" :
          return {
                  direction: "East",
                  steps: steps
                };
      case "U" :
          return {
                  direction: "North",
                  steps: steps
                };
      default:
        throw {
              RE_EXN_ID: InvalidDirection,
              Error: new Error()
            };
    }
  } else {
    throw {
          RE_EXN_ID: InvalidDirection,
          Error: new Error()
        };
  }
}

function facing(direction) {
  switch (direction) {
    case "East" :
        return [
                1,
                0
              ];
    case "South" :
        return [
                0,
                -1
              ];
    case "West" :
        return [
                -1,
                0
              ];
    case "North" :
        return [
                0,
                1
              ];
    
  }
}

function travelSegment(path, segment) {
  var delta = facing(segment.direction);
  var distance = segment.steps;
  var start = path.tip;
  var visited = path.visited;
  var len = path.currentLength;
  var len$p = len + distance | 0;
  var insertStep = function (visits, param) {
    var loc = param[1];
    if (TableclothMap.includes(visits, loc)) {
      return visits;
    } else {
      return TableclothMap.add(visits, loc, param[0]);
    }
  };
  var visited$p = TableclothList.fold(Stdlib__List.zip(TableclothList.initialize(distance, (function (x) {
                  return (x + len | 0) + 1 | 0;
                })), Stdlib__List.unfold((function (param) {
                  return param[0] >= distance;
                }), (function (param) {
                  var x = param[1];
                  return [
                          Coord_V2$AdventOfCode.add(x, delta),
                          [
                            param[0] + 1 | 0,
                            Coord_V2$AdventOfCode.add(x, delta)
                          ]
                        ];
                }), [
                0,
                start
              ])), visited, insertStep);
  var tip$p = Coord_V2$AdventOfCode.add(start, Coord_V2$AdventOfCode.mul(delta, distance));
  return {
          visited: visited$p,
          tip: tip$p,
          currentLength: len$p
        };
}

function travelPath(segments) {
  var path0_tip = [
    0,
    0
  ];
  var path0 = {
    visited: emptyVisited,
    tip: path0_tip,
    currentLength: 0
  };
  return TableclothArray.fold(segments, path0, travelSegment);
}

function travelAllPaths(__x) {
  return __x.map(travelPath);
}

function closest(points) {
  return Utils$AdventOfCode.minIntInArray(Belt_Map.keysToArray(points).map(manhattan));
}

function crossovers(travelledPaths) {
  return Stdlib__Array.foldl1(travelledPaths.map(function (param) {
                  return param.visited;
                }), (function (m1, m2) {
                return TableclothMap.merge(m1, m2, (function (_k, a, b) {
                              if (a !== undefined && b !== undefined) {
                                return a + b | 0;
                              }
                              
                            }));
              }));
}

function shortestPaths(crossings) {
  return Utils$AdventOfCode.minIntInArray(Belt_Map.valuesToArray(crossings));
}

function part1(segmentss) {
  return closest(crossovers(segmentss.map(travelPath)));
}

function part2(segmentss) {
  var crossings = crossovers(segmentss.map(travelPath));
  return Utils$AdventOfCode.minIntInArray(Belt_Map.valuesToArray(crossings));
}

function parse(data) {
  return Utils$AdventOfCode.splitNewline(data).map(function (x) {
              return x.trim().split(",");
            });
}

function solvePart1(data) {
  var segs = parse(data).map(function (__x) {
        return __x.map(makeSegment);
      });
  return part1(segs);
}

function solvePart2(data) {
  var segs = parse(data).map(function (__x) {
        return __x.map(makeSegment);
      });
  return part2(segs);
}

var TC;

var $$Location;

export {
  log ,
  log2 ,
  TC ,
  $$Location ,
  manhattan ,
  emptyVisited ,
  InvalidDirection ,
  makeSegment ,
  facing ,
  travelSegment ,
  travelPath ,
  travelAllPaths ,
  closest ,
  crossovers ,
  shortestPaths ,
  part1 ,
  part2 ,
  parse ,
  solvePart1 ,
  solvePart2 ,
}
/* emptyVisited Not a pure module */
