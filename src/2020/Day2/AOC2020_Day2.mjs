// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/Belt_Option.js";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";
import * as Utils$AdventOfCode from "../../Utils.mjs";

function log(prim) {
  console.log(prim);
}

let formatRe = /(\d+)-(\d+)\s+([A-Za-z]+):\s+(.*)/i;

function make(s) {
  let x = Primitive_option.fromNull(formatRe.exec(s));
  let args = x !== undefined ? Belt_Array.map(Primitive_option.valFromOption(x), x => Belt_Option.getExn((x == null) ? undefined : Primitive_option.some(x))) : [];
  return {
    min: Utils$AdventOfCode.intFromStringExn(Belt_Array.getExn(args, 1)),
    max: Utils$AdventOfCode.intFromStringExn(Belt_Array.getExn(args, 2)),
    char: Belt_Array.getExn(args, 3),
    input: Belt_Array.getExn(args, 4)
  };
}

function isValidPart1(t) {
  let count = t.input.split(t.char).length - 1 | 0;
  if (count >= t.min) {
    return count <= t.max;
  } else {
    return false;
  }
}

function isValidPart2(t) {
  let matchFirst = t.input.charAt(t.min - 1 | 0) === t.char;
  let matchSecond = t.input.charAt(t.max - 1 | 0) === t.char;
  return matchFirst !== matchSecond;
}

let Password = {
  formatRe: formatRe,
  make: make,
  isValidPart1: isValidPart1,
  isValidPart2: isValidPart2
};

function solvePart1(data) {
  let pws = Belt_Array.map(data.split("\n"), s => make(s.trim()));
  return Belt_Array.keep(pws, isValidPart1).length;
}

function solvePart2(data) {
  let pws = Belt_Array.map(data.split("\n"), s => make(s.trim()));
  return Belt_Array.keep(pws, isValidPart2).length;
}

let data1 = "1-3 a: abcde\n            1-3 b: cdefg\n            2-9 c: ccccccccc";

export {
  log,
  data1,
  Password,
  solvePart1,
  solvePart2,
}
/* Utils-AdventOfCode Not a pure module */
