// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Utils$AdventOfCode from "../../Utils.mjs";

function log(prim) {
  console.log(prim);
}

var formatRe = /(\d+)-(\d+)\s+([A-Za-z]+):\s+(.*)/i;

function make(s) {
  var x = (function (__x) {
        return Caml_option.null_to_opt(formatRe.exec(__x));
      })(s);
  var args = x !== undefined ? Belt_Array.map(Caml_option.valFromOption(x), (function (x) {
            return Belt_Option.getExn((x == null) ? undefined : Caml_option.some(x));
          })) : [];
  return {
          min: Utils$AdventOfCode.intFromStringExn(Belt_Array.getExn(args, 1)),
          max: Utils$AdventOfCode.intFromStringExn(Belt_Array.getExn(args, 2)),
          char: Belt_Array.getExn(args, 3),
          input: Belt_Array.getExn(args, 4)
        };
}

function isValidPart1(t) {
  var count = t.input.split(t.char).length - 1 | 0;
  if (count >= t.min) {
    return count <= t.max;
  } else {
    return false;
  }
}

function isValidPart2(t) {
  var matchFirst = t.input.charAt(t.min - 1 | 0) === t.char;
  var matchSecond = t.input.charAt(t.max - 1 | 0) === t.char;
  return matchFirst !== matchSecond;
}

var Password = {
  formatRe: formatRe,
  make: make,
  isValidPart1: isValidPart1,
  isValidPart2: isValidPart2
};

function solvePart1(data) {
  var pws = Belt_Array.map(data.split("\n"), (function (s) {
          return make(s.trim());
        }));
  return Belt_Array.keep(pws, isValidPart1).length;
}

function solvePart2(data) {
  var pws = Belt_Array.map(data.split("\n"), (function (s) {
          return make(s.trim());
        }));
  return Belt_Array.keep(pws, isValidPart2).length;
}

var data1 = "1-3 a: abcde\n            1-3 b: cdefg\n            2-9 c: ccccccccc";

export {
  log ,
  data1 ,
  Password ,
  solvePart1 ,
  solvePart2 ,
}
/* Utils-AdventOfCode Not a pure module */
