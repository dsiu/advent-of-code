// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Int from "rescript/lib/es6/belt_Int.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Belt_MapString from "rescript/lib/es6/belt_MapString.js";
import * as Utils$AdventOfCode from "../../Utils.mjs";
import * as FP_Utils$AdventOfCode from "../../FP_Utils.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function rangeToString(param) {
  return String(param._0) + "-" + String(param._1);
}

function bodyToString(param) {
  return rangeToString(param._0) + " or " + rangeToString(param._1);
}

function inRange(param, value) {
  if (param._0 <= value) {
    return value <= param._1;
  } else {
    return false;
  }
}

function matchesRule(param, value) {
  if (inRange(param._0, value)) {
    return true;
  } else {
    return inRange(param._1, value);
  }
}

function validForAnyField(rules, value) {
  return Belt_Array.keep(Belt_MapString.valuesToArray(rules), (function (__x) {
                return matchesRule(__x, value);
              })).length !== 0;
}

function ticketErrorRate(rules, tickets) {
  return Utils$AdventOfCode.sumIntArray(Utils$AdventOfCode.flatten(Belt_Array.map(tickets, (function (t) {
                        return Belt_Array.keep(t, (function (v) {
                                      return !validForAnyField(rules, v);
                                    }));
                      }))));
}

function parse(data) {
  var trim = function (prim) {
    return prim.trim();
  };
  var intFromStrEx = function (param) {
    return FP_Utils$AdventOfCode.compose(Belt_Int.fromString, Belt_Option.getExn, param);
  };
  var match = Belt_Array.map(Utils$AdventOfCode.splitDoubleNewline(data), (function (x) {
          return Belt_Array.map(Utils$AdventOfCode.splitNewline(x), trim);
        }));
  if (match.length !== 3) {
    throw {
          RE_EXN_ID: "Match_failure",
          _1: [
            "AOC2020_Day16.res",
            41,
            6
          ],
          Error: new Error()
        };
  }
  var rules = match[0];
  var my = match[1];
  var nearby = match[2];
  var parseRange = function (s) {
    var match = Belt_Array.map(s.split("-"), intFromStrEx);
    if (match.length !== 2) {
      throw {
            RE_EXN_ID: "Match_failure",
            _1: [
              "AOC2020_Day16.res",
              44,
              8
            ],
            Error: new Error()
          };
    }
    var a = match[0];
    var b = match[1];
    return /* Range */{
            _0: a,
            _1: b
          };
  };
  var parseRule = function (s) {
    var match = s.split(": ");
    if (match.length !== 2) {
      throw {
            RE_EXN_ID: "Match_failure",
            _1: [
              "AOC2020_Day16.res",
              49,
              8
            ],
            Error: new Error()
          };
    }
    var ruleStr = match[0];
    var rangesStr = match[1];
    var match$1 = Belt_Array.map(rangesStr.split(" or "), parseRange);
    if (match$1.length !== 2) {
      throw {
            RE_EXN_ID: "Match_failure",
            _1: [
              "AOC2020_Day16.res",
              50,
              8
            ],
            Error: new Error()
          };
    }
    var r1 = match$1[0];
    var r2 = match$1[1];
    return [
            ruleStr,
            /* Body */{
              _0: r1,
              _1: r2
            }
          ];
  };
  var ruleSet = Belt_MapString.fromArray(Belt_Array.map(rules, parseRule));
  var parseTicket = function (s) {
    return Belt_Array.map(s.split(","), intFromStrEx);
  };
  var myTicket = parseTicket(Belt_Array.getExn(my, 1));
  var nearbyTickets = Belt_Array.map(Belt_Array.sliceToEnd(nearby, 1), parseTicket);
  return [
          ruleSet,
          myTicket,
          nearbyTickets
        ];
}

function solvePart1(data) {
  var match = parse(data);
  return ticketErrorRate(match[0], match[2]);
}

function solvePart2(data) {
  return 2;
}

var part1 = ticketErrorRate;

export {
  log ,
  log2 ,
  rangeToString ,
  bodyToString ,
  inRange ,
  matchesRule ,
  validForAnyField ,
  ticketErrorRate ,
  part1 ,
  parse ,
  solvePart1 ,
  solvePart2 ,
}
/* No side effect */
