// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Utils from "../../Utils.mjs";
import * as Stdlib__Array from "@dsiu/rescript-stdlib-fp/src/Stdlib__Array.mjs";
import * as Belt_MapString from "rescript/lib/es6/Belt_MapString.js";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function rangeToString(param) {
  return param._0.toString() + "-" + param._1.toString();
}

function bodyToString(param) {
  return rangeToString(param._0) + " or " + rangeToString(param._1);
}

function inRange(param, value) {
  if (param._0 <= value) {
    return value <= param._1;
  } else {
    return false;
  }
}

function matchesRule(param, value) {
  if (inRange(param._0, value)) {
    return true;
  } else {
    return inRange(param._1, value);
  }
}

function validForAnyField(rules, value) {
  return Belt_MapString.valuesToArray(rules._0).some(__x => matchesRule(__x, value));
}

function ticketErrorRate(rules, tickets) {
  return Utils.sumIntArray(tickets.map(t => t.filter(v => !validForAnyField(rules, v))).flat());
}

function isValidTicket(rules, ticket) {
  let rules$1 = rules._0;
  return ticket.map(__x => validForAnyField({
    TAG: "RuleSet",
    _0: rules$1
  }, __x)).every(prim => prim);
}

function possibleColumns(ticketCols, body) {
  let columnMatches = param => param[1].every(__x => matchesRule(body, __x));
  let idx = Stdlib__Array.fromInitializer(ticketCols.length, prim => prim);
  return Stdlib__Array.zip(idx, ticketCols).filter(columnMatches).map(prim => prim[0]);
}

function possibleColumnsAll(rules, tickets) {
  let rules$1 = rules._0;
  let validTickets = tickets.filter(__x => isValidTicket({
    TAG: "RuleSet",
    _0: rules$1
  }, __x));
  let ticketCols = Stdlib__Array.transpose(validTickets);
  return Belt_MapString.map(rules$1, __x => possibleColumns(ticketCols, __x));
}

function reduceCandidate(candidates) {
  let findNextCandidate = candidates => {
    let only1Elem = (param, v) => v.length === 1;
    return Belt_MapString.findFirstBy(candidates._0, only1Elem);
  };
  let _c = {
    TAG: "ColCandidateSet",
    _0: candidates._0
  };
  let _solved = [];
  while (true) {
    let c = _c;
    let solved = _solved;
    let c$1 = c._0;
    let match = findNextCandidate({
      TAG: "ColCandidateSet",
      _0: c$1
    });
    if (match === undefined) {
      return solved;
    }
    let k = match[0];
    let v$p = Stdlib__Array.getUnsafe(match[1], 0);
    let solved$p = solved.concat([[
        k,
        v$p
      ]]);
    let removeFound = __x => __x.filter(x => x !== v$p);
    _solved = solved$p;
    _c = {
      TAG: "ColCandidateSet",
      _0: Belt_MapString.map(Belt_MapString.remove(c$1, k), removeFound)
    };
    continue;
  };
}

function parse(data) {
  let trim = prim => prim.trim();
  let match = Utils.splitDoubleNewline(data).map(x => Utils.splitNewline(x).map(trim));
  if (match.length !== 3) {
    throw {
      RE_EXN_ID: "Match_failure",
      _1: [
        "AOC2020_Day16.res",
        100,
        6
      ],
      Error: new Error()
    };
  }
  let rules = match[0];
  let my = match[1];
  let nearby = match[2];
  let parseRange = s => {
    let match = s.split("-").map(Utils.intFromStringExn);
    if (match.length !== 2) {
      throw {
        RE_EXN_ID: "Match_failure",
        _1: [
          "AOC2020_Day16.res",
          103,
          8
        ],
        Error: new Error()
      };
    }
    let a = match[0];
    let b = match[1];
    return {
      TAG: "Range",
      _0: a,
      _1: b
    };
  };
  let parseRule = s => {
    let match = s.split(": ");
    if (match.length !== 2) {
      throw {
        RE_EXN_ID: "Match_failure",
        _1: [
          "AOC2020_Day16.res",
          108,
          8
        ],
        Error: new Error()
      };
    }
    let ruleStr = match[0];
    let rangesStr = match[1];
    let match$1 = rangesStr.split(" or ").map(parseRange);
    if (match$1.length !== 2) {
      throw {
        RE_EXN_ID: "Match_failure",
        _1: [
          "AOC2020_Day16.res",
          109,
          8
        ],
        Error: new Error()
      };
    }
    let r1 = match$1[0];
    let r2 = match$1[1];
    return [
      ruleStr,
      {
        TAG: "Body",
        _0: r1,
        _1: r2
      }
    ];
  };
  let ruleSet = {
    TAG: "RuleSet",
    _0: Belt_MapString.fromArray(rules.map(parseRule))
  };
  let parseTicket = s => s.split(",").map(Utils.intFromStringExn);
  let myTicket = parseTicket(Stdlib__Array.getUnsafe(my, 1));
  let nearbyTickets = nearby.slice(1).map(parseTicket);
  return [
    ruleSet,
    myTicket,
    nearbyTickets
  ];
}

function solvePart1(data) {
  let match = parse(data);
  return ticketErrorRate(match[0], match[2]);
}

function solvePart2(data) {
  let match = parse(data);
  let myTicket = match[1];
  let pc = possibleColumnsAll(match[0], match[2]);
  let colMapping = reduceCandidate({
    TAG: "ColCandidateSet",
    _0: pc
  });
  return Stdlib__Array.reduce(Stdlib__Array.filterMap(colMapping, param => {
    if (param[0].startsWith("departure")) {
      return Stdlib__Array.getUnsafe(myTicket, param[1]);
    }
    
  }), 1, (acc, x) => x * acc);
}

let $$Map;

let part1 = ticketErrorRate;

export {
  $$Map,
  log,
  log2,
  rangeToString,
  bodyToString,
  inRange,
  matchesRule,
  validForAnyField,
  ticketErrorRate,
  part1,
  isValidTicket,
  possibleColumns,
  possibleColumnsAll,
  reduceCandidate,
  parse,
  solvePart1,
  solvePart2,
}
/* Utils Not a pure module */
