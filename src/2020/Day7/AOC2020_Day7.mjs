// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/Belt_Option.js";
import * as Belt_MapString from "rescript/lib/es6/Belt_MapString.js";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";
import * as Utils$AdventOfCode from "../../Utils.mjs";

function log(prim) {
  console.log(prim);
}

function color(t) {
  return t.color;
}

function count(t) {
  return t.count;
}

function isEmpty(t) {
  if (t.count === 0) {
    return t.color === "";
  } else {
    return false;
  }
}

function colorEq(t, color) {
  return t.color === color;
}

function make(count, color) {
  return {
    count: count,
    color: color
  };
}

let empty = {
  count: 0,
  color: ""
};

let Bag = {
  color: color,
  count: count,
  isEmpty: isEmpty,
  colorEq: colorEq,
  make: make,
  empty: empty
};

let numBagRe = /\D*(\d+)\s+([\w\s]+)\s+bag[s]*.*/i;

let justBagRe = /([\w\s]+)\s+bag[s]*.*/i;

function parseBag(s, r, numIndex, bagIndex) {
  if (s.includes("no other bags")) {
    return empty;
  }
  let y = Primitive_option.fromNull(r.exec(s));
  let c = y !== undefined ? Belt_Array.map(Primitive_option.valFromOption(y), z => Belt_Option.getExn((z == null) ? undefined : Primitive_option.some(z))) : [];
  return {
    count: numIndex === 0 ? 0 : Utils$AdventOfCode.intFromStringExn(Belt_Array.getExn(c, numIndex)),
    color: Belt_Array.getExn(c, bagIndex)
  };
}

function parseNumBag(__x) {
  return parseBag(__x, numBagRe, 1, 2);
}

function parseJustBag(__x) {
  return parseBag(__x, justBagRe, 0, 1);
}

let nodeRe = /(.*)\s+bags/i;

function parseNode(s) {
  let x = Primitive_option.fromNull(nodeRe.exec(s));
  if (x !== undefined) {
    return Belt_Array.getExn(Primitive_option.valFromOption(x), 0);
  }
  throw {
    RE_EXN_ID: "Not_found",
    Error: new Error()
  };
}

let leafRe = /(.*)\s+bags/i;

function parseLeaf(s) {
  let x = Primitive_option.fromNull(leafRe.exec(s));
  if (x !== undefined) {
    return Belt_Array.getExn(Primitive_option.valFromOption(x), 0);
  }
  throw {
    RE_EXN_ID: "Not_found",
    Error: new Error()
  };
}

function addNode(t, node, leaf) {
  return Belt_MapString.set(t, node.color, leaf);
}

function addRule(t, l) {
  let node = parseJustBag(Belt_Array.getExn(l, 0));
  let leaf = Belt_Array.map(Belt_Array.getExn(l, 1).split(","), parseNumBag);
  return addNode(t, node, leaf);
}

function getBag(t, b) {
  return Belt_MapString.getExn(t, b.color);
}

function doesThisBagContain(t, srcColor, match) {
  let leaf = Belt_MapString.getExn(t, srcColor);
  return Belt_Array.reduce(leaf, [], (a, x) => {
    if (isEmpty(x)) {
      return a;
    } else if (x.color === match.color) {
      return Belt_Array.concat(a, [srcColor]);
    } else {
      return Belt_Array.concat(a, doesThisBagContain(t, x.color, match));
    }
  });
}

function whichBagContains(t, match) {
  return Belt_MapString.reduce(t, [], (a, k, v) => {
    let ret = doesThisBagContain(t, k, match);
    if (ret.length !== 0) {
      return Belt_Array.concat(a, [k]);
    } else {
      return a;
    }
  });
}

function countBagsInside(t, bag) {
  let leaf = Belt_MapString.getExn(t, bag.color);
  return Belt_Array.reduce(leaf, 1, (a, x) => {
    if (isEmpty(x)) {
      return a;
    } else {
      return a + Math.imul(x.count, countBagsInside(t, x)) | 0;
    }
  });
}

function howManyBagsIn(t, match) {
  return countBagsInside(t, match) - 1 | 0;
}

let Rules = {
  set: Belt_MapString.set,
  get: Belt_MapString.get,
  getExn: Belt_MapString.getExn,
  forEach: Belt_MapString.forEach,
  reduce: Belt_MapString.reduce,
  map: Belt_MapString.map,
  mapWithKey: Belt_MapString.mapWithKey,
  numBagRe: numBagRe,
  justBagRe: justBagRe,
  parseBag: parseBag,
  parseNumBag: parseNumBag,
  parseJustBag: parseJustBag,
  nodeRe: nodeRe,
  parseNode: parseNode,
  leafRe: leafRe,
  parseLeaf: parseLeaf,
  addNode: addNode,
  addRule: addRule,
  getBag: getBag,
  doesThisBagContain: doesThisBagContain,
  whichBagContains: whichBagContains,
  countBagsInside: countBagsInside,
  howManyBagsIn: howManyBagsIn,
  make: undefined
};

function parseLine(l) {
  return Belt_Array.map(l.trim().split("contain", 2), prim => prim.trim());
}

function parse(data) {
  return Belt_Array.map(Utils$AdventOfCode.splitNewline(data), parseLine);
}

function solvePart1(data) {
  let parsed = Belt_Array.map(Utils$AdventOfCode.splitNewline(data), parseLine);
  let newRules = Belt_Array.reduce(parsed, undefined, addRule);
  return whichBagContains(newRules, {
    count: 0,
    color: "shiny gold"
  }).length;
}

function solvePart2(data) {
  let parsed = Belt_Array.map(Utils$AdventOfCode.splitNewline(data), parseLine);
  let newRules = Belt_Array.reduce(parsed, undefined, addRule);
  return howManyBagsIn(newRules, {
    count: 0,
    color: "shiny gold"
  });
}

export {
  log,
  Bag,
  Rules,
  parseLine,
  parse,
  solvePart1,
  solvePart2,
}
/* Utils-AdventOfCode Not a pure module */
