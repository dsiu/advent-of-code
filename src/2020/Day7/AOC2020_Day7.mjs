// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Belt_MapString from "rescript/lib/es6/belt_MapString.js";
import * as Utils$AdventOfCode from "../../Utils.mjs";

function log(prim) {
  console.log(prim);
  
}

function color(t) {
  return t.color;
}

function count(t) {
  return t.count;
}

function isEmpty(t) {
  if (t.count === 0) {
    return t.color === "";
  } else {
    return false;
  }
}

function colorEq(t, color) {
  return t.color === color;
}

function make(count, color) {
  return {
          count: count,
          color: color
        };
}

var empty = {
  count: 0,
  color: ""
};

var Bag = {
  color: color,
  count: count,
  isEmpty: isEmpty,
  colorEq: colorEq,
  make: make,
  empty: empty
};

var numBagRe = /\D*(\d+)\s+([\w\s]+)\s+bag[s]*.*/i;

var justBagRe = /([\w\s]+)\s+bag[s]*.*/i;

function parseBag(s, r, numIndex, bagIndex) {
  if (s.includes("no other bags")) {
    return empty;
  }
  var y = r.exec(s);
  var c = y !== null ? Belt_Array.map(y, (function (z) {
            return Belt_Option.getExn((z == null) ? undefined : Caml_option.some(z));
          })) : [];
  return {
          count: numIndex === 0 ? 0 : Utils$AdventOfCode.intFromStringExn(Belt_Array.getExn(c, numIndex)),
          color: Belt_Array.getExn(c, bagIndex)
        };
}

function parseNumBag(__x) {
  return parseBag(__x, numBagRe, 1, 2);
}

function parseJustBag(__x) {
  return parseBag(__x, justBagRe, 0, 1);
}

var nodeRe = /(.*)\s+bags/i;

function parseNode(s) {
  var x = nodeRe.exec(s);
  if (x !== null) {
    return Belt_Array.getExn(x, 0);
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

var leafRe = /(.*)\s+bags/i;

function parseLeaf(s) {
  var x = leafRe.exec(s);
  if (x !== null) {
    return Belt_Array.getExn(x, 0);
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function addNode(t, node, leaf) {
  return Belt_MapString.set(t, node.color, leaf);
}

function addRule(t, l) {
  var node = parseJustBag(Belt_Array.getExn(l, 0));
  var leaf = Belt_Array.map(Belt_Array.getExn(l, 1).split(","), parseNumBag);
  return addNode(t, node, leaf);
}

function getBag(t, b) {
  return Belt_MapString.getExn(t, b.color);
}

function doesThisBagContain(t, srcColor, match) {
  var leaf = Belt_MapString.getExn(t, srcColor);
  return Belt_Array.reduce(leaf, [], (function (a, x) {
                if (isEmpty(x)) {
                  return a;
                }
                var color = match.color;
                if (x.color === color) {
                  return Belt_Array.concat(a, [srcColor]);
                } else {
                  return Belt_Array.concat(a, doesThisBagContain(t, x.color, match));
                }
              }));
}

function whichBagContains(t, match) {
  return Belt_MapString.reduce(t, [], (function (a, k, v) {
                var ret = doesThisBagContain(t, k, match);
                if (ret.length !== 0) {
                  return Belt_Array.concat(a, [k]);
                } else {
                  return a;
                }
              }));
}

function countBagsInside(t, bag) {
  var leaf = Belt_MapString.getExn(t, bag.color);
  return Belt_Array.reduce(leaf, 1, (function (a, x) {
                if (isEmpty(x)) {
                  return a;
                } else {
                  return a + Math.imul(x.count, countBagsInside(t, x)) | 0;
                }
              }));
}

function howManyBagsIn(t, match) {
  return countBagsInside(t, match) - 1 | 0;
}

var Rules = {
  set: Belt_MapString.set,
  get: Belt_MapString.get,
  getExn: Belt_MapString.getExn,
  forEach: Belt_MapString.forEach,
  reduce: Belt_MapString.reduce,
  map: Belt_MapString.map,
  mapWithKey: Belt_MapString.mapWithKey,
  numBagRe: numBagRe,
  justBagRe: justBagRe,
  parseBag: parseBag,
  parseNumBag: parseNumBag,
  parseJustBag: parseJustBag,
  nodeRe: nodeRe,
  parseNode: parseNode,
  leafRe: leafRe,
  parseLeaf: parseLeaf,
  addNode: addNode,
  addRule: addRule,
  getBag: getBag,
  doesThisBagContain: doesThisBagContain,
  whichBagContains: whichBagContains,
  countBagsInside: countBagsInside,
  howManyBagsIn: howManyBagsIn,
  make: undefined
};

function parseLine(l) {
  return Belt_Array.map(l.trim().split("contain", 2), (function (prim) {
                return prim.trim();
              }));
}

function parse(data) {
  return Belt_Array.map(Utils$AdventOfCode.splitNewline(data), parseLine);
}

function solvePart1(data) {
  var parsed = Belt_Array.map(Utils$AdventOfCode.splitNewline(data), parseLine);
  var newRules = Belt_Array.reduce(parsed, undefined, addRule);
  return whichBagContains(newRules, {
              count: 0,
              color: "shiny gold"
            }).length;
}

function solvePart2(data) {
  var parsed = Belt_Array.map(Utils$AdventOfCode.splitNewline(data), parseLine);
  var newRules = Belt_Array.reduce(parsed, undefined, addRule);
  return howManyBagsIn(newRules, {
              count: 0,
              color: "shiny gold"
            });
}

export {
  log ,
  Bag ,
  Rules ,
  parseLine ,
  parse ,
  solvePart1 ,
  solvePart2 ,
  
}
/* No side effect */
