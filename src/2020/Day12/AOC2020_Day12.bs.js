// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Belt_Int = require("rescript/lib/js/belt_Int.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Utils$AdventOfCode = require("../../Utils.bs.js");

function log(prim) {
  console.log(prim);
  
}

var InvalidStatus = /* @__PURE__ */Caml_exceptions.create("AOC2020_Day12-AdventOfCode.InvalidStatus");

function flip180(facing) {
  if (facing === "N") {
    return "S";
  } else if (facing === "S") {
    return "N";
  } else if (facing === "W") {
    return "E";
  } else {
    return "W";
  }
}

function l90(facing) {
  if (facing === "N") {
    return "W";
  } else if (facing === "S") {
    return "E";
  } else if (facing === "W") {
    return "S";
  } else {
    return "N";
  }
}

function r90(facing) {
  if (facing === "N") {
    return "E";
  } else if (facing === "S") {
    return "W";
  } else if (facing === "W") {
    return "N";
  } else {
    return "S";
  }
}

function rotateLeft(t, degree) {
  var match = t.facing;
  var exit = 0;
  if (degree >= 90) {
    if (degree >= 270) {
      if (degree === 360) {
        return t;
      }
      if (degree >= 271) {
        throw {
              RE_EXN_ID: InvalidStatus,
              _1: String(degree),
              Error: new Error()
            };
      }
      exit = 3;
    } else if (degree !== 180) {
      if (degree >= 91) {
        throw {
              RE_EXN_ID: InvalidStatus,
              _1: String(degree),
              Error: new Error()
            };
      }
      exit = 1;
    } else {
      exit = 2;
    }
  } else if (degree !== -270) {
    if (degree !== -180) {
      if (degree !== -90) {
        throw {
              RE_EXN_ID: InvalidStatus,
              _1: String(degree),
              Error: new Error()
            };
      }
      exit = 3;
    } else {
      exit = 2;
    }
  } else {
    exit = 1;
  }
  switch (exit) {
    case 1 :
        return {
                coord: t.coord,
                facing: l90(match),
                wayPoint: t.wayPoint
              };
    case 2 :
        return {
                coord: t.coord,
                facing: flip180(match),
                wayPoint: t.wayPoint
              };
    case 3 :
        return {
                coord: t.coord,
                facing: r90(match),
                wayPoint: t.wayPoint
              };
    
  }
}

function rotateRight(t, degree) {
  var match = t.facing;
  var exit = 0;
  if (degree >= 90) {
    if (degree >= 270) {
      if (degree === 360) {
        return t;
      }
      if (degree >= 271) {
        throw {
              RE_EXN_ID: InvalidStatus,
              _1: String(degree),
              Error: new Error()
            };
      }
      exit = 3;
    } else if (degree !== 180) {
      if (degree >= 91) {
        throw {
              RE_EXN_ID: InvalidStatus,
              _1: String(degree),
              Error: new Error()
            };
      }
      exit = 1;
    } else {
      exit = 2;
    }
  } else if (degree !== -270) {
    if (degree !== -180) {
      if (degree !== -90) {
        throw {
              RE_EXN_ID: InvalidStatus,
              _1: String(degree),
              Error: new Error()
            };
      }
      exit = 3;
    } else {
      exit = 2;
    }
  } else {
    exit = 1;
  }
  switch (exit) {
    case 1 :
        return {
                coord: t.coord,
                facing: r90(match),
                wayPoint: t.wayPoint
              };
    case 2 :
        return {
                coord: t.coord,
                facing: flip180(match),
                wayPoint: t.wayPoint
              };
    case 3 :
        return {
                coord: t.coord,
                facing: l90(match),
                wayPoint: t.wayPoint
              };
    
  }
}

function m(point, facing, n) {
  if (facing === "N") {
    return {
            x: point.x,
            y: point.y - n | 0
          };
  } else if (facing === "S") {
    return {
            x: point.x,
            y: point.y + n | 0
          };
  } else if (facing === "W") {
    return {
            x: point.x - n | 0,
            y: point.y
          };
  } else {
    return {
            x: point.x + n | 0,
            y: point.y
          };
  }
}

function move(t, direction, n) {
  return {
          coord: m(t.coord, direction, n),
          facing: t.facing,
          wayPoint: t.wayPoint
        };
}

function moveWP(t, direction, n) {
  return {
          coord: t.coord,
          facing: t.facing,
          wayPoint: m(t.wayPoint, direction, n)
        };
}

var make = {
  coord: {
    x: 0,
    y: 0
  },
  facing: "E",
  wayPoint: {
    x: 10,
    y: 1
  }
};

function execute(ship, s) {
  var variant = s.NAME;
  if (variant === "South") {
    return move(ship, "S", s.VAL);
  } else if (variant === "East") {
    return move(ship, "E", s.VAL);
  } else if (variant === "Left") {
    return rotateLeft(ship, s.VAL);
  } else if (variant === "North") {
    return move(ship, "N", s.VAL);
  } else if (variant === "Forward") {
    return move(ship, ship.facing, s.VAL);
  } else if (variant === "West") {
    return move(ship, "W", s.VAL);
  } else {
    return rotateRight(ship, s.VAL);
  }
}

function executeWithWayPoint(ship, s) {
  var variant = s.NAME;
  if (variant === "South") {
    return moveWP(ship, "S", s.VAL);
  } else if (variant === "East") {
    return moveWP(ship, "E", s.VAL);
  } else if (variant === "Left") {
    return rotateLeft(ship, s.VAL);
  } else if (variant === "North") {
    return moveWP(ship, "N", s.VAL);
  } else if (variant === "Forward") {
    return move(ship, ship.facing, s.VAL);
  } else if (variant === "West") {
    return moveWP(ship, "W", s.VAL);
  } else {
    return rotateRight(ship, s.VAL);
  }
}

function make$1(s, n) {
  switch (s) {
    case "E" :
        return {
                NAME: "East",
                VAL: n
              };
    case "F" :
        return {
                NAME: "Forward",
                VAL: n
              };
    case "L" :
        return {
                NAME: "Left",
                VAL: n
              };
    case "N" :
        return {
                NAME: "North",
                VAL: n
              };
    case "R" :
        return {
                NAME: "Right",
                VAL: n
              };
    case "S" :
        return {
                NAME: "South",
                VAL: n
              };
    case "W" :
        return {
                NAME: "West",
                VAL: n
              };
    default:
      throw {
            RE_EXN_ID: InvalidStatus,
            _1: s,
            Error: new Error()
          };
  }
}

var Instruction = {
  execute: execute,
  executeWithWayPoint: executeWithWayPoint,
  make: make$1
};

function execute$1(ship, ops) {
  return Belt_Array.reduce(ops, ship, execute);
}

function executeWithWayPoint$1(ship, ops) {
  return Belt_Array.reduce(ops, ship, executeWithWayPoint);
}

var Ship = {
  flip180: flip180,
  l90: l90,
  r90: r90,
  rotateLeft: rotateLeft,
  rotateRight: rotateRight,
  m: m,
  move: move,
  moveWP: moveWP,
  make: make,
  Instruction: Instruction,
  execute: execute$1,
  executeWithWayPoint: executeWithWayPoint$1
};

function parse(data) {
  return Belt_Array.map(Utils$AdventOfCode.splitNewline(data), (function (x) {
                var s = x.trim();
                var code = s.charAt(0);
                var n = Belt_Option.getExn(Belt_Int.fromString(s.substring(1)));
                return [
                        code,
                        n
                      ];
              }));
}

function solvePart1(data) {
  var ops = Belt_Array.map(parse(data), (function (param) {
          return make$1(param[0], param[1]);
        }));
  var done = execute$1(make, ops);
  console.log(done);
  return Belt_Array.reduce(Belt_Array.map([
                  done.coord.x,
                  done.coord.y
                ], (function (prim) {
                    return Math.abs(prim);
                  })), 0, Utils$AdventOfCode.sum);
}

function solvePart2(data) {
  var ops = Belt_Array.map(parse(data), (function (param) {
          return make$1(param[0], param[1]);
        }));
  var done = executeWithWayPoint$1(make, ops);
  console.log(done);
  return Belt_Array.reduce(Belt_Array.map([
                  done.coord.x,
                  done.coord.y
                ], (function (prim) {
                    return Math.abs(prim);
                  })), 0, Utils$AdventOfCode.sum);
}

exports.log = log;
exports.InvalidStatus = InvalidStatus;
exports.Ship = Ship;
exports.parse = parse;
exports.solvePart1 = solvePart1;
exports.solvePart2 = solvePart2;
/* No side effect */
