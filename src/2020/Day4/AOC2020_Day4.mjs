// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Int from "rescript/lib/es6/Belt_Int.js";
import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/Belt_Option.js";
import * as Belt_MapString from "rescript/lib/es6/Belt_MapString.js";
import * as Primitive_object from "rescript/lib/es6/Primitive_object.js";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";

function log(prim) {
  console.log(prim);
}

let requiredFields = [
  "byr",
  "iyr",
  "eyr",
  "hgt",
  "hcl",
  "ecl",
  "pid"
];

let optionalFields = ["cid"];

function kvStrToMap(xs) {
  return Belt_Array.reduce(xs, undefined, (a, s) => {
    let kvs = s.split(":");
    return Belt_MapString.set(a, Belt_Array.getExn(kvs, 0), Belt_Array.getExn(kvs, 1));
  });
}

function containsAllFields(t, fields) {
  return Belt_Array.reduce(fields, true, (a, f) => {
    if (a) {
      return Belt_MapString.has(t, f);
    } else {
      return false;
    }
  });
}

function containsAllOptionalFields(__x) {
  return containsAllFields(__x, optionalFields);
}

function containsAllRequiredFields(__x) {
  return containsAllFields(__x, requiredFields);
}

function getFieldSafeAndValidate(t, field, f) {
  let v = Belt_MapString.get(t, field);
  if (v !== undefined) {
    return f(Primitive_option.valFromOption(v));
  } else {
    return false;
  }
}

function validateStringAsInt(s, f) {
  let n = Belt_Int.fromString(s);
  if (n !== undefined) {
    return f(n);
  } else {
    return false;
  }
}

function between(x, a, b) {
  if (Primitive_object.greaterequal(x, a)) {
    return Primitive_object.lessequal(x, b);
  } else {
    return false;
  }
}

function isValidByr(__x) {
  return getFieldSafeAndValidate(__x, "byr", __x => validateStringAsInt(__x, __x => between(__x, 1920, 2002)));
}

function isValidIyr(__x) {
  return getFieldSafeAndValidate(__x, "iyr", __x => validateStringAsInt(__x, __x => between(__x, 2010, 2020)));
}

function isValidEyr(__x) {
  return getFieldSafeAndValidate(__x, "eyr", __x => validateStringAsInt(__x, __x => between(__x, 2020, 2030)));
}

function eclValidator(s) {
  let eyeColors = [
    "amb",
    "blu",
    "brn",
    "gry",
    "grn",
    "hzl",
    "oth"
  ];
  return Belt_Array.some(eyeColors, x => x === s);
}

function isValidEcl(__x) {
  return getFieldSafeAndValidate(__x, "ecl", eclValidator);
}

function lengthIs(s, l) {
  return s.length === l;
}

function charIsInt(s) {
  return Belt_Int.fromString(s) !== undefined;
}

function charIsHex(s) {
  if (s >= "0" && s <= "9") {
    return true;
  } else if (s >= "a") {
    return s <= "f";
  } else {
    return false;
  }
}

function validateCharsInString(s, f) {
  return Belt_Array.reduce(s.split(""), true, (a, x) => {
    if (a) {
      return f(x);
    } else {
      return false;
    }
  });
}

function pidValidator(s) {
  if (s.length === 9) {
    return validateCharsInString(s, charIsInt);
  } else {
    return false;
  }
}

function isValidPid(__x) {
  return getFieldSafeAndValidate(__x, "pid", pidValidator);
}

function hclValidator(s) {
  if (s.length === 7 && s.slice(0, 1) === "#") {
    return validateCharsInString(s.slice(1, 7), charIsHex);
  } else {
    return false;
  }
}

function isValidHcl(__x) {
  return getFieldSafeAndValidate(__x, "hcl", hclValidator);
}

let hgtRe = /(\d+)(in|cm)/i;

function hgtValidator(s) {
  let x = Primitive_option.fromNull(hgtRe.exec(s));
  if (x === undefined) {
    return false;
  }
  let x$1 = Primitive_option.valFromOption(x);
  let h = Belt_Option.getExn(Primitive_option.fromNullable(Belt_Array.getExn(x$1, 1)));
  let u = Belt_Option.getExn(Primitive_option.fromNullable(Belt_Array.getExn(x$1, 2)));
  let match = Belt_Int.fromString(h);
  switch (u) {
    case "cm" :
      if (match !== undefined) {
        return between(match, 150, 193);
      } else {
        return false;
      }
    case "in" :
      if (match !== undefined) {
        return between(match, 56, 76);
      } else {
        return false;
      }
    default:
      return false;
  }
}

function isValidHgt(__x) {
  return getFieldSafeAndValidate(__x, "hgt", hgtValidator);
}

function isValidPart2(t) {
  let validators = [
    containsAllRequiredFields,
    isValidByr,
    isValidIyr,
    isValidEyr,
    isValidHgt,
    isValidHcl,
    isValidEcl,
    isValidPid
  ];
  return Belt_Array.reduce(validators, true, (a, f) => {
    if (a) {
      return f(t);
    } else {
      return false;
    }
  });
}

function make(s) {
  return kvStrToMap(s.split(" "));
}

let Passport = {
  requiredFields: requiredFields,
  optionalFields: optionalFields,
  kvStrToMap: kvStrToMap,
  containsAllFields: containsAllFields,
  containsAllOptionalFields: containsAllOptionalFields,
  containsAllRequiredFields: containsAllRequiredFields,
  isValidPart1: containsAllRequiredFields,
  getFieldSafeAndValidate: getFieldSafeAndValidate,
  validateStringAsInt: validateStringAsInt,
  between: between,
  isValidByr: isValidByr,
  isValidIyr: isValidIyr,
  isValidEyr: isValidEyr,
  eclValidator: eclValidator,
  isValidEcl: isValidEcl,
  lengthIs: lengthIs,
  charIsInt: charIsInt,
  charIsHex: charIsHex,
  validateCharsInString: validateCharsInString,
  pidValidator: pidValidator,
  isValidPid: isValidPid,
  hclValidator: hclValidator,
  isValidHcl: isValidHcl,
  hgtRe: hgtRe,
  hgtValidator: hgtValidator,
  isValidHgt: isValidHgt,
  isValidPart2: isValidPart2,
  make: make
};

function parse(data) {
  return Belt_Array.map(data.split("\n\n"), x => x.trim().replace(/(\r\n|\r|\n|\s)+/g, " "));
}

function solvePart1(data) {
  let parsed = parse(data);
  let p = Belt_Array.map(parsed, make);
  return Belt_Array.keep(Belt_Array.map(p, containsAllRequiredFields), a => a).length;
}

function solvePart2(data) {
  let parsed = parse(data);
  let p = Belt_Array.map(parsed, make);
  return Belt_Array.keep(Belt_Array.map(p, isValidPart2), a => a).length;
}

export {
  log,
  Passport,
  parse,
  solvePart1,
  solvePart2,
}
/* No side effect */
