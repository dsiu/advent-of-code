// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Belt_Int from "rescript/lib/es6/belt_Int.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Belt_MapString from "rescript/lib/es6/belt_MapString.js";

function log(prim) {
  console.log(prim);
}

var requiredFields = [
  "byr",
  "iyr",
  "eyr",
  "hgt",
  "hcl",
  "ecl",
  "pid"
];

var optionalFields = ["cid"];

function kvStrToMap(xs) {
  return Belt_Array.reduce(xs, undefined, (function (a, s) {
                var kvs = s.split(":");
                return Belt_MapString.set(a, Belt_Array.getExn(kvs, 0), Belt_Array.getExn(kvs, 1));
              }));
}

function containsAllFields(t, fields) {
  return Belt_Array.reduce(fields, true, (function (a, f) {
                if (a) {
                  return Belt_MapString.has(t, f);
                } else {
                  return false;
                }
              }));
}

function containsAllOptionalFields(__x) {
  return containsAllFields(__x, optionalFields);
}

function containsAllRequiredFields(__x) {
  return containsAllFields(__x, requiredFields);
}

function getFieldSafeAndValidate(t, field, f) {
  var v = Belt_MapString.get(t, field);
  if (v !== undefined) {
    return Curry._1(f, Caml_option.valFromOption(v));
  } else {
    return false;
  }
}

function validateStringAsInt(s, f) {
  var n = Belt_Int.fromString(s);
  if (n !== undefined) {
    return Curry._1(f, n);
  } else {
    return false;
  }
}

function between(x, a, b) {
  if (Caml_obj.greaterequal(x, a)) {
    return Caml_obj.lessequal(x, b);
  } else {
    return false;
  }
}

function isValidByr(__x) {
  return getFieldSafeAndValidate(__x, "byr", (function (__x) {
                return validateStringAsInt(__x, (function (__x) {
                              return between(__x, 1920, 2002);
                            }));
              }));
}

function isValidIyr(__x) {
  return getFieldSafeAndValidate(__x, "iyr", (function (__x) {
                return validateStringAsInt(__x, (function (__x) {
                              return between(__x, 2010, 2020);
                            }));
              }));
}

function isValidEyr(__x) {
  return getFieldSafeAndValidate(__x, "eyr", (function (__x) {
                return validateStringAsInt(__x, (function (__x) {
                              return between(__x, 2020, 2030);
                            }));
              }));
}

function eclValidator(s) {
  var eyeColors = [
    "amb",
    "blu",
    "brn",
    "gry",
    "grn",
    "hzl",
    "oth"
  ];
  return Belt_Array.some(eyeColors, (function (x) {
                return x === s;
              }));
}

function isValidEcl(__x) {
  return getFieldSafeAndValidate(__x, "ecl", eclValidator);
}

function lengthIs(s, l) {
  return s.length === l;
}

function charIsInt(s) {
  return Belt_Int.fromString(s) !== undefined;
}

function charIsHex(s) {
  if (s >= "0" && s <= "9") {
    return true;
  } else if (s >= "a") {
    return s <= "f";
  } else {
    return false;
  }
}

function validateCharsInString(s, f) {
  return Belt_Array.reduce(s.split(""), true, (function (a, x) {
                if (a) {
                  return Curry._1(f, x);
                } else {
                  return false;
                }
              }));
}

function pidValidator(s) {
  if (s.length === 9) {
    return validateCharsInString(s, charIsInt);
  } else {
    return false;
  }
}

function isValidPid(__x) {
  return getFieldSafeAndValidate(__x, "pid", pidValidator);
}

function hclValidator(s) {
  if (s.length === 7 && s.slice(0, 1) === "#") {
    return validateCharsInString(s.slice(1, 7), charIsHex);
  } else {
    return false;
  }
}

function isValidHcl(__x) {
  return getFieldSafeAndValidate(__x, "hcl", hclValidator);
}

var hgtRe = /(\d+)(in|cm)/i;

function hgtValidator(s) {
  var x = hgtRe.exec(s);
  if (x === null) {
    return false;
  }
  var h = Belt_Option.getExn(Caml_option.nullable_to_opt(Belt_Array.getExn(x, 1)));
  var u = Belt_Option.getExn(Caml_option.nullable_to_opt(Belt_Array.getExn(x, 2)));
  var match = Belt_Int.fromString(h);
  switch (u) {
    case "cm" :
        if (match !== undefined) {
          return between(match, 150, 193);
        } else {
          return false;
        }
    case "in" :
        if (match !== undefined) {
          return between(match, 56, 76);
        } else {
          return false;
        }
    default:
      return false;
  }
}

function isValidHgt(__x) {
  return getFieldSafeAndValidate(__x, "hgt", hgtValidator);
}

function isValidPart2(t) {
  var validators = [
    containsAllRequiredFields,
    isValidByr,
    isValidIyr,
    isValidEyr,
    isValidHgt,
    isValidHcl,
    isValidEcl,
    isValidPid
  ];
  return Belt_Array.reduce(validators, true, (function (a, f) {
                if (a) {
                  return Curry._1(f, t);
                } else {
                  return false;
                }
              }));
}

function make(s) {
  return kvStrToMap(s.split(" "));
}

var Passport = {
  requiredFields: requiredFields,
  optionalFields: optionalFields,
  kvStrToMap: kvStrToMap,
  containsAllFields: containsAllFields,
  containsAllOptionalFields: containsAllOptionalFields,
  containsAllRequiredFields: containsAllRequiredFields,
  isValidPart1: containsAllRequiredFields,
  getFieldSafeAndValidate: getFieldSafeAndValidate,
  validateStringAsInt: validateStringAsInt,
  between: between,
  isValidByr: isValidByr,
  isValidIyr: isValidIyr,
  isValidEyr: isValidEyr,
  eclValidator: eclValidator,
  isValidEcl: isValidEcl,
  lengthIs: lengthIs,
  charIsInt: charIsInt,
  charIsHex: charIsHex,
  validateCharsInString: validateCharsInString,
  pidValidator: pidValidator,
  isValidPid: isValidPid,
  hclValidator: hclValidator,
  isValidHcl: isValidHcl,
  hgtRe: hgtRe,
  hgtValidator: hgtValidator,
  isValidHgt: isValidHgt,
  isValidPart2: isValidPart2,
  make: make
};

function parse(data) {
  return Belt_Array.map(data.split("\n\n"), (function (x) {
                return x.trim().replace(/(\r\n|\r|\n|\s)+/g, " ");
              }));
}

function solvePart1(data) {
  var parsed = parse(data);
  var p = Belt_Array.map(parsed, make);
  return Belt_Array.keep(Belt_Array.map(p, containsAllRequiredFields), (function (a) {
                return a;
              })).length;
}

function solvePart2(data) {
  var parsed = parse(data);
  var p = Belt_Array.map(parsed, make);
  return Belt_Array.keep(Belt_Array.map(p, isValidPart2), (function (a) {
                return a;
              })).length;
}

export {
  log ,
  Passport ,
  parse ,
  solvePart1 ,
  solvePart2 ,
}
/* No side effect */
