// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Int from "rescript/lib/es6/belt_Int.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Belt_Result from "rescript/lib/es6/belt_Result.js";
import * as Belt_SortArrayInt from "rescript/lib/es6/belt_SortArrayInt.js";
import * as Utils$AdventOfCode from "../../Utils.bs.js";

function codes(t) {
  return t.codes;
}

function getCode(t, i) {
  return Belt_Array.get(t.codes, i);
}

function getCodeExn(t, i) {
  return Belt_Array.getExn(t.codes, i);
}

function codeSize(t) {
  return t.codes.length;
}

function runLength(t) {
  return t.runLength;
}

function preambles(t) {
  return Belt_Array.slice(t.codes, 0, t.runLength);
}

function make(codes, runLength) {
  if (codes.length > runLength) {
    return {
            TAG: /* Ok */0,
            _0: {
              codes: codes,
              runLength: runLength
            }
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: /* InvalidRunLength */0
          };
  }
}

function isSumofWith(xs, x, sum) {
  return Belt_Array.keep(xs, (function (a) {
                if (a !== x) {
                  return (a + x | 0) === sum;
                } else {
                  return false;
                }
              }));
}

function isSumOf(xs, sum) {
  return Belt_Array.keep(xs, (function (a) {
                return isSumofWith(xs, a, sum).length !== 0;
              }));
}

function findSumOf(xs, sum) {
  var sumArray = isSumOf(xs, sum);
  if (sumArray.length === 0) {
    return ;
  } else {
    return sumArray;
  }
}

function isCodeValid(t, i) {
  var lastSet = Belt_Array.slice(t.codes, i - t.runLength | 0, t.runLength);
  var code = Belt_Array.get(t.codes, i);
  if (code !== undefined) {
    return {
            TAG: /* Ok */0,
            _0: findSumOf(lastSet, code)
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: /* InvalidIndex */1
          };
  }
}

function findInvalidCode(t) {
  var _i = t.runLength;
  while(true) {
    var i = _i;
    if (i >= t.codes.length) {
      return ;
    }
    var sumOk = isCodeValid(t, i);
    if (sumOk.TAG !== /* Ok */0) {
      return ;
    }
    if (sumOk._0 === undefined) {
      return Belt_Array.getExn(t.codes, i);
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function findContiguousSetAt(xs, start, badCode) {
  var _len = 1;
  while(true) {
    var len = _len;
    var s = Utils$AdventOfCode.sumRange(xs, start, len);
    if (s === badCode) {
      return len;
    }
    if (s >= badCode) {
      return ;
    }
    _len = len + 1 | 0;
    continue ;
  };
}

function findContiguousSet(t, badCode) {
  var xs = t.codes;
  var _start = 0;
  while(true) {
    var start = _start;
    if (start > xs.length) {
      return ;
    }
    var len = findContiguousSetAt(xs, start, badCode);
    if (len !== undefined) {
      return Belt_Array.slice(xs, start, len);
    }
    _start = start + 1 | 0;
    continue ;
  };
}

var Xmax = {
  codes: codes,
  getCode: getCode,
  getCodeExn: getCodeExn,
  codeSize: codeSize,
  runLength: runLength,
  preambles: preambles,
  make: make,
  isSumofWith: isSumofWith,
  isSumOf: isSumOf,
  findSumOf: findSumOf,
  isCodeValid: isCodeValid,
  findInvalidCode: findInvalidCode,
  findContiguousSetAt: findContiguousSetAt,
  findContiguousSet: findContiguousSet
};

function parse(data) {
  return Belt_Array.map(Utils$AdventOfCode.splitNewline(data), (function (x) {
                return Belt_Option.getExn(Belt_Int.fromString(x.trim()));
              }));
}

function solvePart1(data, preambleSize) {
  var xmax = Belt_Result.getExn(make(parse(data), preambleSize));
  return Belt_Option.getExn(findInvalidCode(xmax));
}

function solvePart2(data, preambleSize) {
  var xmax = Belt_Result.getExn(make(parse(data), preambleSize));
  var badCode = Belt_Option.getExn(findInvalidCode(xmax));
  var sorted = Belt_SortArrayInt.stableSort(Belt_Option.getExn(findContiguousSet(xmax, badCode)));
  var min = Belt_Option.getExn(Belt_Array.get(sorted, 0));
  var max = Belt_Option.getExn(Belt_Array.get(sorted, sorted.length - 1 | 0));
  return min + max | 0;
}

var log = Utils$AdventOfCode.log;

export {
  log ,
  Xmax ,
  parse ,
  solvePart1 ,
  solvePart2 ,
  
}
/* No side effect */
