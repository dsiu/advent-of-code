// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/Belt_Option.js";
import * as Belt_Result from "rescript/lib/es6/Belt_Result.js";
import * as Belt_SortArrayInt from "rescript/lib/es6/Belt_SortArrayInt.js";
import * as Utils$AdventOfCode from "../../Utils.mjs";

function log(prim) {
  console.log(prim);
}

function codes(t) {
  return t.codes;
}

function getCode(t, i) {
  return Belt_Array.get(t.codes, i);
}

function getCodeExn(t, i) {
  return Belt_Array.getExn(t.codes, i);
}

function codeSize(t) {
  return t.codes.length;
}

function runLength(t) {
  return t.runLength;
}

function preambles(t) {
  return Belt_Array.slice(t.codes, 0, t.runLength);
}

function make(codes, runLength) {
  if (codes.length > runLength) {
    return {
      TAG: "Ok",
      _0: {
        codes: codes,
        runLength: runLength
      }
    };
  } else {
    return {
      TAG: "Error",
      _0: "InvalidRunLength"
    };
  }
}

function isSumofWith(xs, x, sum) {
  return Belt_Array.keep(xs, a => {
    if (a !== x) {
      return (a + x | 0) === sum;
    } else {
      return false;
    }
  });
}

function isSumOf(xs, sum) {
  return Belt_Array.keep(xs, a => isSumofWith(xs, a, sum).length !== 0);
}

function findSumOf(xs, sum) {
  let sumArray = isSumOf(xs, sum);
  if (sumArray.length === 0) {
    return;
  } else {
    return sumArray;
  }
}

function isCodeValid(t, i) {
  let lastSet = Belt_Array.slice(t.codes, i - t.runLength | 0, t.runLength);
  let code = Belt_Array.get(t.codes, i);
  if (code !== undefined) {
    return {
      TAG: "Ok",
      _0: findSumOf(lastSet, code)
    };
  } else {
    return {
      TAG: "Error",
      _0: "InvalidIndex"
    };
  }
}

function findInvalidCode(t) {
  let _i = t.runLength;
  while (true) {
    let i = _i;
    if (i >= t.codes.length) {
      return;
    }
    let sumOk = isCodeValid(t, i);
    if (sumOk.TAG !== "Ok") {
      return;
    }
    if (sumOk._0 === undefined) {
      return Belt_Array.getExn(t.codes, i);
    }
    _i = i + 1 | 0;
    continue;
  };
}

function findContiguousSetAt(xs, start, badCode) {
  let _len = 1;
  while (true) {
    let len = _len;
    let s = Utils$AdventOfCode.sumRange(xs, start, len);
    if (s === badCode) {
      return len;
    }
    if (s >= badCode) {
      return;
    }
    _len = len + 1 | 0;
    continue;
  };
}

function findContiguousSet(t, badCode) {
  let xs = t.codes;
  let _start = 0;
  while (true) {
    let start = _start;
    if (start > xs.length) {
      return;
    }
    let len = findContiguousSetAt(xs, start, badCode);
    if (len !== undefined) {
      return Belt_Array.slice(xs, start, len);
    }
    _start = start + 1 | 0;
    continue;
  };
}

let Xmax = {
  codes: codes,
  getCode: getCode,
  getCodeExn: getCodeExn,
  codeSize: codeSize,
  runLength: runLength,
  preambles: preambles,
  make: make,
  isSumofWith: isSumofWith,
  isSumOf: isSumOf,
  findSumOf: findSumOf,
  isCodeValid: isCodeValid,
  findInvalidCode: findInvalidCode,
  findContiguousSetAt: findContiguousSetAt,
  findContiguousSet: findContiguousSet
};

function parse(data) {
  return Belt_Array.map(Utils$AdventOfCode.splitNewline(data), Utils$AdventOfCode.intFromStringExn);
}

function solvePart1(data, preambleSize) {
  let xmax = Belt_Result.getExn(make(parse(data), preambleSize));
  return Belt_Option.getExn(findInvalidCode(xmax));
}

function solvePart2(data, preambleSize) {
  let xmax = Belt_Result.getExn(make(parse(data), preambleSize));
  let badCode = Belt_Option.getExn(findInvalidCode(xmax));
  let sorted = Belt_SortArrayInt.stableSort(Belt_Option.getExn(findContiguousSet(xmax, badCode)));
  let min = Belt_Option.getExn(Belt_Array.get(sorted, 0));
  let max = Belt_Option.getExn(Belt_Array.get(sorted, sorted.length - 1 | 0));
  return min + max | 0;
}

export {
  log,
  Xmax,
  parse,
  solvePart1,
  solvePart2,
}
/* Utils-AdventOfCode Not a pure module */
