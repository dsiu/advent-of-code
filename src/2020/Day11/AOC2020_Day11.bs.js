// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";
import * as Utils$AdventOfCode from "../../Utils.bs.js";
import * as Array2D$AdventOfCode from "../../Array2D.bs.js";
import * as Coordinate$AdventOfCode from "../../Coordinate.bs.js";

function log(prim) {
  console.log(prim);
  
}

var InvalidStatus = /* @__PURE__ */Caml_exceptions.create("AOC2020_Day11-AdventOfCode.SeatMap.InvalidStatus");

function make(c) {
  switch (c) {
    case "#" :
        return "#";
    case "." :
        return ".";
    case "L" :
        return "L";
    default:
      throw {
            RE_EXN_ID: InvalidStatus,
            _1: c,
            Error: new Error()
          };
  }
}

var SeatStatus = {
  make: make
};

function isValidCoord(param, len_x, len_y) {
  var y = param[1];
  var x = param[0];
  if (x >= 0 && x <= (len_x - 1 | 0) && y >= 0) {
    return y <= (len_y - 1 | 0);
  } else {
    return false;
  }
}

function adjCoords(c) {
  return Belt_Array.map([
              Coordinate$AdventOfCode.stepNW,
              Coordinate$AdventOfCode.stepN,
              Coordinate$AdventOfCode.stepNE,
              Coordinate$AdventOfCode.stepW,
              Coordinate$AdventOfCode.stepE,
              Coordinate$AdventOfCode.stepSW,
              Coordinate$AdventOfCode.stepS,
              Coordinate$AdventOfCode.stepSE
            ], (function (f) {
                return Curry._1(f, c);
              }));
}

function getAdjacents(t, param) {
  return Belt_Array.keepMap(adjCoords([
                  param[0],
                  param[1]
                ]), (function (c) {
                if (Array2D$AdventOfCode.isValidXY(t, c)) {
                  return Caml_option.some(Array2D$AdventOfCode.getExn(t, c));
                }
                
              }));
}

function isSeatEq(s, to_be) {
  return s === to_be;
}

function countSeat(xs, seatStatus) {
  return Belt_Array.keep(xs, (function (__x) {
                return __x === seatStatus;
              })).length;
}

function countEmptySeat(__x) {
  return countSeat(__x, "L");
}

function countFloor(__x) {
  return countSeat(__x, ".");
}

function countOccupiedSeat(__x) {
  return countSeat(__x, "#");
}

function transformPart1(s, adjacents) {
  var occupied_seats = countSeat(adjacents, "#");
  if (s === ".") {
    return ".";
  } else if (s === "L") {
    if (occupied_seats === 0) {
      return "#";
    } else {
      return "L";
    }
  } else if (occupied_seats >= 4) {
    return "L";
  } else {
    return "#";
  }
}

function iteratePart1(t) {
  return Array2D$AdventOfCode.mapWithIndex(t, (function (param, s) {
                return transformPart1(s, getAdjacents(t, [
                                param[0],
                                param[1]
                              ]));
              }));
}

function nextSeatIn(t, _param, step) {
  while(true) {
    var param = _param;
    var c = Curry._1(step, [
          param[0],
          param[1]
        ]);
    if (!Array2D$AdventOfCode.isValidXY(t, c)) {
      return ".";
    }
    var seat = Belt_Option.getExn(Array2D$AdventOfCode.get(t, c));
    if (seat !== ".") {
      return seat;
    }
    _param = c;
    continue ;
  };
}

function getDirectionals(t, c) {
  return Belt_Array.map([
              Coordinate$AdventOfCode.stepNW,
              Coordinate$AdventOfCode.stepN,
              Coordinate$AdventOfCode.stepNE,
              Coordinate$AdventOfCode.stepW,
              Coordinate$AdventOfCode.stepE,
              Coordinate$AdventOfCode.stepSW,
              Coordinate$AdventOfCode.stepS,
              Coordinate$AdventOfCode.stepSE
            ], (function (f) {
                return nextSeatIn(t, c, f);
              }));
}

function transformPart2(s, directionals) {
  var occupied_seats = countSeat(directionals, "#");
  if (s === ".") {
    return ".";
  } else if (s === "L") {
    if (occupied_seats === 0) {
      return "#";
    } else {
      return "L";
    }
  } else if (occupied_seats >= 5) {
    return "L";
  } else {
    return "#";
  }
}

function iteratePart2(t) {
  return Array2D$AdventOfCode.mapWithIndex(t, (function (param, s) {
                return transformPart2(s, getDirectionals(t, [
                                param[0],
                                param[1]
                              ]));
              }));
}

function stabilize(_t, solver) {
  while(true) {
    var t = _t;
    var t_next = Curry._1(solver, t);
    if (Array2D$AdventOfCode.eq(t, t_next)) {
      return t;
    }
    _t = t_next;
    continue ;
  };
}

function solvePart1(__x) {
  return stabilize(__x, iteratePart1);
}

function solvePart2(__x) {
  return stabilize(__x, iteratePart2);
}

function make$1(xs) {
  var x = Belt_Array.getExn(xs, 0).length;
  var y = xs.length;
  var ret = Array2D$AdventOfCode.make([
        x,
        y
      ], ".");
  Belt_Array.forEachWithIndex(xs, (function (y, ys) {
          return Belt_Array.forEachWithIndex(Utils$AdventOfCode.splitChars(ys), (function (x, c) {
                        Array2D$AdventOfCode.set(ret, [
                              x,
                              y
                            ], make(c));
                        
                      }));
        }));
  return ret;
}

function dump(t) {
  for(var y = 0 ,y_finish = Array2D$AdventOfCode.lengthY(t); y < y_finish; ++y){
    var prim = Utils$AdventOfCode.join(Belt_Option.getExn(Array2D$AdventOfCode.getYEquals(t, y)));
    console.log(prim);
  }
  
}

var SeatMap = {
  InvalidStatus: InvalidStatus,
  SeatStatus: SeatStatus,
  isValidCoord: isValidCoord,
  adjCoords: adjCoords,
  getAdjacents: getAdjacents,
  isSeatEq: isSeatEq,
  countSeat: countSeat,
  countEmptySeat: countEmptySeat,
  countFloor: countFloor,
  countOccupiedSeat: countOccupiedSeat,
  transformPart1: transformPart1,
  iteratePart1: iteratePart1,
  nextSeatIn: nextSeatIn,
  getDirectionals: getDirectionals,
  transformPart2: transformPart2,
  iteratePart2: iteratePart2,
  isStabilized: Array2D$AdventOfCode.eq,
  stabilize: stabilize,
  solvePart1: solvePart1,
  solvePart2: solvePart2,
  make: make$1,
  dump: dump
};

function parse(data) {
  return make$1(Belt_Array.map(data.split("\n"), (function (prim) {
                    return prim.trim();
                  })));
}

function solvePart1$1(data) {
  var seats = parse(data);
  var result = stabilize(seats, iteratePart1);
  return countSeat(Array2D$AdventOfCode.flatten(result), "#");
}

function solvePart2$1(data) {
  var seats = parse(data);
  var result = stabilize(seats, iteratePart2);
  return countSeat(Array2D$AdventOfCode.flatten(result), "#");
}

export {
  log ,
  SeatMap ,
  parse ,
  solvePart1$1 as solvePart1,
  solvePart2$1 as solvePart2,
  
}
/* No side effect */
