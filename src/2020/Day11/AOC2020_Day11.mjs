// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Stdlib__Array from "@dsiu/rescript-stdlib-fp/src/Stdlib__Array.mjs";
import * as Stdlib__Option from "@dsiu/rescript-stdlib-fp/src/Stdlib__Option.mjs";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";
import * as Utils$AdventOfCode from "../../Utils.mjs";
import * as Array2D$AdventOfCode from "../../Array2D.mjs";
import * as Coordinate$AdventOfCode from "../../Coordinate.mjs";

function log(prim) {
  console.log(prim);
}

var InvalidStatus = /* @__PURE__ */Caml_exceptions.create("AOC2020_Day11-AdventOfCode.SeatMap.InvalidStatus");

function make(c) {
  switch (c) {
    case "#" :
        return "#";
    case "." :
        return ".";
    case "L" :
        return "L";
    default:
      throw {
            RE_EXN_ID: InvalidStatus,
            _1: c,
            Error: new Error()
          };
  }
}

var SeatStatus = {
  make: make
};

function isValidCoord(param, len_x, len_y) {
  var y = param[1];
  var x = param[0];
  if (x >= 0 && x <= (len_x - 1 | 0) && y >= 0) {
    return y <= (len_y - 1 | 0);
  } else {
    return false;
  }
}

function adjCoords(c) {
  return [
            Coordinate$AdventOfCode.StepFunctions.stepNW,
            Coordinate$AdventOfCode.StepFunctions.stepN,
            Coordinate$AdventOfCode.StepFunctions.stepNE,
            Coordinate$AdventOfCode.StepFunctions.stepW,
            Coordinate$AdventOfCode.StepFunctions.stepE,
            Coordinate$AdventOfCode.StepFunctions.stepSW,
            Coordinate$AdventOfCode.StepFunctions.stepS,
            Coordinate$AdventOfCode.StepFunctions.stepSE
          ].map(function (f) {
              return f(c);
            });
}

function getAdjacents(t, param) {
  return Stdlib__Array.filterMap(adjCoords([
                  param[0],
                  param[1]
                ]), (function (c) {
                if (Array2D$AdventOfCode.isValidXY(t, c)) {
                  return Caml_option.some(Array2D$AdventOfCode.getExn(t, c));
                }
                
              }));
}

function isSeatEq(s, to_be) {
  return s === to_be;
}

function countSeat(xs, seatStatus) {
  return xs.filter(function (__x) {
              return __x === seatStatus;
            }).length;
}

function countEmptySeat(__x) {
  return countSeat(__x, "L");
}

function countFloor(__x) {
  return countSeat(__x, ".");
}

function countOccupiedSeat(__x) {
  return countSeat(__x, "#");
}

function transformPart1(s, adjacents) {
  var occupied_seats = countSeat(adjacents, "#");
  if (s === ".") {
    return ".";
  } else if (s === "L") {
    if (occupied_seats === 0) {
      return "#";
    } else {
      return "L";
    }
  } else if (occupied_seats >= 4) {
    return "L";
  } else {
    return "#";
  }
}

function iteratePart1(t) {
  return Array2D$AdventOfCode.mapWithIndex(t, (function (param, s) {
                return transformPart1(s, getAdjacents(t, [
                                param[0],
                                param[1]
                              ]));
              }));
}

function nextSeatIn(t, _param, step) {
  while(true) {
    var param = _param;
    var c = Curry._1(step, [
          param[0],
          param[1]
        ]);
    if (!Array2D$AdventOfCode.isValidXY(t, c)) {
      return ".";
    }
    var seat = Stdlib__Option.getExn(Array2D$AdventOfCode.get(t, c));
    if (seat !== ".") {
      return seat;
    }
    _param = c;
    continue ;
  };
}

function getDirectionals(t, c) {
  return [
            Coordinate$AdventOfCode.StepFunctions.stepNW,
            Coordinate$AdventOfCode.StepFunctions.stepN,
            Coordinate$AdventOfCode.StepFunctions.stepNE,
            Coordinate$AdventOfCode.StepFunctions.stepW,
            Coordinate$AdventOfCode.StepFunctions.stepE,
            Coordinate$AdventOfCode.StepFunctions.stepSW,
            Coordinate$AdventOfCode.StepFunctions.stepS,
            Coordinate$AdventOfCode.StepFunctions.stepSE
          ].map(function (f) {
              return nextSeatIn(t, c, f);
            });
}

function transformPart2(s, directionals) {
  var occupied_seats = countSeat(directionals, "#");
  if (s === ".") {
    return ".";
  } else if (s === "L") {
    if (occupied_seats === 0) {
      return "#";
    } else {
      return "L";
    }
  } else if (occupied_seats >= 5) {
    return "L";
  } else {
    return "#";
  }
}

function iteratePart2(t) {
  return Array2D$AdventOfCode.mapWithIndex(t, (function (param, s) {
                return transformPart2(s, getDirectionals(t, [
                                param[0],
                                param[1]
                              ]));
              }));
}

function stabilize(_t, solver) {
  while(true) {
    var t = _t;
    var t_next = solver(t);
    if (Array2D$AdventOfCode.eq(t, t_next)) {
      return t;
    }
    _t = t_next;
    continue ;
  };
}

function solvePart1(__x) {
  return stabilize(__x, iteratePart1);
}

function solvePart2(__x) {
  return stabilize(__x, iteratePart2);
}

function make$1(xs) {
  var x = Stdlib__Array.getUnsafe(xs, 0).length;
  var y = xs.length;
  var ret = Array2D$AdventOfCode.make([
        x,
        y
      ], ".");
  xs.forEach(function (ys, y) {
        Utils$AdventOfCode.splitChars(ys).forEach(function (c, x) {
              Array2D$AdventOfCode.set(ret, [
                    x,
                    y
                  ], make(c));
            });
      });
  return ret;
}

function toString(t) {
  var s = "";
  for(var y = 0 ,y_finish = Array2D$AdventOfCode.lengthY(t); y < y_finish; ++y){
    s = s + Utils$AdventOfCode.join(Stdlib__Option.getExn(Array2D$AdventOfCode.getYEquals(t, y)));
  }
  return s;
}

var SeatMap = {
  InvalidStatus: InvalidStatus,
  SeatStatus: SeatStatus,
  isValidCoord: isValidCoord,
  adjCoords: adjCoords,
  getAdjacents: getAdjacents,
  isSeatEq: isSeatEq,
  countSeat: countSeat,
  countEmptySeat: countEmptySeat,
  countFloor: countFloor,
  countOccupiedSeat: countOccupiedSeat,
  transformPart1: transformPart1,
  iteratePart1: iteratePart1,
  nextSeatIn: nextSeatIn,
  getDirectionals: getDirectionals,
  transformPart2: transformPart2,
  iteratePart2: iteratePart2,
  isStabilized: Array2D$AdventOfCode.eq,
  stabilize: stabilize,
  solvePart1: solvePart1,
  solvePart2: solvePart2,
  make: make$1,
  toString: toString
};

function parse(data) {
  var parsed = data.split("\n").map(function (prim) {
        return prim.trim();
      });
  return make$1(parsed);
}

function solvePart1$1(data) {
  var seats = parse(data);
  var result = stabilize(seats, iteratePart1);
  var result_flat = Array2D$AdventOfCode.flatten(result);
  return countSeat(result_flat, "#");
}

function solvePart2$1(data) {
  var seats = parse(data);
  var result = stabilize(seats, iteratePart2);
  var result_flat = Array2D$AdventOfCode.flatten(result);
  return countSeat(result_flat, "#");
}

export {
  log ,
  SeatMap ,
  parse ,
  solvePart1$1 as solvePart1,
  solvePart2$1 as solvePart2,
}
/* Stdlib__Array Not a pure module */
