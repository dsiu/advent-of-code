// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Utils from "../../Utils.res.mjs";
import * as Array2D from "../../Array2D.res.mjs";
import * as Coordinate from "../../Coordinate.res.mjs";
import * as Stdlib__Array from "@dsiu/rescript-stdlib-fp/src/Stdlib__Array.res.mjs";
import * as Stdlib__Option from "@dsiu/rescript-stdlib-fp/src/Stdlib__Option.res.mjs";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";
import * as Primitive_exceptions from "rescript/lib/es6/Primitive_exceptions.js";

function log(prim) {
  console.log(prim);
}

let InvalidStatus = /* @__PURE__ */Primitive_exceptions.create("AOC2020_Day11.SeatMap.InvalidStatus");

function make(c) {
  switch (c) {
    case "#" :
      return "#";
    case "." :
      return ".";
    case "L" :
      return "L";
    default:
      throw {
        RE_EXN_ID: InvalidStatus,
        _1: c,
        Error: new Error()
      };
  }
}

let SeatStatus = {
  make: make
};

function isValidCoord(param, len_x, len_y) {
  let y = param[1];
  let x = param[0];
  if (x >= 0 && x <= (len_x - 1 | 0) && y >= 0) {
    return y <= (len_y - 1 | 0);
  } else {
    return false;
  }
}

function adjCoords(c) {
  return [
    Coordinate.StepFunctions.stepNW,
    Coordinate.StepFunctions.stepN,
    Coordinate.StepFunctions.stepNE,
    Coordinate.StepFunctions.stepW,
    Coordinate.StepFunctions.stepE,
    Coordinate.StepFunctions.stepSW,
    Coordinate.StepFunctions.stepS,
    Coordinate.StepFunctions.stepSE
  ].map(f => f(c));
}

function getAdjacents(t, param) {
  return Stdlib__Array.filterMap(adjCoords([
    param[0],
    param[1]
  ]), c => {
    if (Array2D.isValidXY(t, c)) {
      return Primitive_option.some(Array2D.getExn(t, c));
    }
    
  });
}

function isSeatEq(s, to_be) {
  return s === to_be;
}

function countSeat(xs, seatStatus) {
  return Stdlib__Array.count(xs, __x => __x === seatStatus);
}

function countEmptySeat(__x) {
  return countSeat(__x, "L");
}

function countFloor(__x) {
  return countSeat(__x, ".");
}

function countOccupiedSeat(__x) {
  return countSeat(__x, "#");
}

function transformPart1(s, adjacents) {
  let occupied_seats = countSeat(adjacents, "#");
  if (s === ".") {
    return ".";
  } else if (s === "L") {
    if (occupied_seats === 0) {
      return "#";
    } else {
      return "L";
    }
  } else if (occupied_seats >= 4) {
    return "L";
  } else {
    return "#";
  }
}

function iteratePart1(t) {
  return Array2D.mapWithIndex(t, (param, s) => transformPart1(s, getAdjacents(t, [
    param[0],
    param[1]
  ])));
}

function nextSeatIn(t, _param, step) {
  while (true) {
    let param = _param;
    let c = step([
      param[0],
      param[1]
    ]);
    if (!Array2D.isValidXY(t, c)) {
      return ".";
    }
    let seat = Stdlib__Option.getExn(Array2D.get(t, c), undefined);
    if (seat !== ".") {
      return seat;
    }
    _param = c;
    continue;
  };
}

function getDirectionals(t, c) {
  return [
    Coordinate.StepFunctions.stepNW,
    Coordinate.StepFunctions.stepN,
    Coordinate.StepFunctions.stepNE,
    Coordinate.StepFunctions.stepW,
    Coordinate.StepFunctions.stepE,
    Coordinate.StepFunctions.stepSW,
    Coordinate.StepFunctions.stepS,
    Coordinate.StepFunctions.stepSE
  ].map(f => nextSeatIn(t, c, f));
}

function transformPart2(s, directionals) {
  let occupied_seats = countSeat(directionals, "#");
  if (s === ".") {
    return ".";
  } else if (s === "L") {
    if (occupied_seats === 0) {
      return "#";
    } else {
      return "L";
    }
  } else if (occupied_seats >= 5) {
    return "L";
  } else {
    return "#";
  }
}

function iteratePart2(t) {
  return Array2D.mapWithIndex(t, (param, s) => transformPart2(s, getDirectionals(t, [
    param[0],
    param[1]
  ])));
}

function stabilize(_t, solver) {
  while (true) {
    let t = _t;
    let t_next = solver(t);
    if (Array2D.eq(t, t_next)) {
      return t;
    }
    _t = t_next;
    continue;
  };
}

function solvePart1(__x) {
  return stabilize(__x, iteratePart1);
}

function solvePart2(__x) {
  return stabilize(__x, iteratePart2);
}

function make$1(xs) {
  let x = Stdlib__Array.getUnsafe(xs, 0).length;
  let y = xs.length;
  let ret = Array2D.make([
    x,
    y
  ], ".");
  xs.forEach((ys, y) => {
    Utils.splitChars(ys).forEach((c, x) => {
      Array2D.set(ret, [
        x,
        y
      ], make(c));
    });
  });
  return ret;
}

function toString(t) {
  let s = "";
  for (let y = 0, y_finish = Array2D.lengthY(t); y < y_finish; ++y) {
    s = s + Utils.join(Stdlib__Option.getExn(Array2D.getYEquals(t, y), undefined));
  }
  return s;
}

let SeatMap = {
  InvalidStatus: InvalidStatus,
  SeatStatus: SeatStatus,
  isValidCoord: isValidCoord,
  adjCoords: adjCoords,
  getAdjacents: getAdjacents,
  isSeatEq: isSeatEq,
  countSeat: countSeat,
  countEmptySeat: countEmptySeat,
  countFloor: countFloor,
  countOccupiedSeat: countOccupiedSeat,
  transformPart1: transformPart1,
  iteratePart1: iteratePart1,
  nextSeatIn: nextSeatIn,
  getDirectionals: getDirectionals,
  transformPart2: transformPart2,
  iteratePart2: iteratePart2,
  isStabilized: Array2D.eq,
  stabilize: stabilize,
  solvePart1: solvePart1,
  solvePart2: solvePart2,
  make: make$1,
  toString: toString
};

function parse(data) {
  return make$1(data.split("\n").map(prim => prim.trim()));
}

function solvePart1$1(data) {
  let seats = parse(data);
  let result = stabilize(seats, iteratePart1);
  return countSeat(Array2D.flatten(result), "#");
}

function solvePart2$1(data) {
  let seats = parse(data);
  let result = stabilize(seats, iteratePart2);
  return countSeat(Array2D.flatten(result), "#");
}

export {
  log,
  SeatMap,
  parse,
  solvePart1$1 as solvePart1,
  solvePart2$1 as solvePart2,
}
/* Utils Not a pure module */
