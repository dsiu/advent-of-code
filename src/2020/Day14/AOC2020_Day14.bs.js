// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Int64 = require("rescript/lib/js/int64.js");
var Belt_Int = require("rescript/lib/js/belt_Int.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_int64 = require("rescript/lib/js/caml_int64.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_format = require("rescript/lib/js/caml_format.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Belt_MutableMapInt = require("rescript/lib/js/belt_MutableMapInt.js");
var Utils$AdventOfCode = require("../../Utils.bs.js");

function log(prim) {
  console.log(prim);
  
}

function base2(__x) {
  return __x.toString(2);
}

function onlyXto1(c) {
  if (c === "X") {
    return "1";
  } else {
    return "0";
  }
}

function only1to1(c) {
  if (c === "1") {
    return "1";
  } else {
    return "0";
  }
}

function only0to1(c) {
  if (c === "0") {
    return "1";
  } else {
    return "0";
  }
}

function makeMask(m, f) {
  return Caml_format.caml_int64_of_string("0b" + Belt_Array.map(Utils$AdventOfCode.splitChars(m), f).join(""));
}

function makePassThurMask(__x) {
  return makeMask(__x, onlyXto1);
}

function makeOneMask(__x) {
  return makeMask(__x, only1to1);
}

function makeZeroMask(__x) {
  return makeMask(__x, only0to1);
}

function make(str) {
  return {
          mask: str.slice(7),
          mask_passthur: makeMask(str, onlyXto1),
          mask_one: makeMask(str, only1to1),
          mask_zero: makeMask(str, only0to1)
        };
}

function dump(t) {
  console.log("=== Mask dump ===");
  console.log(t.mask);
  
}

var Mask = {
  onlyXto1: onlyXto1,
  only1to1: only1to1,
  only0to1: only0to1,
  makeMask: makeMask,
  makePassThurMask: makePassThurMask,
  makeOneMask: makeOneMask,
  makeZeroMask: makeZeroMask,
  make: make,
  dump: dump
};

function make$1(str) {
  var prog_line_re = /mem\[(\d+)\]\s*=\s*(\d+)/i;
  var parsed = Belt_Array.map(Belt_Option.getExn(Caml_option.null_to_opt(prog_line_re.exec(str))), (function (l) {
          return Belt_Option.getExn((l == null) ? undefined : Caml_option.some(l));
        }));
  return {
          address: Belt_Option.getExn(Belt_Option.flatMap(Belt_Array.get(parsed, 1), Belt_Int.fromString)),
          value: Belt_Option.getExn(Belt_Option.flatMap(Belt_Array.get(parsed, 2), (function (x) {
                      return Caml_format.caml_int64_of_string(x);
                    })))
        };
}

function dump$1(t) {
  console.log("=== Memory dump ===");
  console.log(t);
  
}

var Memory = {
  make: make$1,
  dump: dump$1
};

var InvalidInstruction = /* @__PURE__ */Caml_exceptions.create("AOC2020_Day14-AdventOfCode.Program.InvalidInstruction");

function parseInstructions(lines) {
  return Belt_Array.map(lines, (function (l) {
                var match = l.substring(0, 4);
                switch (match) {
                  case "mask" :
                      return {
                              TAG: /* Mask */0,
                              _0: make(l)
                            };
                  case "mem[" :
                      return {
                              TAG: /* Mem */1,
                              _0: make$1(l)
                            };
                  default:
                    throw {
                          RE_EXN_ID: InvalidInstruction,
                          _1: l,
                          Error: new Error()
                        };
                }
              }));
}

function make$2(instructions) {
  return {
          instructions: parseInstructions(instructions),
          memory: Belt_MutableMapInt.make(undefined)
        };
}

function run(t) {
  var cur_m = {
    contents: make("mask = 11110000XXXX")
  };
  Belt_Array.forEach(t.instructions, (function (x) {
          if (x.TAG === /* Mask */0) {
            cur_m.contents = x._0;
            return dump(cur_m.contents);
          }
          var i = x._0;
          return Belt_MutableMapInt.update(t.memory, i.address, (function (v) {
                        dump$1(i);
                        return Caml_int64.and_(Caml_int64.or_(Caml_int64.and_(cur_m.contents.mask_passthur, i.value), cur_m.contents.mask_one), Int64.lognot(cur_m.contents.mask_zero));
                      }));
        }));
  return t.memory;
}

function dump$2(t) {
  console.log("=== Program dump ===");
  console.log(t.instructions);
  return Utils$AdventOfCode.dump_mutableMapInt_of_int64(t.memory);
}

var Program = {
  Mask: Mask,
  Memory: Memory,
  InvalidInstruction: InvalidInstruction,
  parseInstructions: parseInstructions,
  make: make$2,
  run: run,
  dump: dump$2
};

function parse(data) {
  return Belt_Array.map(Utils$AdventOfCode.splitNewline(data), (function (x) {
                return x.trim();
              }));
}

function solvePart1(data) {
  var prog = make$2(parse(data));
  dump$2(prog);
  var result = run(prog);
  var answer = Belt_MutableMapInt.reduce(result, Caml_int64.zero, (function (a, k, v) {
          return Caml_int64.add(v, a);
        }));
  var prim = Int64.to_string(answer);
  console.log(prim);
  return answer;
}

function solvePart2(data) {
  return 2;
}

exports.log = log;
exports.base2 = base2;
exports.Program = Program;
exports.parse = parse;
exports.solvePart1 = solvePart1;
exports.solvePart2 = solvePart2;
/* No side effect */
