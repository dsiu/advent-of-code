// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Belt_Int = require("rescript/lib/js/belt_Int.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Pervasives = require("rescript/lib/js/pervasives.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Belt_MutableMapInt = require("rescript/lib/js/belt_MutableMapInt.js");
var Utils$AdventOfCode = require("../../Utils.bs.js");

function log(prim) {
  console.log(prim);
  
}

function onlyXto1(c) {
  if (c === "X") {
    return "1";
  } else {
    return "0";
  }
}

function only1to1(c) {
  if (c === "1") {
    return "1";
  } else {
    return "0";
  }
}

function only0to1(c) {
  if (c === "0") {
    return "1";
  } else {
    return "0";
  }
}

function makeMask(m, f) {
  return parseInt(Belt_Array.map(Utils$AdventOfCode.splitChars(m), f).join(""), 2);
}

function makePassThurMask(__x) {
  return makeMask(__x, onlyXto1);
}

function makeOneMask(__x) {
  return makeMask(__x, only1to1);
}

function makeZeroMask(__x) {
  return makeMask(__x, only0to1);
}

function make(param) {
  var mask = param[0];
  return {
          mask: mask,
          mask_passthur: makeMask(mask, onlyXto1),
          mask_one: makeMask(mask, only1to1),
          mask_zero: makeMask(mask, only0to1),
          instructions: Belt_Array.map(param[1], (function (x) {
                  return {
                          address: Belt_Option.getExn(Belt_Option.flatMap(Belt_Array.get(x, 1), Belt_Int.fromString)),
                          value: Belt_Option.getExn(Belt_Option.flatMap(Belt_Array.get(x, 2), Belt_Int.fromString))
                        };
                }))
        };
}

function base2(__x) {
  return __x.toString(2);
}

function run(t) {
  var mem = Belt_MutableMapInt.make(undefined);
  Belt_Array.forEach(t.instructions, (function (i) {
          return Belt_MutableMapInt.update(mem, i.address, (function (v) {
                        return (t.mask_passthur ^ i.value | t.mask_one) & Pervasives.lnot(t.mask_zero);
                      }));
        }));
  return mem;
}

function dump(t) {
  console.log("dump");
  console.log(t.mask);
  var prim = t.mask_passthur.toString(2);
  console.log(prim);
  var prim$1 = t.mask_one.toString(2);
  console.log(prim$1);
  var prim$2 = t.mask_zero.toString(2);
  console.log(prim$2);
  console.log(t.instructions);
  
}

var Program = {
  onlyXto1: onlyXto1,
  only1to1: only1to1,
  only0to1: only0to1,
  makeMask: makeMask,
  makePassThurMask: makePassThurMask,
  makeOneMask: makeOneMask,
  makeZeroMask: makeZeroMask,
  make: make,
  base2: base2,
  run: run,
  dump: dump
};

function parse(data) {
  var lines = Belt_Array.map(Utils$AdventOfCode.splitNewline(data), (function (x) {
          return x.trim();
        }));
  var mask_line = Belt_Option.getExn(Belt_Array.get(lines, 0)).slice(7);
  var program_lines = Belt_Array.sliceToEnd(lines, 1);
  var prog_line_re = /mem\[(\d+)\]\s*=\s*(\d+)/i;
  var instructions = Belt_Array.map(program_lines, (function (x) {
          return Belt_Array.map(Belt_Option.getExn(Caml_option.null_to_opt(prog_line_re.exec(x))), (function (l) {
                        return Belt_Option.getExn((l == null) ? undefined : Caml_option.some(l));
                      }));
        }));
  return [
          mask_line,
          instructions
        ];
}

function solvePart1(data) {
  var prog = make(parse(data));
  dump(prog);
  Utils$AdventOfCode.dump_mutableMapInt_of_int_base2(run(prog));
  return 1;
}

function solvePart2(data) {
  return 2;
}

exports.log = log;
exports.Program = Program;
exports.parse = parse;
exports.solvePart1 = solvePart1;
exports.solvePart2 = solvePart2;
/* No side effect */
