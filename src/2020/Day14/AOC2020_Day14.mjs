// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Utils from "../../Utils.mjs";
import * as $$BigInt from "rescript/lib/es6/BigInt.js";
import * as Powerset from "../../Powerset.mjs";
import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/Belt_Option.js";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";
import * as Primitive_exceptions from "rescript/lib/es6/Primitive_exceptions.js";
import * as Belt_MutableMapString from "rescript/lib/es6/Belt_MutableMapString.js";

function toBigInt(str) {
  return BigInt("0b" + str);
}

function onlyXto1(c) {
  if (c === "X") {
    return "1";
  } else {
    return "0";
  }
}

function only1to1(c) {
  if (c === "1") {
    return "1";
  } else {
    return "0";
  }
}

function only0to1(c) {
  if (c === "0") {
    return "1";
  } else {
    return "0";
  }
}

function makeMask(m, f) {
  return Belt_Array.map(Utils.splitChars(m), f).join("");
}

function toString(param) {
  return "mask: " + param.mask + "\n" + ("mask_x: " + param.mask_x.toString() + "\n") + ("mask_x_str: " + param.mask_x_str) + ("mask_one: " + param.mask_one.toString() + "\n") + ("mask_zero: " + param.mask_zero.toString());
}

function makePassThurMask(__x) {
  return makeMask(__x, onlyXto1);
}

function makeOneMask(__x) {
  return makeMask(__x, only1to1);
}

function makeZeroMask(__x) {
  return makeMask(__x, only0to1);
}

function make(str) {
  let str$1 = makeMask(str, onlyXto1);
  let str$2 = makeMask(str, only1to1);
  let str$3 = makeMask(str, only0to1);
  return {
    mask: str.slice("mask = ".length),
    mask_x: BigInt("0b" + str$1),
    mask_x_str: makeMask(str, onlyXto1),
    mask_one: BigInt("0b" + str$2),
    mask_zero: BigInt("0b" + str$3)
  };
}

let Mask = {
  onlyXto1: onlyXto1,
  only1to1: only1to1,
  only0to1: only0to1,
  makeMask: makeMask,
  toString: toString,
  makePassThurMask: makePassThurMask,
  makeOneMask: makeOneMask,
  makeZeroMask: makeZeroMask,
  make: make
};

function make$1(str) {
  let prog_line_re = /mem\[(\d+)\]\s*=\s*(\d+)/i;
  let parsed = Belt_Array.map(Belt_Option.getExn(Primitive_option.fromNull(prog_line_re.exec(str))), l => Belt_Option.getExn((l == null) ? undefined : Primitive_option.some(l)));
  return {
    address: Belt_Option.getExn(Belt_Option.map(Belt_Array.get(parsed, 1), prim => BigInt(prim))),
    value: Belt_Option.getExn(Belt_Option.map(Belt_Array.get(parsed, 2), prim => BigInt(prim)))
  };
}

function toString$1(t) {
  return "address: " + t.address.toString() + "\nvalue: " + t.value.toString();
}

let Memory = {
  make: make$1,
  toString: toString$1
};

function instructionToString(i) {
  if (i.TAG === "MaskOp") {
    return "MaskOp(" + toString(i._0) + ")";
  } else {
    return "MemOp(" + toString$1(i._0) + ")";
  }
}

let InvalidInstruction = /* @__PURE__ */Primitive_exceptions.create("AOC2020_Day14.Program.InvalidInstruction");

function parse(lines) {
  return Belt_Array.map(lines, l => {
    let match = l.substring(0, 4);
    switch (match) {
      case "mask" :
        return {
          TAG: "MaskOp",
          _0: make(l)
        };
      case "mem[" :
        return {
          TAG: "MemOp",
          _0: make$1(l)
        };
      default:
        throw {
          RE_EXN_ID: InvalidInstruction,
          _1: l,
          Error: new Error()
        };
    }
  });
}

function make$2(instructions) {
  return {
    instructions: parse(instructions),
    memory: Belt_MutableMapString.make()
  };
}

function decodeMemory(mask, mem_value) {
  return (mask.mask_x & mem_value | mask.mask_one) & $$BigInt.lnot(mask.mask_zero);
}

function part1Algo(space, mask, mem) {
  Belt_MutableMapString.update(space, mem.address.toString(), v => decodeMemory(mask, mem.value));
}

function bit1Index(m) {
  let xs = Utils.splitChars(m);
  let len = xs.length;
  return Belt_Array.reduceWithIndex(xs, [], (a, x, i) => {
    if (x === "1") {
      return Belt_Array.concat(a, [(len - 1 | 0) - i | 0]);
    } else {
      return a;
    }
  });
}

function decodeAddress(mask, mem_address) {
  let pos_mask = $$BigInt.lnot(mask.mask_x);
  let base = (mem_address | mask.mask_one) & pos_mask;
  let pos = bit1Index(mask.mask_x_str);
  let all_pos = Powerset.powersetArray(pos);
  return Belt_Array.map(all_pos, pos => {
    let m = Belt_Array.reduce(pos, 0n, (acc, x) => acc | (1n << BigInt(x)));
    return (base | m).toString();
  });
}

function part2Algo(space, mask, mem) {
  let addresses = decodeAddress(mask, mem.address);
  Belt_Array.forEach(addresses, addr => Belt_MutableMapString.update(space, addr, v => mem.value));
}

function run(t, algo) {
  let cur_m = {
    contents: make("mask = 11110000XXXX")
  };
  Belt_Array.forEach(t.instructions, x => {
    if (x.TAG === "MaskOp") {
      cur_m.contents = x._0;
      return;
    } else {
      return algo(t.memory, cur_m.contents, x._0);
    }
  });
  return t.memory;
}

function runPart1(__x) {
  return run(__x, part1Algo);
}

function runPart2(__x) {
  return run(__x, part2Algo);
}

function toString$2(t) {
  return "=== Program dump ===\n" + Utils.Printable.$$Array.toString(t.instructions, instructionToString) + "\n" + Utils.Printable.MutableMapString.$$BigInt.toString(t.memory, undefined);
}

let Program = {
  Mask: Mask,
  Memory: Memory,
  instructionToString: instructionToString,
  InvalidInstruction: InvalidInstruction,
  parse: parse,
  make: make$2,
  decodeMemory: decodeMemory,
  part1Algo: part1Algo,
  bit1Index: bit1Index,
  decodeAddress: decodeAddress,
  part2Algo: part2Algo,
  run: run,
  runPart1: runPart1,
  runPart2: runPart2,
  toString: toString$2
};

function parse$1(data) {
  return Belt_Array.map(Utils.splitNewline(data), x => x.trim());
}

function memoryToAnswer(__x) {
  return Belt_MutableMapString.reduce(__x, 0n, (a, k, v) => v + a);
}

function solvePart1(data) {
  let prog = make$2(parse$1(data));
  return memoryToAnswer(run(prog, part1Algo));
}

function solvePart2(data) {
  let prog = make$2(parse$1(data));
  return memoryToAnswer(run(prog, part2Algo));
}

export {
  toBigInt,
  Program,
  parse$1 as parse,
  memoryToAnswer,
  solvePart1,
  solvePart2,
}
/* Utils Not a pure module */
