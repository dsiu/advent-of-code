// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as TableclothInt from "tablecloth-rescript/src/TableclothInt.mjs";
import * as TableclothSet from "tablecloth-rescript/src/TableclothSet.mjs";
import * as TableclothTuple3 from "tablecloth-rescript/src/TableclothTuple3.mjs";
import * as Utils$AdventOfCode from "../../Utils.mjs";
import * as TableclothComparator from "tablecloth-rescript/src/TableclothComparator.mjs";
import * as FP_Utils$AdventOfCode from "../../FP_Utils.mjs";

function log(prim) {
  console.log(prim);
}

function compare(param) {
  return function (param$1) {
    var param$2 = TableclothInt.compare;
    var param$3 = TableclothInt.compare;
    var param$4 = TableclothInt.compare;
    return TableclothTuple3.compare(param, param$1, param$2, param$3, param$4);
  };
}

var include = TableclothComparator.Make({
      compare: compare
    });

var comparator = include.comparator;

function add(param, param$1) {
  return [
          param[0] + param$1[0] | 0,
          param[1] + param$1[1] | 0,
          param[2] + param$1[2] | 0
        ];
}

var Coord = {
  compare: compare,
  comparator: comparator,
  add: add
};

function makeGrid(lines) {
  var createActive = function (x, y) {
    if (Belt_Array.getExn(Belt_Array.getExn(lines, y), x) === "#") {
      return [
              x,
              y,
              0
            ];
    }
    
  };
  var maxX = Belt_Array.getExn(lines, 0).length - 1 | 0;
  var maxY = lines.length - 1 | 0;
  var xs = Belt_Array.range(0, maxX);
  var ys = Belt_Array.range(0, maxY);
  return TableclothSet.fromArray(FP_Utils$AdventOfCode.combinationIfArray2(xs, ys, createActive), {
              comparator: comparator
            });
}

function neighbourSpaces(here) {
  return TableclothSet.fromArray(FP_Utils$AdventOfCode.combinationIfArray3([
                  -1,
                  0,
                  1
                ], [
                  -1,
                  0,
                  1
                ], [
                  -1,
                  0,
                  1
                ], (function (x, y, z) {
                    if (x === 0 && y === 0 && z === 0) {
                      return ;
                    } else {
                      return add([
                                  x,
                                  y,
                                  z
                                ], here);
                    }
                  })), {
              comparator: comparator
            });
}

function countOccupiedNeighbours(cell, grid) {
  return TableclothSet.length(TableclothSet.intersection(neighbourSpaces(cell), grid._0));
}

function cubeSurvives(grid, cell) {
  var grid$1 = grid._0;
  var alive = TableclothSet.includes(grid$1, cell);
  var nNbrs = countOccupiedNeighbours(cell, /* Grid */{
        _0: grid$1
      });
  if (alive) {
    if (nNbrs === 2) {
      return true;
    } else {
      return nNbrs === 3;
    }
  } else {
    return false;
  }
}

function cubeBorn(grid, cell) {
  var grid$1 = grid._0;
  var dead = !TableclothSet.includes(grid$1, cell);
  var nNbrs = countOccupiedNeighbours(cell, /* Grid */{
        _0: grid$1
      });
  if (dead) {
    return nNbrs === 3;
  } else {
    return false;
  }
}

function update(grid) {
  var grid$1 = grid._0;
  var mergeEmpties = function (acc, cell) {
    return TableclothSet.union(acc, neighbourSpaces(cell));
  };
  var empties = TableclothSet.difference(TableclothSet.fold(grid$1, TableclothSet.empty({
                comparator: comparator
              }), mergeEmpties), grid$1);
  var partial_arg = /* Grid */{
    _0: grid$1
  };
  var partial_arg$1 = /* Grid */{
    _0: grid$1
  };
  return /* Grid */{
          _0: TableclothSet.union(TableclothSet.filter(grid$1, (function (param) {
                      return cubeSurvives(partial_arg, param);
                    })), TableclothSet.filter(empties, (function (param) {
                      return cubeBorn(partial_arg$1, param);
                    })))
        };
}

function iterate(_grid, f, _times) {
  while(true) {
    var grid = _grid;
    var times = _times;
    var grid$1 = grid._0;
    if (times === 0) {
      return grid$1;
    }
    _times = times - 1 | 0;
    _grid = Curry._1(f, /* Grid */{
          _0: grid$1
        });
    continue ;
  };
}

function parse(data) {
  return Belt_Array.map(Utils$AdventOfCode.splitNewline(data), (function (param) {
                return FP_Utils$AdventOfCode.compose((function (prim) {
                              return prim.trim();
                            }), Utils$AdventOfCode.splitChars, param);
              }));
}

function solvePart1(data) {
  var grid0 = makeGrid(parse(data));
  return TableclothSet.length(iterate(/* Grid */{
                  _0: grid0
                }, update, 6));
}

function solvePart2(data) {
  return 2;
}

var TC;

export {
  log ,
  TC ,
  Coord ,
  makeGrid ,
  neighbourSpaces ,
  countOccupiedNeighbours ,
  cubeSurvives ,
  cubeBorn ,
  update ,
  iterate ,
  parse ,
  solvePart1 ,
  solvePart2 ,
}
/* include Not a pure module */
