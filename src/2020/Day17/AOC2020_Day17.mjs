// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Pervasives from "rescript/lib/es6/Pervasives.js";
import * as Stdlib__Array from "@dsiu/rescript-stdlib-fp/src/Stdlib__Array.mjs";
import * as TableclothSet from "@dsiu/rescript-stdlib-fp/src/Tablecloth/TableclothSet.mjs";
import * as Utils$AdventOfCode from "../../Utils.mjs";
import * as TableclothComparator from "@dsiu/rescript-stdlib-fp/src/Tablecloth/TableclothComparator.mjs";
import * as Coord_V3$AdventOfCode from "../../Coord_V3.mjs";
import * as Coord_V4$AdventOfCode from "../../Coord_V4.mjs";

function log(prim) {
  console.log(prim);
}

function compare(a, b) {
  if (a.TAG === "Coord_V3") {
    if (b.TAG === "Coord_V3") {
      return Coord_V3$AdventOfCode.compare(a._0, b._0);
    } else {
      return Pervasives.failwith("Invalid comparison");
    }
  } else if (b.TAG === "Coord_V3") {
    return Pervasives.failwith("Invalid comparison");
  } else {
    return Coord_V4$AdventOfCode.compare(a._0, b._0);
  }
}

let include = TableclothComparator.Make({
  compare: compare
});

let comparator = include.comparator;

function add(a, b) {
  if (a.TAG === "Coord_V3") {
    if (b.TAG === "Coord_V3") {
      return {
        TAG: "Coord_V3",
        _0: Coord_V3$AdventOfCode.add(a._0, b._0)
      };
    } else {
      return Pervasives.failwith("Invalid addition");
    }
  } else if (b.TAG === "Coord_V3") {
    return Pervasives.failwith("Invalid addition");
  } else {
    return {
      TAG: "Coord_V4",
      _0: Coord_V4$AdventOfCode.add(a._0, b._0)
    };
  }
}

let Coord = {
  compare: compare,
  comparator: comparator,
  add: add
};

function makeGrid(lines) {
  let createActive = (x, y) => {
    if (Belt_Array.getExn(Belt_Array.getExn(lines, y), x) === "#") {
      return {
        TAG: "Coord_V3",
        _0: [
          x,
          y,
          0
        ]
      };
    }
    
  };
  let maxX = Belt_Array.getExn(lines, 0).length - 1 | 0;
  let maxY = lines.length - 1 | 0;
  let xs = Belt_Array.range(0, maxX);
  let ys = Belt_Array.range(0, maxY);
  return TableclothSet.fromArray(Stdlib__Array.combinationIf2(xs, ys, createActive), {
    comparator: comparator
  });
}

function conv34Cell(param) {
  if (param.TAG === "Coord_V3") {
    let match = param._0;
    return {
      TAG: "Coord_V4",
      _0: [
        match[0],
        match[1],
        match[2],
        0
      ]
    };
  }
  throw {
    RE_EXN_ID: "Match_failure",
    _1: [
      "AOC2020_Day17.res",
      56,
      18
    ],
    Error: new Error()
  };
}

function conv34(grid) {
  return TableclothSet.fromArray(TableclothSet.toArray(grid).map(conv34Cell), {
    comparator: comparator
  });
}

function neighbourSpaces(here) {
  if (here.TAG === "Coord_V3") {
    return TableclothSet.fromArray(Stdlib__Array.combinationIf3([
      -1,
      0,
      1
    ], [
      -1,
      0,
      1
    ], [
      -1,
      0,
      1
    ], (x, y, z) => {
      if (x === 0 && y === 0 && z === 0) {
        return;
      } else {
        return add({
          TAG: "Coord_V3",
          _0: [
            x,
            y,
            z
          ]
        }, here);
      }
    }), {
      comparator: comparator
    });
  } else {
    return TableclothSet.fromArray(Stdlib__Array.combinationIf4([
      -1,
      0,
      1
    ], [
      -1,
      0,
      1
    ], [
      -1,
      0,
      1
    ], [
      -1,
      0,
      1
    ], (x, y, z, w) => {
      if (x === 0 && y === 0 && z === 0 && w === 0) {
        return;
      } else {
        return add({
          TAG: "Coord_V4",
          _0: [
            x,
            y,
            z,
            w
          ]
        }, here);
      }
    }), {
      comparator: comparator
    });
  }
}

function countOccupiedNeighbours(cell, grid) {
  return TableclothSet.length(TableclothSet.intersection(neighbourSpaces(cell), grid));
}

function cubeSurvives(grid, cell) {
  let alive = TableclothSet.includes(grid, cell);
  let nNbrs = countOccupiedNeighbours(cell, grid);
  if (alive) {
    if (nNbrs === 2) {
      return true;
    } else {
      return nNbrs === 3;
    }
  } else {
    return false;
  }
}

function cubeBorn(grid, cell) {
  let dead = !TableclothSet.includes(grid, cell);
  let nNbrs = countOccupiedNeighbours(cell, grid);
  if (dead) {
    return nNbrs === 3;
  } else {
    return false;
  }
}

function update(grid) {
  let mergeEmpties = (acc, cell) => TableclothSet.union(acc, neighbourSpaces(cell));
  let empties = TableclothSet.difference(TableclothSet.fold(grid, TableclothSet.empty({
    comparator: comparator
  }), mergeEmpties), grid);
  return TableclothSet.union(TableclothSet.filter(grid, __x => cubeSurvives(grid, __x)), TableclothSet.filter(empties, __x => cubeBorn(grid, __x)));
}

function iterate(_grid, f, _times) {
  while (true) {
    let times = _times;
    let grid = _grid;
    if (times === 0) {
      return grid;
    }
    _times = times - 1 | 0;
    _grid = f(grid);
    continue;
  };
}

function parse(data) {
  return Belt_Array.map(Utils$AdventOfCode.splitNewline(data), Utils$AdventOfCode.compose(prim => prim.trim(), Utils$AdventOfCode.splitChars));
}

function solvePart1(data) {
  let prim = parse(data);
  console.log(prim);
  let grid0 = makeGrid(parse(data));
  console.log(grid0);
  return TableclothSet.length(iterate(grid0, update, 6));
}

function solvePart2(data) {
  let grid = conv34(makeGrid(parse(data)));
  return TableclothSet.length(iterate(grid, update, 6));
}

let TC;

export {
  log,
  TC,
  Coord,
  makeGrid,
  conv34Cell,
  conv34,
  neighbourSpaces,
  countOccupiedNeighbours,
  cubeSurvives,
  cubeBorn,
  update,
  iterate,
  parse,
  solvePart1,
  solvePart2,
}
/* include Not a pure module */
