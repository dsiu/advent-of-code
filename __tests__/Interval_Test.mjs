// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Jest from "@glennsl/rescript-jest/src/jest.mjs";
import * as Interval from "../src/Interval.mjs";

Jest.describe("Interval", () => {
  Jest.describe("length", () => {
    Jest.test("length - returns correct length for positive interval", () => {
      let interval_0 = BigInt(1);
      let interval_1 = BigInt(5);
      let interval = [
        interval_0,
        interval_1
      ];
      let expected = BigInt(5);
      return Jest.Expect.toEqual(Jest.Expect.expect(Interval.length(interval)), expected);
    });
    Jest.test("length - returns correct length for zero-length interval", () => {
      let interval_0 = BigInt(3);
      let interval_1 = BigInt(3);
      let interval = [
        interval_0,
        interval_1
      ];
      let expected = BigInt(1);
      return Jest.Expect.toEqual(Jest.Expect.expect(Interval.length(interval)), expected);
    });
    Jest.test("length - returns correct length for negative interval", () => {
      let interval_0 = BigInt(5);
      let interval_1 = BigInt(1);
      let interval = [
        interval_0,
        interval_1
      ];
      let expected = BigInt(5);
      return Jest.Expect.toEqual(Jest.Expect.expect(Interval.length(interval)), expected);
    });
  });
  Jest.describe("contains", () => {
    Jest.test("contains - returns true when number is within the interval", () => {
      let interval_0 = BigInt(5);
      let interval_1 = BigInt(10);
      let interval = [
        interval_0,
        interval_1
      ];
      let num = BigInt(7);
      return Jest.Expect.toBe(Jest.Expect.expect(Interval.contains(interval, num)), true);
    });
    Jest.test("contains - returns true when number is equal to the lower bound", () => {
      let interval_0 = BigInt(5);
      let interval_1 = BigInt(10);
      let interval = [
        interval_0,
        interval_1
      ];
      let num = BigInt(5);
      return Jest.Expect.toBe(Jest.Expect.expect(Interval.contains(interval, num)), true);
    });
    Jest.test("contains - returns true when number is equal to the upper bound", () => {
      let interval_0 = BigInt(5);
      let interval_1 = BigInt(10);
      let interval = [
        interval_0,
        interval_1
      ];
      let num = BigInt(10);
      return Jest.Expect.toBe(Jest.Expect.expect(Interval.contains(interval, num)), true);
    });
    Jest.test("contains - returns false when number is less than the lower bound", () => {
      let interval_0 = BigInt(5);
      let interval_1 = BigInt(10);
      let interval = [
        interval_0,
        interval_1
      ];
      let num = BigInt(4);
      return Jest.Expect.toBe(Jest.Expect.expect(Interval.contains(interval, num)), false);
    });
    Jest.test("contains - returns false when number is greater than the upper bound", () => {
      let interval_0 = BigInt(5);
      let interval_1 = BigInt(10);
      let interval = [
        interval_0,
        interval_1
      ];
      let num = BigInt(11);
      return Jest.Expect.toBe(Jest.Expect.expect(Interval.contains(interval, num)), false);
    });
    Jest.test("contains - returns false when the number is not in interval with length 1", () => {
      let interval_0 = BigInt(5);
      let interval_1 = BigInt(5);
      let interval = [
        interval_0,
        interval_1
      ];
      let num = BigInt(4);
      return Jest.Expect.toBe(Jest.Expect.expect(Interval.contains(interval, num)), false);
    });
    Jest.test("contains - returns true when the number is in interval with length 1", () => {
      let interval_0 = BigInt(5);
      let interval_1 = BigInt(5);
      let interval = [
        interval_0,
        interval_1
      ];
      let num = BigInt(5);
      return Jest.Expect.toBe(Jest.Expect.expect(Interval.contains(interval, num)), true);
    });
  });
  Jest.describe("isOverlap", () => {
    Jest.test("isOverlap - returns true when intervals overlap", () => {
      let interval1 = Interval.make(BigInt(5), BigInt(10));
      let interval2 = Interval.make(BigInt(7), BigInt(12));
      return Jest.Expect.toBe(Jest.Expect.expect(Interval.isOverlap(interval1, interval2)), true);
    });
    Jest.test("isOverlap - returns false when intervals do not overlap", () => {
      let interval1 = Interval.make(BigInt(5), BigInt(10));
      let interval2 = Interval.make(BigInt(11), BigInt(15));
      return Jest.Expect.toBe(Jest.Expect.expect(Interval.isOverlap(interval1, interval2)), false);
    });
    Jest.test("isOverlap - returns true when intervals touch at one point on right", () => {
      let interval1 = Interval.make(BigInt(5), BigInt(10));
      let interval2 = Interval.make(BigInt(10), BigInt(15));
      return Jest.Expect.toBe(Jest.Expect.expect(Interval.isOverlap(interval1, interval2)), true);
    });
    Jest.test("isOverlap - returns true when intervals touch at one point on left", () => {
      let interval1 = Interval.make(BigInt(6), BigInt(11));
      let interval2 = Interval.make(BigInt(3), BigInt(6));
      return Jest.Expect.toBe(Jest.Expect.expect(Interval.isOverlap(interval1, interval2)), true);
    });
    Jest.test("isOverlap - returns true when a contains b", () => {
      let interval1 = Interval.make(BigInt(1), BigInt(10));
      let interval2 = Interval.make(BigInt(3), BigInt(6));
      return Jest.Expect.toBe(Jest.Expect.expect(Interval.isOverlap(interval1, interval2)), true);
    });
    Jest.test("isOverlap - returns true when b contains a", () => {
      let interval1 = Interval.make(BigInt(5), BigInt(9));
      let interval2 = Interval.make(BigInt(1), BigInt(12));
      return Jest.Expect.toBe(Jest.Expect.expect(Interval.isOverlap(interval1, interval2)), true);
    });
    Jest.test("isOverlap - returns true when both a and b are some", () => {
      let interval1 = Interval.make(BigInt(13), BigInt(13));
      let interval2 = Interval.make(BigInt(13), BigInt(13));
      return Jest.Expect.toBe(Jest.Expect.expect(Interval.isOverlap(interval1, interval2)), true);
    });
  });
  Jest.describe("intersect", () => {
    Jest.test("intersect - returns intersection when intervals overlap", () => {
      let interval1 = Interval.make(BigInt(5), BigInt(10));
      let interval2 = Interval.make(BigInt(7), BigInt(12));
      return Jest.Expect.toEqual(Jest.Expect.expect(Interval.intersect(interval1, interval2)), Interval.make(BigInt(7), BigInt(10)));
    });
    Jest.test("intersect - returns None when intervals do not overlap", () => {
      let interval1 = Interval.make(BigInt(5), BigInt(10));
      let interval2 = Interval.make(BigInt(11), BigInt(15));
      return Jest.Expect.toBe(Jest.Expect.expect(Interval.intersect(interval1, interval2)), undefined);
    });
    Jest.test("intersect - returns intersection when intervals touch at one point", () => {
      let interval1 = Interval.make(BigInt(5), BigInt(10));
      let interval2 = Interval.make(BigInt(10), BigInt(15));
      return Jest.Expect.toEqual(Jest.Expect.expect(Interval.intersect(interval1, interval2)), Interval.make(BigInt(10), BigInt(10)));
    });
    Jest.test("intersect - returns intersection both intervals are length 1", () => {
      let interval1 = Interval.make(BigInt(5), BigInt(5));
      let interval2 = Interval.make(BigInt(5), BigInt(5));
      return Jest.Expect.toEqual(Jest.Expect.expect(Interval.intersect(interval1, interval2)), Interval.make(BigInt(5), BigInt(5)));
    });
    Jest.test("intersect - returns intersection a interval is length 1 and the other is inside", () => {
      let interval1 = Interval.make(BigInt(7), BigInt(7));
      let interval2 = Interval.make(BigInt(1), BigInt(10));
      return Jest.Expect.toEqual(Jest.Expect.expect(Interval.intersect(interval1, interval2)), Interval.make(BigInt(7), BigInt(7)));
    });
  });
  Jest.describe("below", () => {
    Jest.test("below - returns true when first interval is below the second", () => {
      let interval1 = Interval.make(BigInt(5), BigInt(10));
      let interval2 = Interval.make(BigInt(12), BigInt(15));
      return Jest.Expect.toBe(Jest.Expect.expect(Interval.below(interval1, interval2)), true);
    });
    Jest.test("below - returns false when first interval is above the second", () => {
      let interval1 = Interval.make(BigInt(12), BigInt(15));
      let interval2 = Interval.make(BigInt(5), BigInt(10));
      return Jest.Expect.toBe(Jest.Expect.expect(Interval.below(interval1, interval2)), false);
    });
    Jest.test("below - returns false when intervals overlap", () => {
      let interval1 = Interval.make(BigInt(5), BigInt(10));
      let interval2 = Interval.make(BigInt(7), BigInt(12));
      return Jest.Expect.toBe(Jest.Expect.expect(Interval.below(interval1, interval2)), false);
    });
  });
  Jest.describe("adjacent", () => {
    Jest.test("adjacent - returns true when intervals are adjacent and not overlapping", () => {
      let interval1 = Interval.make(BigInt(5), BigInt(10));
      let interval2 = Interval.make(BigInt(11), BigInt(15));
      return Jest.Expect.toBe(Jest.Expect.expect(Interval.adjacent(interval1, interval2)), true);
    });
    Jest.test("adjacent - returns false when intervals are overlapping", () => {
      let interval1 = Interval.make(BigInt(5), BigInt(10));
      let interval2 = Interval.make(BigInt(7), BigInt(12));
      return Jest.Expect.toBe(Jest.Expect.expect(Interval.adjacent(interval1, interval2)), false);
    });
    Jest.test("adjacent - returns false when intervals are not adjacent and not overlapping", () => {
      let interval1 = Interval.make(BigInt(5), BigInt(10));
      let interval2 = Interval.make(BigInt(15), BigInt(20));
      return Jest.Expect.toBe(Jest.Expect.expect(Interval.adjacent(interval1, interval2)), false);
    });
  });
  Jest.describe("remove", () => {
    Jest.test("remove - returns a when intervals do not overlap", () => {
      let a = Interval.make(BigInt(1), BigInt(5));
      let b = Interval.make(BigInt(6), BigInt(10));
      let result = Interval.remove(a, b);
      let expected = [
        BigInt(1),
        BigInt(5)
      ];
      return Jest.Expect.toEqual(Jest.Expect.expect(result), expected);
    });
    Jest.test("remove - returns None when b is all contained within a", () => {
      let a = Interval.make(BigInt(1), BigInt(10));
      let b = Interval.make(BigInt(3), BigInt(7));
      let result = Interval.remove(a, b);
      return Jest.Expect.toEqual(Jest.Expect.expect(result), undefined);
    });
    Jest.test("remove - returns None when a is contained within b", () => {
      let a = Interval.make(BigInt(3), BigInt(7));
      let b = Interval.make(BigInt(1), BigInt(10));
      let result = Interval.remove(a, b);
      return Jest.Expect.toEqual(Jest.Expect.expect(result), undefined);
    });
    Jest.test("remove - returns None when a and b are the same", () => {
      let a = Interval.make(BigInt(3), BigInt(7));
      let b = Interval.make(BigInt(3), BigInt(7));
      let result = Interval.remove(a, b);
      return Jest.Expect.toEqual(Jest.Expect.expect(result), undefined);
    });
    Jest.test("remove - returns None when a and b are single point intervals and are the same", () => {
      let a = Interval.make(BigInt(3), BigInt(3));
      let b = Interval.make(BigInt(3), BigInt(3));
      let result = Interval.remove(a, b);
      return Jest.Expect.toEqual(Jest.Expect.expect(result), undefined);
    });
    Jest.test("remove - returns Some(a) when a and b are single point intervals and are different", () => {
      let a = Interval.make(BigInt(3), BigInt(3));
      let b = Interval.make(BigInt(4), BigInt(4));
      let result = Interval.remove(a, b);
      let expected = [
        BigInt(3),
        BigInt(3)
      ];
      return Jest.Expect.toEqual(Jest.Expect.expect(result), expected);
    });
  });
  Jest.describe("Sort", () => {
    Jest.test("sort - sorts intervals by lower bound ascending, then upper bound ascending", () => {
      let intervals = [
        [
          BigInt(3),
          BigInt(5)
        ],
        [
          BigInt(1),
          BigInt(2)
        ],
        [
          BigInt(1),
          BigInt(4)
        ]
      ];
      let expected = [
        [
          BigInt(1),
          BigInt(2)
        ],
        [
          BigInt(1),
          BigInt(4)
        ],
        [
          BigInt(3),
          BigInt(5)
        ]
      ];
      return Jest.Expect.toEqual(Jest.Expect.expect(Interval.sort(intervals)), expected);
    });
    Jest.test("sort - handles equal lower bounds by sorting by upper bound", () => {
      let intervals = [
        [
          BigInt(1),
          BigInt(5)
        ],
        [
          BigInt(1),
          BigInt(2)
        ],
        [
          BigInt(1),
          BigInt(4)
        ]
      ];
      let expected = [
        [
          BigInt(1),
          BigInt(2)
        ],
        [
          BigInt(1),
          BigInt(4)
        ],
        [
          BigInt(1),
          BigInt(5)
        ]
      ];
      return Jest.Expect.toEqual(Jest.Expect.expect(Interval.sort(intervals)), expected);
    });
    Jest.test("sort - handles equal intervals correctly", () => {
      let intervals = [
        [
          BigInt(1),
          BigInt(2)
        ],
        [
          BigInt(1),
          BigInt(2)
        ],
        [
          BigInt(1),
          BigInt(2)
        ]
      ];
      let expected = [
        [
          BigInt(1),
          BigInt(2)
        ],
        [
          BigInt(1),
          BigInt(2)
        ],
        [
          BigInt(1),
          BigInt(2)
        ]
      ];
      return Jest.Expect.toEqual(Jest.Expect.expect(Interval.sort(intervals)), expected);
    });
    Jest.test("sort - handles empty array correctly", () => {
      let intervals = [];
      let expected = [];
      return Jest.Expect.toEqual(Jest.Expect.expect(Interval.sort(intervals)), expected);
    });
  });
  Jest.describe("merge", () => {
    Jest.test("merge - merges two overlapping intervals", () => {
      let interval1_0 = BigInt(1);
      let interval1_1 = BigInt(3);
      let interval1 = [
        interval1_0,
        interval1_1
      ];
      let interval2_0 = BigInt(2);
      let interval2_1 = BigInt(4);
      let interval2 = [
        interval2_0,
        interval2_1
      ];
      let expected_0 = BigInt(1);
      let expected_1 = BigInt(4);
      let expected = [
        expected_0,
        expected_1
      ];
      return Jest.Expect.toEqual(Jest.Expect.expect(Interval.merge(interval1, interval2)), expected);
    });
    Jest.test("merge - merges two connected intervals", () => {
      let interval1_0 = BigInt(1);
      let interval1_1 = BigInt(2);
      let interval1 = [
        interval1_0,
        interval1_1
      ];
      let interval2_0 = BigInt(3);
      let interval2_1 = BigInt(4);
      let interval2 = [
        interval2_0,
        interval2_1
      ];
      let expected_0 = BigInt(1);
      let expected_1 = BigInt(4);
      let expected = [
        expected_0,
        expected_1
      ];
      return Jest.Expect.toEqual(Jest.Expect.expect(Interval.merge(interval1, interval2)), expected);
    });
    Jest.test("merge - throws error when intervals are not connected or overlapping", () => {
      let interval1_0 = BigInt(1);
      let interval1_1 = BigInt(2);
      let interval1 = [
        interval1_0,
        interval1_1
      ];
      let interval2_0 = BigInt(4);
      let interval2_1 = BigInt(5);
      let interval2 = [
        interval2_0,
        interval2_1
      ];
      let mergeFunction = () => Interval.merge(interval1, interval2);
      return Jest.Expect.toThrow(Jest.Expect.expect(mergeFunction));
    });
    Jest.test("merge - interval within another interval", () => {
      let interval1_0 = BigInt(1);
      let interval1_1 = BigInt(5);
      let interval1 = [
        interval1_0,
        interval1_1
      ];
      let interval2_0 = BigInt(2);
      let interval2_1 = BigInt(4);
      let interval2 = [
        interval2_0,
        interval2_1
      ];
      let expected_0 = BigInt(1);
      let expected_1 = BigInt(5);
      let expected = [
        expected_0,
        expected_1
      ];
      return Jest.Expect.toEqual(Jest.Expect.expect(Interval.merge(interval1, interval2)), expected);
    });
  });
  Jest.describe("sortAndMergeOverlaps", () => {
    Jest.test("sortAndMergeOverlaps - overlapping intervals", () => {
      let intervals = [
        [
          BigInt(3),
          BigInt(7)
        ],
        [
          BigInt(1),
          BigInt(5)
        ],
        [
          BigInt(2),
          BigInt(6)
        ],
        [
          BigInt(4),
          BigInt(8)
        ]
      ];
      let result = Interval.sortAndMergeOverlaps(intervals);
      let expected = [[
          BigInt(1),
          BigInt(8)
        ]];
      return Jest.Expect.toEqual(Jest.Expect.expect(result), expected);
    });
    Jest.test("sortAndMergeOverlaps - non-overlapping connecting intervals", () => {
      let intervals = [
        [
          BigInt(1),
          BigInt(2)
        ],
        [
          BigInt(3),
          BigInt(4)
        ],
        [
          BigInt(5),
          BigInt(6)
        ],
        [
          BigInt(7),
          BigInt(8)
        ]
      ];
      let result = Interval.sortAndMergeOverlaps(intervals);
      let expected = [[
          BigInt(1),
          BigInt(8)
        ]];
      return Jest.Expect.toEqual(Jest.Expect.expect(result), expected);
    });
    Jest.test("sortAndMergeOverlaps - non-overlapping non-connecting intervals", () => {
      let intervals = [
        [
          BigInt(4),
          BigInt(5)
        ],
        [
          BigInt(1),
          BigInt(2)
        ],
        [
          BigInt(10),
          BigInt(11)
        ],
        [
          BigInt(7),
          BigInt(8)
        ]
      ];
      let result = Interval.sortAndMergeOverlaps(intervals);
      let expected = [
        [
          BigInt(1),
          BigInt(2)
        ],
        [
          BigInt(4),
          BigInt(5)
        ],
        [
          BigInt(7),
          BigInt(8)
        ],
        [
          BigInt(10),
          BigInt(11)
        ]
      ];
      return Jest.Expect.toEqual(Jest.Expect.expect(result), expected);
    });
    Jest.test("sortAndMergeOverlaps - some overlapping some connecting intervals", () => {
      let intervals = [
        [
          BigInt(3),
          BigInt(5)
        ],
        [
          BigInt(1),
          BigInt(4)
        ],
        [
          BigInt(9),
          BigInt(10)
        ],
        [
          BigInt(7),
          BigInt(8)
        ]
      ];
      let result = Interval.sortAndMergeOverlaps(intervals);
      let expected = [
        [
          BigInt(1),
          BigInt(5)
        ],
        [
          BigInt(7),
          BigInt(10)
        ]
      ];
      return Jest.Expect.toEqual(Jest.Expect.expect(result), expected);
    });
    Jest.test("sortAndMergeOverlaps - identical intervals", () => {
      let intervals = [
        [
          BigInt(1),
          BigInt(5)
        ],
        [
          BigInt(1),
          BigInt(5)
        ],
        [
          BigInt(1),
          BigInt(5)
        ],
        [
          BigInt(1),
          BigInt(5)
        ]
      ];
      let result = Interval.sortAndMergeOverlaps(intervals);
      let expected = [[
          BigInt(1),
          BigInt(5)
        ]];
      return Jest.Expect.toEqual(Jest.Expect.expect(result), expected);
    });
    Jest.test("sortAndMergeOverlaps - interval within another interval", () => {
      let intervals = [
        [
          BigInt(1),
          BigInt(5)
        ],
        [
          BigInt(2),
          BigInt(4)
        ],
        [
          BigInt(3),
          BigInt(3)
        ],
        [
          BigInt(1),
          BigInt(5)
        ]
      ];
      let result = Interval.sortAndMergeOverlaps(intervals);
      let expected = [[
          BigInt(1),
          BigInt(5)
        ]];
      return Jest.Expect.toEqual(Jest.Expect.expect(result), expected);
    });
  });
});

/*  Not a pure module */
